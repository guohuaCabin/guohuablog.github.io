<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS之项目总结二：关于项目中一些功能的改进建议（从一个维护者的角度） | 所念皆星辰 | 踏实、低调、前行。</title>

  
  <meta name="author" content="Wheat">
  

  
  <meta name="description" content="简单的一个技术博客，用来作为学习笔记和日常记录使用。">
  

  
  
  <meta name="keywords" content="iOS">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="iOS之项目总结二：关于项目中一些功能的改进建议（从一个维护者的角度）"/>

  <meta property="og:site_name" content="所念皆星辰"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="所念皆星辰" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">所念皆星辰</a>
    </h1>
    <p class="site-description">踏实、低调、前行。</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>iOS之项目总结二：关于项目中一些功能的改进建议（从一个维护者的角度）</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/01/11/project-summary-two/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-11T15:38:00.000Z">
          2017-01-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近一直在维护老的项目，遇到的问题也千奇百怪，需要修补的，需要优化的，需要特殊处理的，感觉总是那么的无语。也许这时候也应该感叹一句：路漫漫其修远兮，吾将上下而求索吧。<br>这篇文章就只是讲讲老项目中遇到的种种不敢苟同的代码写法，以及遇到一些问题时的处理方法。</p>
<h3 id="1、关于按钮事件的重复点击问题"><a href="#1、关于按钮事件的重复点击问题" class="headerlink" title="1、关于按钮事件的重复点击问题"></a>1、关于按钮事件的重复点击问题</h3><p>我们开发中大概都经历过这样的事情，我的一个<code>button</code>被重复的快速点击，（我们开发者应该更清楚的知道这意味着什么）。那我们再深入的想一下（给这样的事件安排一个特定的环境）：例如当网络较差的情况下，再例如当<code>button</code>的执行事件较为耗时时。这时就会出现很多的问题：有时是界面出现问题（当<code>button</code>执行事件中出现调节界面<code>frame</code>的时候）；有时则会出现卡顿，更甚至会出现崩溃现象。对于这种问题，我们要提前考虑到，做好防范处理：即点击按钮事件时,添加防止重复点击功能。</p>
<p><strong>思路是</strong>：防止按钮重复点击<br>比较推荐的解决方法代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)btnClicked:(id)sender &#123;</span><br><span class="line">    //在这里做按钮的想做的事情。</span><br><span class="line">&#125;</span><br><span class="line">- (void)buttonClicked:(id)sender &#123;</span><br><span class="line">   //先将未到时间执行前的任务取消。</span><br><span class="line">    [[self class] cancelPreviousPerformRequestsWithTarget:self selector:@selector(btnClicked:)object:sender];</span><br><span class="line">    [self performSelector:@selector(btnClicked:)withObject:sender afterDelay:0.2f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原理是</strong> ：我们每次点击按钮时，先执行取消之前的按钮点击执行事件，然后再去执行一个延迟执行方法（方法中执行的是按钮执行的事件）。</p>
<p>还有一种方法也是可以实现的：具体的看《<a href="http://www.cnblogs.com/LQCQ-Silent/p/6082086.html" target="_blank" rel="noopener">iOS之防止用户重复点击Button（按钮）问题</a> 》</p>
<h3 id="2、很多界面共用一个界面时：使用枚举做类型判断"><a href="#2、很多界面共用一个界面时：使用枚举做类型判断" class="headerlink" title="2、很多界面共用一个界面时：使用枚举做类型判断"></a>2、很多界面共用一个界面时：使用枚举做类型判断</h3><p>老的项目中会出现很多这样的现象：很多界面重复使用一个界面，这样就自然而然的需要在不同的界面跳转到复用的界面时去做判断。而奇怪的地方在于：判断的依据是<code>self.title</code>。那么就会出现这样一种现象：在跳转界面后会有一大段<code>if</code>去判断字符串是否等于<code>self.title</code> 。</p>
<p><strong>如果我们做一些改变：使用枚举来做界面类型的判断，使用<code>switch case</code>语句做判断执行代码。这样会不会更优美，简洁一些。</strong></p>
<h3 id="3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题"><a href="#3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题" class="headerlink" title="3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题"></a>3、关于老项目中iOS10以上的情况下，导航栏中按钮不显示问题</h3><p>如果你的<code>viewController</code>都继承于基类，那么在基类中添加这样一段代码（这也是目前我发现的最省事的方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillAppear:(BOOL)animated &#123; </span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    [self.navigationController setNavigationBarHidden:YES animated:NO];</span><br><span class="line">    [self.navigationController setNavigationBarHidden:NO animated:NO];</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    [self.navigationController setNavigationBarHidden:YES animated:NO];</span><br><span class="line">    [self.navigationController setNavigationBarHidden:NO animated:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、事件方法要每个界面区分开"><a href="#4、事件方法要每个界面区分开" class="headerlink" title="4、事件方法要每个界面区分开"></a>4、事件方法要每个界面区分开</h3><p>老项目中会有这种情况：在本界面 command点击一个<code>button</code>执行事件方法或者手势事件方法时，会莫名其妙的跳转到另外一个界面。<br>我们在开发时最好给不同界面<code>button</code>的<code>clicked</code>事件命名是区分开来，例如：界面名 + <code>ButtonClicked</code></p>
<h3 id="5、对象为空现象"><a href="#5、对象为空现象" class="headerlink" title="5、对象为空现象"></a>5、对象为空现象</h3><p>在开发中如果存在<code>image</code>为空，或者必须显示的<code>String</code>为空现象，<br>记得在代码中作判断，图片可以直接设置默认图片，字符串也可以设置默认字符串<br>这一点可以学一下SDWebImage库中对于网络请求图片不存在的处理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//给一张默认图片，先使用默认图片，当图片加载完成后再替换</span><br><span class="line">[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@&quot;default&quot;]];</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImage *image = [UIImage imageNamed:@&quot;image&quot;];</span><br><span class="line">UIImage *defaultImage = [UIImage imageNamed:@&quot;defaultImage&quot;];</span><br><span class="line">UIImageView *imageView = [[UIImageView alloc]initWithImage:image==nil ?  image:defaultImage];</span><br></pre></td></tr></table></figure>
<p>字符串当然也是类似，其实看似有些费事甚至有的显得多余的写法，会使以后的维护变得更加的如意。</p>
<h3 id="6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。"><a href="#6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。" class="headerlink" title="6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。"></a>6、一个界面多网络请求问题，而且需要多个请求都完成后，对界面有一些操作。</h3><p>这是一个老的话题了，我之所以重新提及这个话题，原因是我从一些文章中发现了一个从来没使用过的方法，这个下面会提到，现在就让我们列举出来比较常用的方法。就以一个界面两个网络请求为例 A和B.</p>
<p><strong>（1）两个请求互套)(也是最笨的方法)</strong><br>     具体是这样的，我在A请求成功后，再请求B。当然如果请求多的话，这个肯定是作废的。</p>
<p><strong>（2）使用GCD中的通知</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t serviceGroup = dispatch_group_create();</span><br><span class="line">// 开始第一个网络请求</span><br><span class="line">servicedispatch_group_enter(serviceGroup);</span><br><span class="line">[self.configService startWithCompletion:^(ConfigResponse *results, NSError *error) &#123;</span><br><span class="line"> //请求成功后的操作</span><br><span class="line">    configError = error; </span><br><span class="line">    dispatch_group_leave(serviceGroup);//完成后离开分组</span><br><span class="line">&#125;];</span><br><span class="line">// 开始第二个请求</span><br><span class="line">dispatch_group_enter(serviceGroup);</span><br><span class="line">[self.preferenceService startWithCompletion:^(PreferenceResponse *results, NSError *error) &#123;</span><br><span class="line"> //请求成功后的操作</span><br><span class="line">    preferenceError = error; </span><br><span class="line">    dispatch_group_leave(serviceGroup);//完成后离开分组</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_group_notify(serviceGroup,dispatch_get_main_queue(),^&#123;</span><br><span class="line"> // Assess any errors</span><br><span class="line">     NSError *overallError = nil; </span><br><span class="line">    if (configError || preferenceError)  &#123;</span><br><span class="line"> // 判断时候请求有失败</span><br><span class="line">        overallError = configError ?: preferenceError; </span><br><span class="line">     &#125; </span><br><span class="line">// 最后完成后执行的block</span><br><span class="line">    completion(overallError);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>（3）利用GCD中的信号量</strong></p>
<p>在GCD中有三个函数是<code>semaphore</code>的操作，分别是：　　<br><code>dispatch_semaphore_create</code> 创建一个semaphore　　<br><code>dispatch_semaphore_signal</code> 发送一个信号　<br><code>dispatch_semaphore_wait</code> 等待信号　　<br>简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，<code>dispatch_semaphore_signal</code>是发送一个信号，自然会让信号总量加1，<code>dispatch_semaphore_wait</code>等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。</p>
<p>利用这样的机制，当信号量达到我们网络请求的数量时，请求结束。</p>
<p><strong>（4）这个也是我上面说的无意中看到的一个方法，仅拿出来作为参考</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(concurrent_queue, ^&#123; </span><br><span class="line">     NSLog(@&quot;---并发任务1---&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrent_queue, ^&#123;</span><br><span class="line">     NSLog(@&quot;---并发任务2---&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(concurrent_queue, ^&#123;     </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123; </span><br><span class="line">        NSLog(@&quot;---所有并发任务结束后回到主线程刷新---&quot;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上就是关于一界面多请求的不同解决方案。</p>
<h3 id="7、代码规范问题"><a href="#7、代码规范问题" class="headerlink" title="7、代码规范问题"></a>7、代码规范问题</h3><ul>
<li>为什么这个普通的话题放到最后呢，大概是因为我觉得这个很重要的问题吧，毕竟技术水平不高，还是可以提升的。但代码不规范的话，养成习惯后很难改的，我见过太多项目中使用【拼音命名、不注意驼峰命名法、define预处理指令满天飞等等的代码】这些出现在项目中就像时时刻刻在提醒你，看这样的项目是一种煎熬。</li>
<li>其实代码规范不仅仅是公司对开发者的要求,也是开发者对自己的一个要求。因为如果统一每个人的写作规范，是一件耗时，耗财的事情。小一些的公司是做不来，中型的公司大多是不想做。而大型的公司总是花费近几个月的时间去培养员工的代码规范，这就是财大气粗吧。而且开发者本身对于技术的提升、追求等，都无形中要求自己注意代码规范问题。</li>
<li>对于这部分，建议看看《Effective Objective-C 2.0》这本书，其中提到了这部分内容。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/项目总结/">项目总结</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Wheat
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'GTM-NHB73SK', 'auto');
    ga('send', 'pageview');

</script>

    
<script>
    var _hmt = _hmt || [];
    ( function () {
        var hm = document.createElement( "script" );
        hm.src = "https://hm.baidu.com/hm.js?ae05530a6a007cdb8063cf611691cc3e";
        var s = document.getElementsByTagName( "script" )[ 0 ];
        s.parentNode.insertBefore( hm, s );
    } )();
</script>

  </div>
</div>
</body>
</html>