<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>似梦言生</title>
  
  <subtitle>踏实、低调、前行。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guohuaden.com/"/>
  <updated>2021-01-30T11:40:56.965Z</updated>
  <id>http://guohuaden.com/</id>
  
  <author>
    <name>Wheat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 代码规范</title>
    <link href="http://guohuaden.com/2021/01/30/iOS-Code-Standards/"/>
    <id>http://guohuaden.com/2021/01/30/iOS-Code-Standards/</id>
    <published>2021-01-30T11:39:50.000Z</published>
    <updated>2021-01-30T11:40:56.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-命名规范"><a href="#1-命名规范" class="headerlink" title="1.命名规范"></a>1.命名规范</h2><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>命名应该尽可能的清晰和简洁，避免使用单词的简写，避免有歧义的命名</p><ul><li>命名遵循<a href="https://baike.baidu.com/item/骆驼命名法?fr=aladdin" target="_blank" rel="noopener">驼峰命名法</a></li><li>必须由数字、字母、下滑线组成，不能数字开头。</li><li>见名知意（非常重要，严禁出现无意义的命名，如<strong>aa，cc，data1，data2..</strong>）</li><li>变量名不能重名</li><li>变量名不能和系统关键字重名（如int id 等）</li></ul><p><strong>代码示范：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">insertObject:atIndex:</span><br><span class="line">setBackgroundColor:</span><br><span class="line"></span><br><span class="line">//不推荐</span><br><span class="line">// 不清晰，insert的对象类型和at的位置属性没有说明</span><br><span class="line">insert:at:</span><br><span class="line">// 不清晰，不要使用简写</span><br><span class="line">setBkgdColor:</span><br><span class="line">// 有歧义，是返回sendPort还是send一个Port？</span><br><span class="line">sendPort</span><br></pre></td></tr></table></figure><p>但在 Objective-C 编码过程中有部分单词简写非常常用，以至于成为了一种规范，这些简写可以在代码中直接使用，下面部分列举：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alloc   == Allocate         max    == Maximum</span><br><span class="line">alt     == Alternate        min    == Minimum</span><br><span class="line">app     == Application      msg    == Message</span><br><span class="line">calc    == Calculate        nib    == Interface Builder archive</span><br><span class="line">dealloc == Deallocate       pboard == Pasteboard</span><br><span class="line">func    == Function         rect   == Rectangle</span><br><span class="line">horiz   == Horizontal       Rep    == Representation (used in class name such as NSBitmapImageRep).</span><br><span class="line">info    == Information      temp   == Temporary</span><br><span class="line">init    == Initialize       vert   == Vertical</span><br><span class="line">int     == Integer</span><br></pre></td></tr></table></figure><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>整个工程的命名风格要保持一致性，最好和苹果SDK的代码保持统一。不同类中完成相似功能的方法应该叫一样的名字，比如我们总是用<code>count</code>来返回集合的个数，不能在A类中使用<code>count</code>而在B类中使用<code>getNumber</code> </p><h4 id="工程名"><a href="#工程名" class="headerlink" title="工程名"></a>工程名</h4><p><strong>工程名的命名必须有</strong>强烈的导向性<strong>，让人看到工程名的第一眼就明白该工程对应哪个项目。如</strong>KKLOnLine<strong>。<br>工程名字不能出现中文，不允许有空格。<br>工程名字采用大驼峰式命名法。</strong></p><h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><p><strong>类名的命名遵循</strong>大驼峰式命名法<strong>，应该包含一个<em>名词</em>来表示它代表的对象类型，类名中可以添加</strong>工程的前缀**，防止多个子工程出现类名重复的情况。（如，学习工程中的课程列表STCourseListTableViewController）</p><h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p><strong>方法名的命名规范遵循</strong>小驼峰式命名法**，如果是私有的方法，在方法面前可以加p_，每个方法名之前需要有详细的注释，标明方法的作用。</p><ul><li>可以用一些通用的大写字母缩写打头方法，比如<code>PDF</code>，<code>TIFF</code>等。</li><li>可以用带下划线的前缀来命名私有方法或者类别中的方法。</li><li>若方法表示让对象执行一个动作，使用动词打头来命名（不要使用 <code>do</code>，<code>does</code> 这种多余的关键字）。</li><li>若方法是为了获取对象的一个属性值，直接用属性名称来命名这个方法（不要添加 <code>get</code> 或者其他的动词前缀）。</li></ul><h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><p><strong>变量名的命名规范遵循</strong>小驼峰式命名法<strong>(参数名的命名规则和变量名一直)。</strong></p><h4 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h4><p><strong>常量名的命名模式 k+大驼峰式命名法形式。（如，</strong>kCourseCount**）</p><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p>源码的头文件名应该清晰地暗示它的功能和包含的内容。（如：<strong>NSBundleAdditions.h</strong>）</p><h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p>委托的第一个参数是触发它的对象，第一个关键词是触发对象的类名，除非委托方法只有一个名为<code>sender</code>的参数。根据委托方法触发的时机和目的，使用 <code>should</code>， <code>will</code>， <code>did</code> 等关键词</p><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p><code>[触发通知的类名] + [Did | Will] + [动作] + Notification</code></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p> 函数的的命名遵循<strong>大驼峰式命名法</strong>，一般带有缩写前缀，表示方法所在的框架。</p><ul><li>如果函数通过指针参数来返回值，需要在函数名中使用 <code>Get</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *NSGetSizeAndAlignment(const char *typePtr, unsigned int *sizep, unsigned int *alignp)</span><br></pre></td></tr></table></figure><ul><li>函数的返回类型是BOOL时的命名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL NSDecimalIsNotANumber(const NSDecimal *decimal)</span><br></pre></td></tr></table></figure><ul><li>如果函数返回其参数的某个属性，省略动词：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int NSEventMaskFromType(NSEventType type)</span><br><span class="line">float NSHeight(NSRect aRect)</span><br></pre></td></tr></table></figure><h2 id="2-注释规范"><a href="#2-注释规范" class="headerlink" title="2.注释规范"></a>2.注释规范</h2><p> 一份规范的代码必定不能缺少详尽的注释。代码块的注释应该更注重说明<strong>为什么这么做</strong>，而不是<strong>做了什么</strong></p><p>注释的作用：</p><ol><li>方便工作交接和引导新同事熟悉代码</li><li>方便自己之后回忆代码逻辑</li><li>方便生成文档</li></ol><h4 id="属性的注释"><a href="#属性的注释" class="headerlink" title="属性的注释"></a>属性的注释</h4><p>对于属性我们使用 三杠 <strong>///</strong> 进行单行注释 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">///姓名</span><br><span class="line">@property (nonatomic，copy)NSString *name;</span><br></pre></td></tr></table></figure><h4 id="特殊行和代码块的注释"><a href="#特殊行和代码块的注释" class="headerlink" title="特殊行和代码块的注释"></a>特殊行和代码块的注释</h4><p>对于特殊行和代码块的注释使用 双杠 <strong>//</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//设置音量</span><br><span class="line">player.volum = 0.5;</span><br><span class="line">if(liveStatus == kLiveStatusEnded)&#123;//直播结束的操作</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">[[[ResourceTask task] post] subscribeNext:^(ResourceTask *task) &#123;//请求之后的处理</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="方法的注释"><a href="#方法的注释" class="headerlink" title="方法的注释"></a>方法的注释</h4><p>对于方法我们使用<strong>多行注释</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">@abstract 初始化方法 </span><br><span class="line">@param name 姓名 </span><br><span class="line">@param sex  性别 </span><br><span class="line">@result 返回一个初始化实例 </span><br><span class="line">*/</span><br><span class="line">- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex;</span><br></pre></td></tr></table></figure><h4 id="类的注释"><a href="#类的注释" class="headerlink" title="类的注释"></a>类的注释</h4><p>对于类的注释我们使用多行注释  <strong>类的声明部分要对当前类的功能作用进行详细的注释，标明类的作用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  TopView.h</span><br><span class="line">//  KKLOnLine</span><br><span class="line">//</span><br><span class="line">//  Created by zahir on 2017/7/31.</span><br><span class="line">//  Copyright © 2017年 mistong. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">/**</span><br><span class="line"> @class           TopView</span><br><span class="line"> @abstract        TopView 的简单介绍</span><br><span class="line"> @discussion      TopView 的功能介绍 和 一些特殊的使用注意事项</span><br><span class="line"> */</span><br><span class="line">@interface TopView : UIView</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="特定注释"><a href="#特定注释" class="headerlink" title="特定注释"></a>特定注释</h4><ul><li><p><code>///TODO:</code> 有功能代码待编写，需要注明，以便自己和代码审查者全局搜索。</p></li><li><p><code>///FIXME:(禅道bug编号)</code> 用于追溯bug，如果有禅道记录，修复完成后带入禅道的bug号，没有的话，也需要写明bug描述</p></li><li><p><code>///!!!:</code>  代码需要注意</p></li><li><code>///???:</code> 代码有疑问</li><li><code>///MARK:</code> 标记，与#pragma mark 效果相同</li></ul><h4 id="文件的注释"><a href="#文件的注释" class="headerlink" title="文件的注释"></a>文件的注释</h4><p>每一个文件都<strong>必须</strong>写文件注释，文件注释通常包含</p><ul><li>文件所在模块</li><li>作者信息</li><li>历史版本信息</li><li>版权信息</li><li>文件包含的内容，作用</li></ul><p><em>注：文件注释的格式通常不作要求，能清晰易读就可以了，但在整个工程中风格要统一。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*******************************************************************************</span><br><span class="line">    Copyright (C), 2011-2013, Andrew Min Chang</span><br><span class="line"></span><br><span class="line">    File name:  AMCCommonLib.h</span><br><span class="line">    Author:     Andrew Chang (Zhang Min) </span><br><span class="line">    E-mail:     LaplaceZhang@126.com</span><br><span class="line">    </span><br><span class="line">    Description:    </span><br><span class="line">            This file provide some covenient tool in calling library tools. One can easily include </span><br><span class="line">        library headers he wants by declaring the corresponding macros. </span><br><span class="line">            I hope this file is not only a header, but also a useful Linux library note.</span><br><span class="line">            </span><br><span class="line">    History:</span><br><span class="line">        2012-??-??: On about come date around middle of Year 2012, file created as &quot;commonLib.h&quot;</span><br><span class="line">        2012-08-</span><br><span class="line">    Copyright information: 20: Add shared memory library; add message queue.</span><br><span class="line">    2012-08-21: Add socket library (local)</span><br><span class="line">    2012-10-10: Change file name as &quot;AMCCommonLib.h&quot;</span><br><span class="line">    2012-12-04: Add UDP support in AMC socket library</span><br><span class="line">    2013-01-22: Add CFG_LIB_TIMER.</span><br><span class="line">    2013-01-22: Remove CFG_LIB_DATA_TYPE because there is already AMCDataTypes.h</span><br><span class="line"></span><br><span class="line">            This file was intended to be under GPL protocol. However, I may use this library</span><br><span class="line">        in my work as I am an employee. And my company may require me to keep it secret. </span><br><span class="line">        Therefore, this file is neither open source nor under GPL control. </span><br><span class="line">        </span><br><span class="line">********************************************************************************/</span><br></pre></td></tr></table></figure><h2 id="3-代码规范"><a href="#3-代码规范" class="headerlink" title="3.代码规范"></a>3.代码规范</h2><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><ol><li><p>不要在工程里使用 Tab，使用空格来进行缩进。在 <code>Xcode &gt; Preferences &gt; Text Editing</code> 将 Tab 和自动缩进都设置为<strong>4</strong>个空格。</p></li><li><p><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>=</code> 的前后都应该保留一个空格。</p></li><li>逗号<code>,</code>的前面不应该留有空格，<code>,</code>后面应该保留一个空格</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">NSArray *data = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;];</span><br><span class="line">NSInteger x = 4 * (5 + 3);</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">NSArray* data=@[ @&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot; ];</span><br><span class="line">NSInteger x=4*(5+3);</span><br></pre></td></tr></table></figure><h4 id="每一行的最大长度"><a href="#每一行的最大长度" class="headerlink" title="每一行的最大长度"></a>每一行的最大长度</h4><p>在 <code>Xcode &gt; Preferences &gt; Text Editing &gt; Page guide at column:</code> 中将最大行长设置为<strong>80</strong>，过长的一行代码将会导致可读性问题。</p><h4 id="括号的换行"><a href="#括号的换行" class="headerlink" title="括号的换行"></a>括号的换行</h4><p><strong>方法</strong>及其他大括号(<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code>等)，总是在同一行语句打开但在新行中关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">- (void)foobar &#123;</span><br><span class="line">    if (user.age &gt; 18) &#123;</span><br><span class="line">        // Do something</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">- (void)foobar </span><br><span class="line">&#123;</span><br><span class="line">    if (user.age &gt; 18) </span><br><span class="line">    &#123;</span><br><span class="line">      // Do something  </span><br><span class="line">    &#125; </span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">      // Do something  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数的书写和调用"><a href="#函数的书写和调用" class="headerlink" title="函数的书写和调用"></a>函数的书写和调用</h4><ol><li><p>在 <code>-</code> 和 <code>(void)</code> 之间应该有一个空格，第一个大括号 <code>{</code> 的位置在函数所在行的末尾，同样应该有一个空格。</p></li><li><p>函数有特别多的参数或者名称很长，应该将其按照<code>:</code>来对齐分行显示。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithModel:(IPCModle)model</span><br><span class="line">       ConnectType:(IPCConnectType)connectType</span><br><span class="line">        Resolution:(IPCResolution)resolution</span><br><span class="line">          AuthName:(NSString *)authName</span><br><span class="line">          Password:(NSString *)password</span><br><span class="line">               MAC:(NSString *)mac</span><br><span class="line">              AzIp:(NSString *)az_ip</span><br><span class="line">             AzDns:(NSString *)az_dns</span><br><span class="line">             Token:(NSString *)token</span><br><span class="line">             Email:(NSString *)email</span><br><span class="line">          Delegate:(id&lt;IPCConnectHandlerDelegate&gt;)delegate;</span><br></pre></td></tr></table></figure><h4 id="方法内部避免空白行"><a href="#方法内部避免空白行" class="headerlink" title="方法内部避免空白行"></a>方法内部避免空白行</h4><p>在方法内部尽量避免空白行，如果为了区分功能，请用单行注释进行分割(注释可以增加斜杠数量<code>////</code>表明功能隔离)。</p><h4 id="闭包建议避免以冒号对齐的方式调用"><a href="#闭包建议避免以冒号对齐的方式调用" class="headerlink" title="闭包建议避免以冒号对齐的方式调用"></a>闭包建议避免以冒号对齐的方式调用</h4><ol><li>较短的 block 可以写在一行内。</li><li>block 内的代码采用<strong>4个空格</strong>的缩进</li><li><code>^</code> 和 <code>(</code> 之间，<code>^</code> 和 <code>{</code> 之间都没有空格，参数列表的右括号 <code>)</code> 和 <code>{</code> 之间有一个空格</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 较短的block写在一行内</span><br><span class="line">[operation setCompletionBlock:^&#123; [self onOperationDone]; &#125;];</span><br><span class="line"></span><br><span class="line">// 推荐</span><br><span class="line">  [UIView animateWithDuration:1.0 animations:^&#123;</span><br><span class="line">    // something</span><br><span class="line">  &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">    // something</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  //不推荐</span><br><span class="line">  [UIView animateWithDuration:1.0</span><br><span class="line">              animations:^&#123;</span><br><span class="line">                  // something</span><br><span class="line">               &#125;</span><br><span class="line">              completion:^(BOOL finished) &#123;</span><br><span class="line">                   // something</span><br><span class="line">              &#125;];</span><br></pre></td></tr></table></figure><h3 id="数据结构的语法糖"><a href="#数据结构的语法糖" class="headerlink" title="数据结构的语法糖"></a>数据结构的语法糖</h3><p>应该使用可读性更好的语法糖来构造 <code>NSArray</code>，<code>NSDictionary</code> 等数据结构，避免使用冗长的 <code>alloc</code>,<code>init</code> 方法。</p><p><strong>一行构造，应该在括号两端保留一个空格，使得被构造的元素于与构造语法区分开</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 正确，在语法糖的&quot;[]&quot;或者&quot;&#123;&#125;&quot;两端留有空格</span><br><span class="line">NSArray *array = @[ [foo description], @&quot;Another String&quot;, [bar description] ];</span><br><span class="line">NSDictionary *dic = @&#123; NSForegroundColorAttributeName : [NSColor redColor] &#125;;</span><br><span class="line"></span><br><span class="line">// 不正确，不留有空格降低了可读性</span><br><span class="line">NSArray* array = @[[foo description], [bar description]];</span><br><span class="line">NSDictionary* dic = @&#123;NSForegroundColorAttributeName: [NSColor redColor]&#125;;</span><br></pre></td></tr></table></figure><p><strong>多行构造，构造元素应保留两个空格来进行缩进，右括号 <code>]</code> 或者 <code>}</code>写在新的一行，并且与调用语法糖那行代码的第一个非空字符对齐</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[</span><br><span class="line">  @&quot;This&quot;,</span><br><span class="line">  @&quot;is&quot;,</span><br><span class="line">  @&quot;an&quot;,</span><br><span class="line">  @&quot;array&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">NSDictionary *dictionary = @&#123;</span><br><span class="line">  NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12],</span><br><span class="line">  NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>构造字典时，字典的Key和Value与中间的冒号<code>:</code>都要留有一个空格，多行书写时，也可以将Value对齐</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 推荐，冒号&apos;:&apos;前后留有一个空格</span><br><span class="line">NSDictionary *option1 = @&#123;</span><br><span class="line">  NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12],</span><br><span class="line">  NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 推荐，按照Value来对齐</span><br><span class="line">NSDictionary *option2 = @&#123;</span><br><span class="line">  NSFontAttributeName :            [NSFont fontWithName:@&quot;Arial&quot; size:12],</span><br><span class="line">  NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不推荐，冒号前应该有一个空格</span><br><span class="line">NSDictionary *wrong = @&#123;</span><br><span class="line">  AKey:       @&quot;b&quot;,</span><br><span class="line">  BLongerKey: @&quot;c&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不推荐，每一个元素要么单独成为一行，要么全部写在一行内</span><br><span class="line">NSDictionary *alsoWrong= @&#123; AKey : @&quot;a&quot;,</span><br><span class="line">                            BLongerKey : @&quot;b&quot; &#125;;</span><br><span class="line"></span><br><span class="line">// 不推荐，在冒号前只能有一个空格，冒号后才可以考虑按照Value对齐</span><br><span class="line">NSDictionary *stillWrong = @&#123;</span><br><span class="line">  AKey       : @&quot;b&quot;,</span><br><span class="line">  BLongerKey : @&quot;c&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>TODO：待讨论</strong></p><ul><li><p>在方法之间应该有且只有一行。这样有利于在视觉上更清晰。</p></li><li><p>函数有特别多的参数或者名称很长，应该将其按照<code>:</code>来对齐分行显示。</p></li><li><p>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请<strong>不要</strong>这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。(?????)</p></li><li><p>闭包建议避免以冒号对齐的方式调用。</p></li></ul><h2 id="4-编码规范"><a href="#4-编码规范" class="headerlink" title="4.编码规范"></a>4.编码规范</h2><p>编码规范简单来说就是为了保证写出来的代码具备三个原则:可复用， 易维护， 可扩展. 这其实也是面向对象的基本原则.</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格</p></li><li><p>一个方法，应该少于50行</p></li><li><p>方法分布区</p></li><li><p>life-Cycle、Delegate、Event-Response、Private-Method、Setters-Getters 顺序进行分区域书写 不是delegate方法的，不是event response方法的，不是life cycle方法的，就是private method了。</p></li><li><p>对于整个单独的功能模块是可以考虑添加category。</p></li><li><p>同一区域中的方法按照经常：容易忘记的、常使用的程度顺序进行排列</p></li><li><p>当一个方法参数过多，其实这样就预示着是否我们可以聚合一个model类，一方面代码整洁；另一方面参数过多逻辑不简容易导致错误</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">- (void)registerUser(User*)user;</span><br><span class="line">//不推荐</span><br><span class="line">-(void)registerUserName:(NSString*)userName password:(NSString*)password email:(NSString*)email;</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>所有的属性特性应该显示的列出来，有助于新手理解代码。</p></li><li><p><code>*</code>应该跟着属性名字，而不是跟在类型后面。</p></li><li><p>集合作为属性时，标注集合内元素类型</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">@property (nonatomic，strong) NSArray&lt;Teacher *&gt; *teacherList;</span><br><span class="line">//不推荐</span><br><span class="line">@property (nonatomic，strong) NSArray *teacherList;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在<code>for()</code>循环。</p></li><li><p>变量进行赋值、比较时避免产生硬编码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">#define kPeopleNumber 2</span><br><span class="line">if(peopleNumber == kPeopleNumber)&#123;</span><br><span class="line">&#125; </span><br><span class="line">//或者 </span><br><span class="line">int studentNumber = kPeopleNumber;</span><br><span class="line">int teacherNumber = kPeopleNumber;</span><br><span class="line">//不推荐</span><br><span class="line">if(peopleNumber == 2)&#123;</span><br><span class="line">&#125;</span><br><span class="line">//或者 </span><br><span class="line">int studentNumber = 2;</span><br><span class="line">int teacherNumber = 2;</span><br></pre></td></tr></table></figure><ul><li>星号表示变量是指针。例如， <code>NSString *text</code> 既不是 <code>NSString* text</code> 也不是 <code>NSString * text</code>。</li><li>尽可能用私有属性代替实例变量的使用。如果有实例变量，要用下划线开头命名<code>NSString *_text</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">@interface GrowthStationVC ()</span><br><span class="line">@property (nonatomic， strong) NSString *fmTitle; </span><br><span class="line">@property (nonatomic， strong) UIView *containerView;</span><br><span class="line">@end</span><br><span class="line">//不推荐</span><br><span class="line">@interface GrowthStationVC () &#123;</span><br><span class="line">    NSString *_fmTitle;</span><br><span class="line">    UIView *containerView;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>当使用<code>enum</code>时，推荐使用<code>NS_ENUM</code>方式，因为它有更强的类型检查和代码补全。现在SDK有一个宏<code>NS_ENUM()</code>来帮助和鼓励你使用固定的基本类型。</p><p><strong>例如：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">typedef NS_ENUM(NSInteger， RWTLeftMenuTopItemType) &#123;</span><br><span class="line">  RWTLeftMenuTopItemMain = 1，</span><br><span class="line">  RWTLeftMenuTopItemShows，</span><br><span class="line">  RWTLeftMenuTopItemSchedule</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//不推荐</span><br><span class="line">enum GlobalConstants &#123;</span><br><span class="line">  kMaxPinSize = 5，</span><br><span class="line">  kMaxPinCount = 500，</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>Objective-C使用<code>YES</code>和<code>NO</code>。因为<code>true</code>和<code>false</code>应该只在C或C++代码使用。不要拿某样东西直接与<code>YES</code>比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">if (someObject) &#123;&#125;</span><br><span class="line">if (![anotherObject boolValue]) &#123;&#125;</span><br><span class="line"></span><br><span class="line">//不推荐</span><br><span class="line">if (someObject == nil) &#123;&#125;</span><br><span class="line">if ([anotherObject boolValue] == NO) &#123;&#125;</span><br><span class="line">if (isAwesome == YES) &#123;&#125; // Never do this.</span><br><span class="line">if (isAwesome == true) &#123;&#125; // Never do this.</span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul><li><p>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，</p><p>even more dangerous defect</p><p>可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">if (!error) &#123;</span><br><span class="line">  return success;</span><br><span class="line">&#125;</span><br><span class="line">//不推荐</span><br><span class="line">if (!error)</span><br><span class="line">  return success;</span><br><span class="line">//或:</span><br><span class="line">if (!error) return success;</span><br></pre></td></tr></table></figure><ul><li><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套<code>if</code>语句，多个返回语句也是OK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">- (void)someMethod &#123;</span><br><span class="line">if (![someOther boolValue]) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">  //Do something important</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不推荐</span><br><span class="line">- (void)someMethod &#123;</span><br><span class="line">  if ([someOther boolValue]) &#123;</span><br><span class="line">    //Do something important</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h3><p>当需要提高代码的清晰性和简洁性时，三元操作符<code>?:</code>才会使用。单个条件求值常常需要它。多个条件求值时，如果使用<code>if</code>语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p><p>Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">NSInteger value = 5;</span><br><span class="line">result = (value != 0) ? x : y;</span><br><span class="line"></span><br><span class="line">BOOL isHorizontal = YES;</span><br><span class="line">result = isHorizontal ? x : y;</span><br><span class="line"></span><br><span class="line">//不推荐</span><br><span class="line">result = a &gt; b ? x = c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure><h3 id="nil检测"><a href="#nil检测" class="headerlink" title="nil检测"></a>nil检测</h3><p>在 Objective-C 中向 nil 对象发送命令是不会抛出异常或者导致崩溃的，只是完全的“什么都不干”，所以，只在程序中使用 nil 来做逻辑上的检查。</p><p>不要使用诸如 <code>nil == Object</code> 或者 <code>Object == nil</code> 的形式来判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 正确，直接判断</span><br><span class="line">if (!objc) &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误，不要使用nil == Object的形式</span><br><span class="line">if (nil == objc) &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用NSNumber的语法糖"><a href="#使用NSNumber的语法糖" class="headerlink" title="使用NSNumber的语法糖"></a>使用NSNumber的语法糖</h3><p>使用带有<code>@</code>符号的语法糖来生成 NSNumber 对象能使代码更简洁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *phoneNumber = @42;</span><br><span class="line">NSNumber *pi_2 = @(M_PI / 2);</span><br></pre></td></tr></table></figure><h3 id="NSString-在赋值时被复制"><a href="#NSString-在赋值时被复制" class="headerlink" title="NSString 在赋值时被复制"></a>NSString 在赋值时被复制</h3><p>以复制（copy）的方式防止在不知情的情况下 String 的值被其它对象修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFood:(NSString *)food &#123;</span><br><span class="line">  _food = [food copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BOOL的使用"><a href="#BOOL的使用" class="headerlink" title="BOOL的使用"></a>BOOL的使用</h3><ol><li><strong>不要</strong>将 BOOL 类型变量直接和 <code>YES</code>。</li><li>BOOL类型可以和 <code>_Bool</code>,<code>bool</code> 相互转化，但是<strong>不能</strong>和 <code>Boolean</code> 转化。</li><li>不要将其它类型的值作为 BOOL 来返回，这种情况下，BOOL 变量只会取值的最后一个字节来赋值，这样很可能会取到0（NO）。但是，一些逻辑操作符比如 <code>&amp;&amp;</code>,<code>||</code>,<code>!</code>的返回是可以直接赋给 BOOL。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 错误，无法确定|great|的值是否是YES(1)，不要将BOOL值直接与YES比较</span><br><span class="line">BOOL great = [foo isGreat];</span><br><span class="line">if (great == YES)</span><br><span class="line">  // ...be great!</span><br><span class="line"></span><br><span class="line">//正确</span><br><span class="line">BOOL great = [foo isGreat];</span><br><span class="line">if (great)</span><br><span class="line">  // ...be great!</span><br><span class="line"></span><br><span class="line">// 错误，不要将其它类型转化为BOOL返回</span><br><span class="line">- (BOOL)isBold &#123;</span><br><span class="line">  return [self fontTraits] &amp; NSFontBoldTrait;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isValid &#123;</span><br><span class="line">  return [self stringValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">- (BOOL)isBold &#123;</span><br><span class="line">  return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确，逻辑操作符可以直接转化为BOOL</span><br><span class="line">- (BOOL)isValid &#123;</span><br><span class="line">  return [self stringValue] != nil;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isEnabled &#123;</span><br><span class="line">  return [self isValid] &amp;&amp; [self isBold];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不要使用-new-方法"><a href="#不要使用-new-方法" class="headerlink" title="不要使用 new 方法"></a>不要使用 new 方法</h3><p>尽管很多时候能用<code>new</code>代替<code>alloc init</code>方法，但这可能会导致调试内存时出现不可预料的问题。Cocoa的规范就是使用<code>alloc init</code>方法，使用<code>new</code>会让一些读者困惑。</p><h3 id="避免循环引用"><a href="#避免循环引用" class="headerlink" title="避免循环引用"></a>避免循环引用</h3><p>为了保持代码统一性，避免开发中疏忽导致强引用。统一强调在代码块中使用 <code>@weakify(self) ,@strongify(self)</code>来做处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">void(^messageBlock)(NSString *) = ^(NSString *message) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    self.message = message;</span><br><span class="line">    NSLog(@&quot;%@&quot;,message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-命名规范&quot;&gt;&lt;a href=&quot;#1-命名规范&quot; class=&quot;headerlink&quot; title=&quot;1.命名规范&quot;&gt;&lt;/a&gt;1.命名规范&lt;/h2&gt;&lt;h4 id=&quot;基本原则&quot;&gt;&lt;a href=&quot;#基本原则&quot; class=&quot;headerlink&quot; title=&quot;基
      
    
    </summary>
    
      <category term="iOS" scheme="http://guohuaden.com/categories/iOS/"/>
    
    
      <category term="iOS代码规范" scheme="http://guohuaden.com/tags/iOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历（Binary Tree）</title>
    <link href="http://guohuaden.com/2021/01/30/Binary-Tree/"/>
    <id>http://guohuaden.com/2021/01/30/Binary-Tree/</id>
    <published>2021-01-30T11:14:01.000Z</published>
    <updated>2021-01-30T11:27:22.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>二叉树（Binary Tree）：计算机中数据结构的一种，是树形结构的一个重要类型。结构类型是<strong>每个节点最多有两个子树的树结构</strong>。特点是<strong>每个节点最多只能有了两棵子树，且有左右之分</strong>。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>二叉树</strong>是指树中节点的度不大于2的有序树，是n(n&gt;=0)个节点的有限集合，该集合或者为空集（称为空二叉树），或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树 。</p><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li>叶子节点：也称为终端节点，没有子树的节点或者度为零的节点。</li><li>节点的关系：节点子树的根节点为该节点的<strong>孩子节点</strong>。相应该节点称为孩子节点的<strong>双亲节点</strong>。</li><li>节点的度：一个节点拥有子树的数目称为节点的度</li><li>节点的层级：从根节点开始，假设根节点为第1层，根节点的子节点为第2层，依此类推，如果某一个节点位于第L层，则其子节点位于第L+1层</li><li>数的深度：也称为树的高度，树中所有节点的层次最大值称为树的深度</li></ul><p><img src="http://blog.guohuaden.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.png" alt="树的层级"></p><p><img src="http://blog.guohuaden.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%A6.png" alt="树的度"></p><h2 id="基本形态"><a href="#基本形态" class="headerlink" title="基本形态"></a>基本形态</h2><ul><li>空二叉树</li><li>只有一个跟节点的二叉树</li><li>只有左子树</li><li>只有右子树</li><li>满二叉树</li></ul><p><img src="http://blog.guohuaden.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE.png" alt="二叉树基本类型图"></p><h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><ul><li>满二叉树 ：如果一棵二叉树只有度为0的节点和度为2的节点，并且度为0的节点在同一层上，则这棵二叉树为满二叉树。一棵深度为k且有个结点的二叉树称为满二叉树</li><li>完全二叉树 ：深度为k，有n个节点的二叉树当且仅当其每一个节点都与深度为k的满二叉树中编号从1到n的节点一一对应时，称为完全二叉树 </li></ul><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><h3 id="例图"><a href="#例图" class="headerlink" title="例图"></a>例图</h3><p><img src="http://blog.guohuaden.com/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树示例图"></p><ul><li>先序遍历：根节点 –&gt; 左子树 –&gt; 右子树  ==&gt;  A 、B 、D 、E 、C 、F 、G </li><li>中序遍历 ：左子树 –&gt; 根节点 –&gt; 右子树  ==&gt; D、B、E、A 、F 、C、G</li><li>后序遍历：左子树  –&gt; 右子树 –&gt; 根节点  ==&gt;  D、E、B、F、G、C、A</li><li>层级遍历：也叫层序遍历，按层遍历          ==&gt;  A、B、C、D、E、F、G</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">res,root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(root.val);</span><br><span class="line">    recursive(result,root.left);</span><br><span class="line">    recursive(result,root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">result,root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    recursive(result,root.left);</span><br><span class="line">    result.push(root.val);</span><br><span class="line">    recursive(result,root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">result,root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    recursive(result,root.left);</span><br><span class="line">    recursive(result,root.right);</span><br><span class="line">    result.push(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>非递归实现，其实就是迭代方法，引入栈来替代递归。<strong>由于栈的特性是后进先出，所以进栈的时机和递归是相反的</strong> 。所以利用递归的思路用栈实现时，需要先放右节点进栈，再放左节点进栈。这样可以保证每次出栈取到的节点都是左节点优先，达到和递归顺序一样的效果。</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>先序遍历的顺序：根–左–右</p><p>所以每次访问</p><ul><li>常规解法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span> || node != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            result.push(node.val);</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = stack.pop();<span class="comment">//出栈的同时访问右节点，保证访问顺序是先左后右</span></span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>技巧性解法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        <span class="comment">// 由于栈先进后出的特性，先 push right，再 push left</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历是以 左–根–右 遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span> || node != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = stack.pop();<span class="comment">//出栈的同时访问右节点，保证访问顺序是先左后右</span></span><br><span class="line">            result.push(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>思路：</p><p>对于任意节点P而言</p><ol><li><p>P如果是叶子节点，直接输出</p></li><li><p>P如果有孩子，且孩子没有被访问过，则按照右孩子，左孩子的顺序依次入栈</p></li><li><p>P如果有孩子，而且孩子都已经访问过，则访问P节点</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> node;</span><br><span class="line">    <span class="keyword">let</span> preNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        node = stack[stack.length<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//判断当前节点时，左孩子和右孩子都在根结点前已经被访问</span></span><br><span class="line">        <span class="keyword">let</span> visited = preNode != <span class="literal">null</span> &amp;&amp; (preNode == node.left || preNode == node.right);</span><br><span class="line">        <span class="keyword">if</span>((node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) || visited)&#123;</span><br><span class="line">            result.push(node.val);</span><br><span class="line">            preNode = node;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span> || stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            result.push(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.reverse();  <span class="comment">//这里的反转，相当于从栈中取出来节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(result.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  node = result.pop();</span><br><span class="line">    <span class="comment">//打印每个节点的val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>技巧性解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        result.push(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.reverse();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注：后序遍历：左 -- 右 -- 根 </span></span><br><span class="line"><span class="comment">//题中遍历是以 根--右--左出栈的，顺序和后序遍历顺序相反，所以对结果反转得到的就是后序遍历结果</span></span><br></pre></td></tr></table></figure><p><strong>递归和迭代的时间复杂度和空间复杂度都是O(n)</strong> ,</p><p>区别：在于递归的空间是系统栈维护的</p><p>时间复杂度的推导公式：<strong>Master公式</strong>,Master公式是常用来解决递归问题时间复杂度的通用公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">公式 T(N) = a*T(N / b) + O (N^d)</span><br><span class="line">代入公式得到：T(N)=2T(N/2)+O(1):，其中 a = 2, b = 2, d = 0;</span><br><span class="line">得到 log(2,2) = 1 &gt; 0，代入公式 O(N ^ log(b,a)) = O(N^ log(2,2)) = O(N)</span><br></pre></td></tr></table></figure><h3 id="层级遍历（BFS）"><a href="#层级遍历（BFS）" class="headerlink" title="层级遍历（BFS）"></a>层级遍历（BFS）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层级遍历</span></span><br><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = [];<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">let</span> queue = [];<span class="comment">//队列</span></span><br><span class="line">    queue.push(root);<span class="comment">//进栈</span></span><br><span class="line">    <span class="keyword">let</span> node;</span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = queue.length;<span class="comment">//每个层级下的节点</span></span><br><span class="line">        <span class="keyword">let</span> list = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            node = queue.shift();<span class="comment">//出栈</span></span><br><span class="line">            list.push(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(list);<span class="comment">//这个如果要求自底向上输出，可以每次添加到首位。result.unshift(list)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度：每个节点都需要进栈出栈，所以时间复杂度和空间复杂度都是O(n)</span></span><br></pre></td></tr></table></figure><h3 id="二叉树深度-（BFS-and-DFS）"><a href="#二叉树深度-（BFS-and-DFS）" class="headerlink" title="二叉树深度 （BFS and DFS）"></a>二叉树深度 （BFS and DFS）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;二叉树（Binary Tree）：计算机中数据结构的一种，是树形结构的一个重要类型。结构类型是&lt;strong&gt;每个节点最多有两个子树的树结构
      
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="算法" scheme="http://guohuaden.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：从尾到头打印链表</title>
    <link href="http://guohuaden.com/2019/04/20/Arithmetic-weekly5/"/>
    <id>http://guohuaden.com/2019/04/20/Arithmetic-weekly5/</id>
    <published>2019-04-20T12:46:09.000Z</published>
    <updated>2021-01-30T11:32:07.794Z</updated>
    
    <content type="html"><![CDATA[<h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h4><h4 id="题：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下："><a href="#题：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下：" class="headerlink" title="题：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下："></a>题：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  <span class="keyword">int</span>   m_nKey;</span><br><span class="line">  ListNode* m_pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>我们首先想到的是链表的翻转，这也是我们的第一思路。但链表的翻转会改变原来链表的结构，如果不允许在打印链表的时候修改链表的结构呢？</p><p>分析：打印链表首先需要遍历链表，遍历的顺序是从头到尾，但要求的输出顺序是：从尾到头。这种方式为典型的”后进先出”，所以可以用栈实现这种顺序。每遍历一个节点，就将该节点放入栈中。当遍历完整个链表后，再从栈顶开始逐个输出节点的值。这样得到的顺序就是从尾到头的顺序。</p><p>所以完成该题有两种思路：</p><p>1、在没有要求不允许更改链表结构的情况下，利用链表的翻转可以完成该题。</p><p>2、分析该题的要求，根据符合栈的”后进先出”这一特性，利用栈来完成该题。</p><h4 id="代码实践："><a href="#代码实践：" class="headerlink" title="代码实践："></a>代码实践：</h4><p><strong>1、链表翻转</strong></p><p>1.1循环实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">revereList</span><span class="params">(ListNode* pHead)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">ListNode* pNode = pHead;</span><br><span class="line"><span class="comment">//当前节点的上一个节点</span></span><br><span class="line">ListNode* pPrev = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//当前节点的下一个节点</span></span><br><span class="line">ListNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//新链表的头指针</span></span><br><span class="line">ListNode* pReverseHead = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="comment">//如果当前节点不为空，获取该节点的下一个节点</span></span><br><span class="line">pNext = pNode-&gt;p_next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果下一个节点为空，说明遍历到了尾部，将新链表的头指针指向当前节点</span></span><br><span class="line"><span class="keyword">if</span> (pNext == <span class="literal">NULL</span>) &#123;</span><br><span class="line">pReverseHead = pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前的节点的p_next指向前一个节点</span></span><br><span class="line">pNode-&gt;p_next = pPrev;</span><br><span class="line"><span class="comment">//前一个节点指向当前节点</span></span><br><span class="line">pPrev = pNode;</span><br><span class="line"><span class="comment">//当前节点指向下一个节点</span></span><br><span class="line">pNode = pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pReverseHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">ListNode *p1=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">ListNode *p2=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">head-&gt;p_next=p1;</span><br><span class="line">p1-&gt;p_next=p2; </span><br><span class="line"></span><br><span class="line">ListNode *p=revereList(head);</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">p = p-&gt;p_next;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">revereList</span><span class="params">(ListNode* pHead, ListNode* &amp;newHead)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* nextHead = pHead-&gt;p_next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line">newHead = pHead;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">revereList(nextHead, newHead);</span><br><span class="line">nextHead-&gt;p_next = pHead;</span><br><span class="line">pHead-&gt;p_next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">ListNode *p1=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">ListNode *p2=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">head-&gt;p_next=p1;</span><br><span class="line">p1-&gt;p_next=p2; </span><br><span class="line"></span><br><span class="line">ListNode *newhead=<span class="literal">NULL</span>;</span><br><span class="line">ListNode *p=revereList(head,newhead);</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">p = p-&gt;p_next;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、利用栈的”后进先出”实现</strong></p><p>1.1 循环实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListNodeReverse_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt;nodes;</span><br><span class="line"></span><br><span class="line">ListNode* pNode = pHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">nodes.push(pNode);</span><br><span class="line">pNode = pNode-&gt;p_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!nodes.empty()) &#123;</span><br><span class="line">pNode = nodes.top();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,pNode-&gt;val);</span><br><span class="line">nodes.pop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2递归实现</p><p>由于递归本质就是一个栈结构，所以可以直接用递归实现，要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自己，这样链表的输出结果就反过来了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListNodeReverse_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pHead != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pHead -&gt;p_next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">printListNodeReverse_Iteratively(pHead -&gt;p_next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,pHead-&gt;p_value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                  <span class="comment">//测试代码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">ListNode *p1=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">ListNode *p2=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">head-&gt;p_next=p1;</span><br><span class="line">p1-&gt;p_next=p2;</span><br><span class="line">printListNodeReverse_Iteratively(head);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：本篇所有思路均参考或直接引用《剑指offer》一书</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;从尾到头打印链表&quot;&gt;&lt;a href=&quot;#从尾到头打印链表&quot; class=&quot;headerlink&quot; title=&quot;从尾到头打印链表&quot;&gt;&lt;/a&gt;从尾到头打印链表&lt;/h4&gt;&lt;h4 id=&quot;题：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下：&quot;&gt;
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法：实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;</title>
    <link href="http://guohuaden.com/2019/04/14/Arithmetic-weekly4/"/>
    <id>http://guohuaden.com/2019/04/14/Arithmetic-weekly4/</id>
    <published>2019-04-14T03:46:09.000Z</published>
    <updated>2021-01-30T11:32:43.424Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”-则输出-“We-20are-20family-”。"><a href="#题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”-则输出-“We-20are-20family-”。" class="headerlink" title="题：实现一个函数，把字符串中的每个空格替换成”%20”。例如：”We are family.”,则输出 “We%20are%20family.”。"></a>题：实现一个函数，把字符串中的每个空格替换成”%20”。例如：”We are family.”,则输出 “We%20are%20family.”。</h4><h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><p>在网络编程中，如果URL参数中含有特殊字符，如空格、’#’等，则可能导致服务器端无法获得正确的参数值。我们需要将这些特殊符号转成服务器可以识别的字符。<strong>转换的规则是在’%’后面跟上ASCII码的两位十六进制的表示</strong>。比如空格的ASCII码是32，即十六进制的0x20，因此空格被替换成’%20’；再比如’#’的ASCII码为35，即十六进制的0x23,它在URL中被替换为’%23’。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>这题的规则很简单，将空格替换成’%20’，那么需要考虑的就是时间复杂度的问题。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>最简单的想法是：直接遍历字符串中的字符，遇到空格便将其替换成’%20’，但有一些问题，空格的长度和’%20’的长度是不等的，那么结果是需要将每个空格后面的字符向后移动。举个例子：如果字符串的长度为n，对每个空格字符，需要移动后面的O(n)个字符，因此对于含有O(n)个空格字符的字符串而言，总的时间复杂度为：O(n^2)。</p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>使用辅助空间，遍历字符串的每个字符，将其添加到辅助字符串中，添加的过程中将空格替换成’%20’。这种方法是牺牲空复杂度间换取时间复杂度。时间复杂度为：O(n)。</p><h5 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h5><p>先遍历一遍字符串，找出其中的空格，确定替换后的字符转的长度。然后从字符串的后面开始复制和替换。首先准备两个指针：P1和P2。P1指向原始字符串的末尾，P2则指向替换之后的字符串的末尾。<strong>实现步骤：</strong>做好之前的准备后，向前移动指针P1，诸葛把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。时间复杂度为：O(n)。</p><h4 id="代码实践："><a href="#代码实践：" class="headerlink" title="代码实践："></a>代码实践：</h4><p><strong>方法一实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">1000</span>] = <span class="string">"We are family."</span>;</span><br><span class="line"><span class="keyword">int</span> stringlen = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">int</span> indexNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringlen; i++)&#123;</span><br><span class="line"><span class="keyword">char</span> charStr = <span class="built_in">string</span>[i];</span><br><span class="line"><span class="keyword">if</span> (charStr == <span class="string">' '</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//将空格之后的字符向后移动</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = stringlen;j &gt; i; j--) &#123;</span><br><span class="line"><span class="built_in">string</span>[j+<span class="number">2</span>] = <span class="built_in">string</span>[j]; </span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span>[++indexNum] = <span class="string">'%'</span>;</span><br><span class="line"><span class="built_in">string</span>[++indexNum] = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">string</span>[++indexNum] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">i = i+<span class="number">2</span>;  </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">indexNum = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n-----one3 %s\n"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p><strong>方法二实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"We are family."</span>;</span><br><span class="line"><span class="keyword">int</span> strLen = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这段代码是用来计算辅助字符串的长度的;</span></span><br><span class="line"><span class="keyword">char</span> replaceStr[] = <span class="string">"%20"</span>;</span><br><span class="line"><span class="comment">//统计空格的数目</span></span><br><span class="line"><span class="keyword">int</span> bankNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++)&#123;</span><br><span class="line"><span class="keyword">char</span> charStr = str[i];</span><br><span class="line"><span class="keyword">if</span> (charStr == <span class="string">' '</span>) &#123;</span><br><span class="line">bankNumber++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> replacelen = bankNumber * (<span class="built_in">strlen</span>(replaceStr)<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> repStrNewlen = strLen + replacelen; </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据计算的字符串长度，创建辅助字符串</span></span><br><span class="line"><span class="keyword">char</span> newStr[repStrNewlen] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将str中的字符复制到辅助字符串中，并将空格替换为'%20'</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (strLen &gt; <span class="number">0</span> &amp;&amp; num &lt;= strLen) &#123;</span><br><span class="line"><span class="keyword">char</span> charS = str[num];</span><br><span class="line"><span class="keyword">if</span> (charS == <span class="string">' '</span>) &#123;</span><br><span class="line">newStr[index++] = <span class="string">'%'</span>;</span><br><span class="line">newStr[index++] = <span class="string">'2'</span>;</span><br><span class="line">newStr[index++] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">newStr[index++] = charS;</span><br><span class="line">&#125;</span><br><span class="line">++num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--------one2Result == %s"</span>,newStr);</span><br></pre></td></tr></table></figure><p><strong>方法三实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">"We are family."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计空格的数目</span></span><br><span class="line"><span class="keyword">int</span> bankNumber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> replaceStr[] = <span class="string">"%20"</span>;</span><br><span class="line"><span class="keyword">int</span> stringlen = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringlen; i++)&#123;</span><br><span class="line"><span class="keyword">char</span> charStr = <span class="built_in">string</span>[i];</span><br><span class="line"><span class="keyword">if</span> (charStr == <span class="string">' '</span>) &#123;</span><br><span class="line">bankNumber++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//替换字符增加的长度</span></span><br><span class="line"><span class="keyword">int</span> replacelen = bankNumber * (<span class="built_in">strlen</span>(replaceStr)<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//替换后的字符串长度</span></span><br><span class="line"><span class="keyword">int</span> repStrNewlen = stringlen + replacelen; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (stringlen &gt;= <span class="number">0</span> &amp;&amp; stringlen &lt; repStrNewlen) &#123;  </span><br><span class="line"><span class="keyword">char</span> char1 = <span class="built_in">string</span>[stringlen];</span><br><span class="line"><span class="keyword">if</span> (char1 == <span class="string">' '</span>) &#123;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = <span class="string">'%'</span>;</span><br><span class="line">bankNumber--;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = char1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--stringlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"result==%s \n"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”-则输出-“We-20are-20family-”。&quot;&gt;&lt;a href=&quot;#题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法：判断数组中是否含有某个整数</title>
    <link href="http://guohuaden.com/2019/04/12/Arithmetic-weekly3/"/>
    <id>http://guohuaden.com/2019/04/12/Arithmetic-weekly3/</id>
    <published>2019-04-12T08:00:18.000Z</published>
    <updated>2021-01-30T11:33:59.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。"><a href="#题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。" class="headerlink" title="题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。"></a>题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。</h3><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>二维数组。而且数组的排列顺序也给了规定：每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>二分查找方法，以及利用二维数组的排列顺序规则进行查找。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。"><a href="#1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。" class="headerlink" title="1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。"></a>1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。</h5><h5 id="2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。"><a href="#2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。" class="headerlink" title="2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。"></a>2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>&#125;, &#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>&#125;, &#123;<span class="number">21</span>,<span class="number">23</span>,<span class="number">36</span>&#125;, &#123;<span class="number">33</span>,<span class="number">36</span>,<span class="number">37</span>&#125;, &#123;<span class="number">42</span>,<span class="number">46</span>,<span class="number">49</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>,  <span class="number">7</span> , <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>, <span class="number">12</span>, <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span>, <span class="number">23</span>, <span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="number">33</span>, <span class="number">36</span>, <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="number">42</span>, <span class="number">46</span>, <span class="number">49</span></span><br></pre></td></tr></table></figure><h4 id="代码实践："><a href="#代码实践：" class="headerlink" title="代码实践："></a>代码实践：</h4><p><strong>方案一：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>][<span class="number">3</span>]=&#123; &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>&#125;, &#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>&#125;, &#123;<span class="number">21</span>,<span class="number">23</span>,<span class="number">36</span>&#125;, &#123;<span class="number">33</span>,<span class="number">36</span>,<span class="number">37</span>&#125;, &#123;<span class="number">42</span>,<span class="number">46</span>,<span class="number">49</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> targetNumber =  <span class="number">33</span>;</span><br><span class="line"><span class="keyword">int</span> numbers = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//行数 </span></span><br><span class="line"><span class="keyword">int</span> rowNumbers = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);  <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//列数</span></span><br><span class="line"><span class="keyword">int</span> lineNumbers= <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转成一维数组</span></span><br><span class="line"><span class="keyword">int</span> arrB[numbers];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowNumbers;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; lineNumbers;j++)&#123;</span><br><span class="line">arrB[i*lineNumbers+j] = arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;numbers ; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arrB[j] &gt; arrB[j - <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arrB[j];</span><br><span class="line">arrB[j] = arrB[j - <span class="number">1</span>];</span><br><span class="line">arrB[j - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = numbers;</span><br><span class="line"><span class="keyword">int</span> middle = (start+end)*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(middle &gt;= start || middle &lt;= end)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = arrB[middle];</span><br><span class="line"><span class="keyword">if</span> (num == targetNumber) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----%d-----"</span>,num);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; targetNumber)&#123;</span><br><span class="line">middle =  (end-middle)/<span class="number">2</span> + middle;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; targetNumber)&#123;</span><br><span class="line">middle =  (middle-start)/<span class="number">2</span> + start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">示例二维数组： int example[5][10]</span><br><span class="line">数组的总数为： </span><br><span class="line">sizeof(example) / sizeof(int)// sizeof(example)为该数组的大小(这里是5x10)，sizeof(int)为int类型的大小(4)</span><br><span class="line">数组列数为： </span><br><span class="line">sizeof(example[0])/sizeof(int)// sizeof(example[0])为该数组一行的大小(这里是10)</span><br><span class="line">数组行数则为 ：</span><br><span class="line">( sizeof(example) / sizeof(int) )/ ( sizeof(example[0]) / sizeof(int) )</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int arr[5][3]=&#123; &#123;5,7,10&#125;, &#123;10,12,23&#125;, &#123;21,23,36&#125;, &#123;33,36,37&#125;, &#123;42,46,49&#125; &#125;;</span><br><span class="line"></span><br><span class="line">int targetNumber =  33;</span><br><span class="line">int numbers = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">//行数 </span><br><span class="line">int rowNumbers = sizeof(arr)/sizeof(arr[0]);  // 5</span><br><span class="line">//列数</span><br><span class="line">int lineNumbers= sizeof(arr[0])/sizeof(int);  // 3</span><br><span class="line"></span><br><span class="line">int rowIndex = 0;</span><br><span class="line">bool result = false;</span><br><span class="line">while(lineNumbers &gt;= 0 &amp;&amp; rowNumbers &gt;= 0)&#123;</span><br><span class="line"></span><br><span class="line">int number = arr[rowIndex][lineNumbers-1];</span><br><span class="line">if (number == targetNumber) &#123;</span><br><span class="line">result = true;</span><br><span class="line">printf(&quot;-------%d----&quot;,number);</span><br><span class="line">return;</span><br><span class="line">&#125;else if(number &gt; targetNumber &amp;&amp; lineNumbers &gt;0)&#123;</span><br><span class="line">lineNumbers--;</span><br><span class="line">&#125;else if(number &lt; targetNumber &amp;&amp; rowIndex &lt; rowNumbers)&#123;</span><br><span class="line">rowIndex++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (result == false) &#123;</span><br><span class="line">printf(&quot;数组中未找到该数字&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。&quot;&gt;&lt;a href=&quot;#题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法：找出数组中重复的数字</title>
    <link href="http://guohuaden.com/2019/04/11/Arithmetic-weekly2/"/>
    <id>http://guohuaden.com/2019/04/11/Arithmetic-weekly2/</id>
    <published>2019-04-11T03:58:52.000Z</published>
    <updated>2021-01-30T11:33:42.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h3><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如：如果输入长度为 7 的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>从数组中找出重复的数字，如果没有提示！</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>遍历数组进行匹配，考虑时间复杂度问题。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、双重遍历"><a href="#1、双重遍历" class="headerlink" title="1、双重遍历"></a>1、双重遍历</h5><p>将数组中的每一个数与其他数做匹配，如果两者相等，输出，否则输出未找到提示。</p><h5 id="2、排序-遍历"><a href="#2、排序-遍历" class="headerlink" title="2、排序+遍历"></a>2、排序+遍历</h5><p>将数组排序，匹配相邻者数字，如果两者相等，输出，否则输出未找到提示。</p><h5 id="3、哈希表-遍历"><a href="#3、哈希表-遍历" class="headerlink" title="3、哈希表+遍历"></a>3、哈希表+遍历</h5><p>将遍历时的每个数存入哈希表中，每次存入的时候判断下是否</p><h5 id="4、辅助数组-遍历"><a href="#4、辅助数组-遍历" class="headerlink" title="4、辅助数组+遍历"></a>4、辅助数组+遍历</h5><p>创建一个辅助数组，然后逐一把原数组的每个数字复制到辅助数组中，如果原数组中被复制的数字是n,则把它复制到辅助数组中下标为n的位置。如果该位置已有相同的数字，则该数字为重复数字。该方案需要O(n)的辅助空间。</p><h5 id="5、类似二分查找方法"><a href="#5、类似二分查找方法" class="headerlink" title="5、类似二分查找方法"></a>5、类似二分查找方法</h5><p>前提：在一个长度为n的数组里的所有数字都在0~n-1的范围内。我们把从0~n-1的数字从中间的数字【 (n-1)/2】（下面以m表示）分为两部分，前半部分为0~m,后半部分为m+1 ~ n-1。如果1~m的数字个数超过m，则这个区间一定存在重复的数字；否则后半部分区间一定存在重复的数字。继续重复分割数字区间，直到找到一个重复的数字。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践:"></a>代码实践:</h4><p><strong>双重遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&lt;len;j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (number == arr[j]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,number);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"未找到"</span>);</span><br></pre></td></tr></table></figure><p><strong>排序+遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="keyword">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp;j--)&#123;</span><br><span class="line">arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[index];</span><br><span class="line"><span class="keyword">int</span> next = arr[index+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (number == next) &#123;</span><br><span class="line">result = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--%d---"</span>,number);</span><br><span class="line">&#125;</span><br><span class="line">index = index+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result == <span class="literal">false</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"未找到"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哈希表+遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len &lt;= <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =  <span class="number">0</span>; i &lt; len ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span> || arr[i] &gt; len<span class="number">-1</span> ) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> number = arr[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(number != i)&#123;</span><br><span class="line"><span class="keyword">int</span> nextNum = arr[number];</span><br><span class="line"><span class="keyword">if</span>(number == nextNum)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,number);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = number;</span><br><span class="line">arr[i] = nextNum;</span><br><span class="line">arr[number] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、辅助数组+遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr1[len+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[i];</span><br><span class="line"><span class="keyword">int</span> tagerNumber = arr1[number];</span><br><span class="line"><span class="keyword">if</span>(number == tagerNumber)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----%d\n"</span>,number);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">arr1[number] = number;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、类似二分查找方法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line"><span class="keyword">int</span> middle = (end+start)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//计算区间里的数字数目</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;=middle &amp;&amp; arr[i]&gt;=start)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果区间内的数字个数大于区间的应有个数（比如：10-20， 中间数为15，区间为10-15，区间内应有5个数）</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; middle-start+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//说明重复数字在[start,middle]中</span></span><br><span class="line">end = middle;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//说明重复数字在[middle,end]中</span></span><br><span class="line">start = middle+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找索引相遇代表查找结束。</span></span><br><span class="line"><span class="keyword">if</span>(end == start)&#123;</span><br><span class="line"><span class="comment">//count大于0，说明找到重复数字</span></span><br><span class="line"><span class="keyword">if</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,start);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;找出数组中重复的数字&quot;&gt;&lt;a href=&quot;#找出数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;找出数组中重复的数字&quot;&gt;&lt;/a&gt;找出数组中重复的数字&lt;/h3&gt;&lt;h4 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法：找出有序数组中和等于指定数的两个数</title>
    <link href="http://guohuaden.com/2019/04/04/Arithmetic-weekly1/"/>
    <id>http://guohuaden.com/2019/04/04/Arithmetic-weekly1/</id>
    <published>2019-04-04T02:27:55.000Z</published>
    <updated>2021-01-30T11:33:27.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题：找出有序数组中和等于指定数的两个数"><a href="#题：找出有序数组中和等于指定数的两个数" class="headerlink" title="题：找出有序数组中和等于指定数的两个数"></a>题：找出有序数组中和等于指定数的两个数</h3><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>数组是有序的；数组中可能存在两个数相加的和等于给定的值，找出这两个数，如果没有提示。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先想到的必须遍历数组，这点是毋庸置疑的。这时需要考虑的就是怎样遍历数组以及时间复杂度问题。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、双重遍历"><a href="#1、双重遍历" class="headerlink" title="1、双重遍历"></a>1、双重遍历</h5><p>最简单也是最笨重的想法是双重遍历：将每个数与另外的数相加，判断是否等于目标值，时间复杂度为O(n*n)。</p><h5 id="2、快速查找法"><a href="#2、快速查找法" class="headerlink" title="2、快速查找法"></a>2、快速查找法</h5><p><strong>方法一：</strong>从两端开始，分别向中间取值匹配。时间复杂度为O(n)。</p><p>(1)如果两数之和&gt;目标值,说明较大加数需要小些，向数组的较小值方向移位取值继续和原较小值重新匹配。</p><p>(2)如果两数之和&lt;目标值,说明较小加数需要大些，向数组的较大值方向移位取值继续和原较大值重新匹配。</p><p><strong>方法二：</strong>近一步思考：以数组中间下标(index)为分界点，分别向左右两边取值匹配。时间复杂度为O(n)。</p><p>  （1）若两数之和&gt;目标值，说明较小加数还要再小，向数组的较小值方向移位取值与原较大值重新匹配。</p><p>  （2）若两数之和&lt;目标值，说明较大加数还要再大，向数组的较大值方向移位取值与原较小值重新匹配。</p><p><strong>方法三：</strong>换一种方式思考，    两个加数一定满足条件：较小加数小于等于目标值的一半，并且较大值大于等于目标值的一半（较小加数&lt;= (目标值/2) &lt;= 较大加数）；那么只需要找出该数组的较小加数和较大加数分界index，以该分界为起点分别往左右两边逐个取值匹配。比较的方式遵循方法二的(1)(2)。时间复杂度仍为O(n)。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h4><h5 id="双重遍历"><a href="#双重遍历" class="headerlink" title="双重遍历"></a>双重遍历</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;51&quot;,@&quot;60&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">BOOL result = NO;</span><br><span class="line"></span><br><span class="line">for(NSInteger i = 0    ; i&lt; arr.count; i++)&#123;</span><br><span class="line">    NSInteger minNumber = [arr[i] integerValue];</span><br><span class="line">    </span><br><span class="line">    for (NSInteger j = i+1;j&lt; arr.count;j++) &#123;</span><br><span class="line">        NSInteger maxNumber = [arr[j] integerValue];</span><br><span class="line">        if(minNumber + maxNumber == targetNumber )&#123;</span><br><span class="line">            NSLog(@&quot;search3 :::::::%li---%li&quot;,minNumber,maxNumber);</span><br><span class="line">            result = YES;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h5><p><strong>方法一：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;24&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;50&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">BOOL result = NO;</span><br><span class="line">NSInteger minIndex = 0 ;</span><br><span class="line">NSInteger maxIndex = arr.count-1;</span><br><span class="line">do &#123;</span><br><span class="line">    NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">    if(sumNumber &gt; targetNumber)&#123;</span><br><span class="line">        maxIndex -- ;</span><br><span class="line">    &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">        minIndex++;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">        minIndex++;</span><br><span class="line">        maxIndex--;</span><br><span class="line">        result = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; while (minIndex &lt;= maxIndex);</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;24&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;50&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">NSInteger midIndex = arr.count*0.5;</span><br><span class="line">BOOL result = NO;</span><br><span class="line">if(midIndex &gt; 0)&#123;</span><br><span class="line">    NSInteger minIndex = midIndex ;</span><br><span class="line">    NSInteger maxIndex = midIndex+1;</span><br><span class="line">    do &#123;</span><br><span class="line">        NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">        if(sumNumber &gt; targetNumber)&#123;</span><br><span class="line">            minIndex -- ;</span><br><span class="line">        &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">            maxIndex++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">            minIndex--;</span><br><span class="line">            maxIndex++;</span><br><span class="line">            result = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; while (minIndex &gt;= 0 &amp;&amp; maxIndex &lt; arr.count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;51&quot;,@&quot;60&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">NSInteger midIndex = 0;</span><br><span class="line">BOOL result = NO;</span><br><span class="line">for (NSInteger i = 0;i&lt;arr.count;i++) &#123;</span><br><span class="line">    if([arr[i] integerValue] &gt; targetNumber*0.5)&#123;</span><br><span class="line">        midIndex = i - 1;</span><br><span class="line">        NSLog(@&quot;%ld&quot;,midIndex);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(midIndex != -1)&#123;</span><br><span class="line">    NSInteger minIndex = midIndex;</span><br><span class="line">    NSInteger maxIndex =  midIndex + 1;</span><br><span class="line">    do &#123;   </span><br><span class="line">        NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">        if (sumNumber &gt; targetNumber) &#123;</span><br><span class="line">            minIndex--;</span><br><span class="line">        &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">            maxIndex++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">            minIndex--;</span><br><span class="line">            maxIndex++;</span><br><span class="line">            result = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (minIndex &gt;= 0 &amp;&amp; (maxIndex &lt;= arr.count-1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题：找出有序数组中和等于指定数的两个数&quot;&gt;&lt;a href=&quot;#题：找出有序数组中和等于指定数的两个数&quot; class=&quot;headerlink&quot; title=&quot;题：找出有序数组中和等于指定数的两个数&quot;&gt;&lt;/a&gt;题：找出有序数组中和等于指定数的两个数&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>隐私协议</title>
    <link href="http://guohuaden.com/2019/01/25/PrivacyPolicy/"/>
    <id>http://guohuaden.com/2019/01/25/PrivacyPolicy/</id>
    <published>2019-01-25T07:19:56.000Z</published>
    <updated>2019-03-02T11:46:53.650Z</updated>
    
    <content type="html"><![CDATA[<p>本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三方提供。本软件会不时更新本隐私权政策。您在同意本软件服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本软件服务使用协议不可分割的一部分。</p><h3 id="1-适用范围"><a href="#1-适用范围" class="headerlink" title="1.适用范围"></a>1.适用范围</h3><p>a.在您使用本软件网络服务，本软件自动接收并记录的您的手机上的信息，包括但不限于您的健康数据、使用的语言、访问日期和时间等数据；</p><h3 id="2-信息的使用"><a href="#2-信息的使用" class="headerlink" title="2.信息的使用"></a>2.信息的使用</h3><p>a.在获得您的数据之后，本软件会将其上传至服务器，以便您能够更好地使用服务。</p><h3 id="3-信息披露"><a href="#3-信息披露" class="headerlink" title="3.信息披露"></a>3.信息披露</h3><p>a.本软件不会将您的信息披露给不受信任的第三方。</p><p>b.根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p><p>c.如您出现违反中国有关法律、法规或者相关规则的情况，需要向第三方披露；</p><h3 id="4-信息存储和交换"><a href="#4-信息存储和交换" class="headerlink" title="4.信息存储和交换"></a>4.信息存储和交换</h3><p>本软件收集的有关您的信息和资料将保存在本软件及服务器上，这些信息和资料可能传送至您所在国家、地区或本软件收集信息和资料所在地的境外并在境外被访问、存储和展示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>K最近邻算法</title>
    <link href="http://guohuaden.com/2019/01/07/Arithmetic6-KNN/"/>
    <id>http://guohuaden.com/2019/01/07/Arithmetic6-KNN/</id>
    <published>2019-01-07T13:38:58.000Z</published>
    <updated>2021-01-30T11:31:08.514Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>迪克特斯拉算法</title>
    <link href="http://guohuaden.com/2019/01/06/Arithmetic5-Dijkstra/"/>
    <id>http://guohuaden.com/2019/01/06/Arithmetic5-Dijkstra/</id>
    <published>2019-01-06T14:38:27.000Z</published>
    <updated>2021-01-30T11:31:14.694Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>深度优先搜索（DFS）</title>
    <link href="http://guohuaden.com/2019/01/05/Arithmetic4-DFS/"/>
    <id>http://guohuaden.com/2019/01/05/Arithmetic4-DFS/</id>
    <published>2019-01-05T13:37:34.000Z</published>
    <updated>2021-01-30T11:31:33.122Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>深度优先搜索，英文缩写为DFS，即Depth First Search 。</p><p>是针对图和树的遍历算法，其过程简要来说是对每一个可能的分支路径深入到不能深入为止，而且每个节点只能访问一次。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p><strong>从一个顶点V0开始，沿着一条路走到底，如果发现不能到达目标解，那就返回上一个节点，然后从另一条路走到底，重复上述，一直找到或者确定未找到为止</strong>，通俗点说：DFS是一条道走到黑，没路了就再换一条道走到黑，知道走通为止。</p><h3 id="图解逻辑"><a href="#图解逻辑" class="headerlink" title="图解逻辑"></a>图解逻辑</h3><p><img src="http://blog.guohuaden.com/DFS_1.png" alt="示例图"></p><p><img src="http://blog.guohuaden.com/DFS_2.png" alt="步骤1"></p><p><img src="http://blog.guohuaden.com/DFS_3.png" alt="步骤2"></p><p><img src="http://blog.guohuaden.com/DFS_4.png" alt="步骤3"></p><p><img src="http://blog.guohuaden.com/DFS_5.png" alt="步骤4"></p><p><img src="http://blog.guohuaden.com/DFS_6.png" alt="步骤5"></p><p><img src="http://blog.guohuaden.com/DFS_7.png" alt="步骤6"></p><p><img src="http://blog.guohuaden.com/DFS_8.png" alt="步骤7"></p><p><img src="http://blog.guohuaden.com/DFS_9.png" alt="步骤8"></p><p><img src="http://blog.guohuaden.com/DFS_10.png" alt="步骤9"></p><p><img src="http://blog.guohuaden.com/DFS_11.png" alt="步骤10"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><strong>DFS核心伪代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line">*@param n: 当前开始搜索的节点</span><br><span class="line"></span><br><span class="line">*@param d: 当前到达的深度</span><br><span class="line"></span><br><span class="line">*@return 是否有解 </span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">bool DFS(Node n ,int d) &#123;</span><br><span class="line"></span><br><span class="line">    if (isEnd(n,d)) &#123;//判断是否达到条件</span><br><span class="line">        return trun;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Node nextNode in n)&#123;//遍历相邻的节点nextNode</span><br><span class="line"></span><br><span class="line">        if(!visit[nextNode])&#123;</span><br><span class="line"></span><br><span class="line">            visit[nextNode] = true;//在下一次搜索中，nextNode不能再次出现</span><br><span class="line"></span><br><span class="line">            if(DFS(nextNode,d+1))&#123;//如果搜索出有解</span><br><span class="line"></span><br><span class="line">               //做些其他的事情，例如记录结果深度等</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            //重新设置成false，因为它有可能在下一次搜索的别的 路径中</span><br><span class="line">           visit[nextNode] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码框架</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Node n)&#123;</span><br><span class="line"></span><br><span class="line">    if(达到结束状态)&#123;</span><br><span class="line">        ... //根据题意，做一些相应的操作</span><br><span class="line">        retrun;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(越界/不合法状态)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(Node nextNode in n)&#123;</span><br><span class="line">        if(扩张方法达到合法状态)&#123;</span><br><span class="line">            修改操作;//根据题意，做一些相应的操作</span><br><span class="line">            做访问过标记;</span><br><span class="line">            DFS(nextNode);</span><br><span class="line">            还原标记; //根据题意决定是否加上还原标记，如果加上就是回溯法。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪代码分析"><a href="#伪代码分析" class="headerlink" title="伪代码分析"></a>伪代码分析</h3><ol><li><p>访问路径的确定。根据不同的题目思考怎么访问一个路径，如何实现遍历</p></li><li><p>起点条件。从哪个点开始访问？是否每个点都需要当作起点？所以第一次遍历调用DFS的时机至关重要</p></li><li><p>递归参数。怎么在访问的节点上继续向下个节点访问，实现递归需要传递什么参数？</p></li><li><p>结束条件。访问的结束条件是什么？符合题意的结束条件或者临界点作为结束的判断依据</p></li><li><p>访问标志。将已访问且不符合条件的的节点做标记，防止重复访问</p></li><li><p>优化。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;深度优先搜索，英文缩写为DFS，即Depth First Search 。&lt;/p&gt;
&lt;p&gt;是针对图和树的遍历算法，其过程简要来说是对每一个可
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://guohuaden.com/2019/01/03/Arithmetic3-DynamicProgramming/"/>
    <id>http://guohuaden.com/2019/01/03/Arithmetic3-DynamicProgramming/</id>
    <published>2019-01-03T13:32:21.000Z</published>
    <updated>2021-01-30T11:31:39.321Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：选择排序</title>
    <link href="http://guohuaden.com/2018/12/31/Arithmetic-Basice-SelectSort/"/>
    <id>http://guohuaden.com/2018/12/31/Arithmetic-Basice-SelectSort/</id>
    <published>2018-12-31T12:52:49.000Z</published>
    <updated>2021-01-30T11:33:16.518Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：插入排序</title>
    <link href="http://guohuaden.com/2018/12/30/Arithmetic-Basice-InsertSort/"/>
    <id>http://guohuaden.com/2018/12/30/Arithmetic-Basice-InsertSort/</id>
    <published>2018-12-30T13:10:56.000Z</published>
    <updated>2021-01-30T11:33:15.386Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>递归和for循环</title>
    <link href="http://guohuaden.com/2018/12/01/Arithmetic2-RecursionAndFor/"/>
    <id>http://guohuaden.com/2018/12/01/Arithmetic2-RecursionAndFor/</id>
    <published>2018-12-01T13:05:51.000Z</published>
    <updated>2021-01-30T11:31:48.417Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：交换排序</title>
    <link href="http://guohuaden.com/2018/11/29/Arithmetic-Basice-ExchangeSort/"/>
    <id>http://guohuaden.com/2018/11/29/Arithmetic-Basice-ExchangeSort/</id>
    <published>2018-11-29T12:54:23.000Z</published>
    <updated>2021-01-30T11:33:13.863Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>基础算法一：排序</title>
    <link href="http://guohuaden.com/2018/11/28/Arithmetic-basics/"/>
    <id>http://guohuaden.com/2018/11/28/Arithmetic-basics/</id>
    <published>2018-11-28T12:14:26.000Z</published>
    <updated>2021-01-30T11:33:17.807Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="http://guohuaden.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://guohuaden.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 七 （SDWebImageTransition）</title>
    <link href="http://guohuaden.com/2018/10/30/Read-SDWebImage-SDWebImageTransition/"/>
    <id>http://guohuaden.com/2018/10/30/Read-SDWebImage-SDWebImageTransition/</id>
    <published>2018-10-30T13:32:19.000Z</published>
    <updated>2018-11-02T08:04:14.440Z</updated>
    
    <content type="html"><![CDATA[<p>该类用于在视图类别加载图像完成后提供过渡动画。 </p><ol><li><p>在<code>UIVit + WebCache.h</code> 中的 <code>sd_imageTransition</code><br> 用于<code>UIKit(iOS和tvOS)</code>，使用<br> <code>+ [UIView transitionWithView：duration：options：animations：completion]</code> 进行过渡动画。 </p></li><li><p>对于<code>AppKit(macOS)</code><br>使用 <code>+ [NSAnimationContext runAnimationGroup：completionHandler：]</code>进行过渡动画。 我们可以调用<code>+ [NSAnimationContext currentContext]</code>来获取动画块中的上下文。 提供这些转换以用于基本用途。 </p></li></ol><ol start="3"><li>如果需要复杂的动画，可以考虑直接使用<code>Core Animation</code>或使用<code>SDWebImageAvoidAutoSetImage</code>并实现自己的后映像加载完成。<a id="more"></a></li></ol><h3 id="动画选项"><a href="#动画选项" class="headerlink" title="动画选项"></a>动画选项</h3><p>分两种情况，如果是 SD_UIKIT 类型，就直接使用系统的动画选项，否则定义的枚举类型只有一种隐式动画</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT</span><br><span class="line">typedef UIViewAnimationOptions SDWebImageAnimationOptions;</span><br><span class="line">#else</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageAnimationOptions) &#123;</span><br><span class="line">    SDWebImageAnimationOptionAllowsImplicitAnimation = 1 &lt;&lt; 0, // specify `allowsImplicitAnimation` for the `NSAnimationContext`</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="三个block代码块"><a href="#三个block代码块" class="headerlink" title="三个block代码块"></a>三个block代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用于动画开始之前要执行的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionPreparesBlock)(__kindof UIView * _Nonnull view, UIImage * _Nullable image, NSData * _Nullable imageData, SDImageCacheType cacheType, NSURL * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//用于控制展示动画的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionAnimationsBlock)(__kindof UIView * _Nonnull view, UIImage * _Nullable image);</span><br><span class="line"></span><br><span class="line">//用于动画结束后要执行的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionCompletionBlock)(BOOL finished);</span><br></pre></td></tr></table></figure><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下，我们将图像设置为动画开头的视图。 您可以禁用此功能并提供自定义设置图像处理</span><br><span class="line">@property (nonatomic, assign) BOOL avoidAutoSetImage;</span><br><span class="line"></span><br><span class="line">//过渡动画的持续时间，以秒为单位。 默认为0.5。</span><br><span class="line">@property (nonatomic, assign) NSTimeInterval duration;</span><br><span class="line"></span><br><span class="line">//用于此过渡动画（macOS）中所有动画的计时功能。</span><br><span class="line">@property (nonatomic, strong, nullable) CAMediaTimingFunction *timingFunction NS_AVAILABLE_MAC(10_7);</span><br><span class="line"></span><br><span class="line">//一个动画选项</span><br><span class="line">@property (nonatomic, assign) SDWebImageAnimationOptions animationOptions;</span><br><span class="line"></span><br><span class="line">//动画开始前所要执行的代码块</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionPreparesBlock prepares;</span><br><span class="line"></span><br><span class="line">动画代码块</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionAnimationsBlock animations;</span><br><span class="line"></span><br><span class="line">//动画结束时要执行的代码块。</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionCompletionBlock completion;</span><br></pre></td></tr></table></figure><h3 id="Conveniences分类"><a href="#Conveniences分类" class="headerlink" title="Conveniences分类"></a>Conveniences分类</h3><p>创建过渡的便捷方式 如果需要，请记住指定持续时间。 对于UIKit，这些转换只使用对应的<code>animationOptions</code>。 默认情况下，我们启用<code>UIViewAnimationOptionAllowUserInteraction</code>以允许用户在转换期间进行交互。 对于AppKit，这些过渡在“动画”中使用了Core Animation。 因此，您的视图必须是图层支持的。 在应用之前设置<code>wantsLayer = YES</code>。</p><h4 id="公共属性和方法"><a href="#公共属性和方法" class="headerlink" title="公共属性和方法"></a>公共属性和方法</h4><p>调用不同的类属性获取不同的动画效果，如果类属性不可用，就调用类方法类获取不同的动画效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#if __has_feature(objc_class_property)</span><br><span class="line">/// 淡出过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *fadeTransition;</span><br><span class="line">/// 从左转换翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromLeftTransition;</span><br><span class="line">/// 从右转换翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromRightTransition;</span><br><span class="line">/// 从顶部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromTopTransition;</span><br><span class="line">/// 从底部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromBottomTransition;</span><br><span class="line">/// 卷起过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlUpTransition;</span><br><span class="line">/// 向下弯曲过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlDownTransition;</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">+ (nonnull instancetype)fadeTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromLeftTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromRightTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromTopTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromBottomTransition;</span><br><span class="line">+ (nonnull instancetype)curlUpTransition;</span><br><span class="line">+ (nonnull instancetype)curlDownTransition;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p><code>SDWebImageTransition</code> 只有一个初始化方法，设置了动画时间为0.5秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation SDWebImageTransition</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.duration = 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>SDWebImageTransition 分类中创建了不同的动画,这里区别了SD_UIKIT 和 其他。（即iOS 、tvOS、部分watchOS ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">+ (SDWebImageTransition *)fadeTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCrossDissolve | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionFade;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromLeftTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromLeft | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromLeft;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromRightTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromRight | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromRight;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromTopTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromTop | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromTop;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromBottomTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromBottom | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromBottom;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)curlUpTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCurlUp | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionReveal;</span><br><span class="line">        trans.subtype = kCATransitionFromTop;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)curlDownTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCurlDown | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionReveal;</span><br><span class="line">        trans.subtype = kCATransitionFromBottom;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该类用于在视图类别加载图像完成后提供过渡动画。 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;UIVit + WebCache.h&lt;/code&gt; 中的 &lt;code&gt;sd_imageTransition&lt;/code&gt;&lt;br&gt; 用于&lt;code&gt;UIKit(iOS和tvOS)&lt;/code&gt;，使用&lt;br&gt; &lt;code&gt;+ [UIView transitionWithView：duration：options：animations：completion]&lt;/code&gt; 进行过渡动画。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于&lt;code&gt;AppKit(macOS)&lt;/code&gt;&lt;br&gt;使用 &lt;code&gt;+ [NSAnimationContext runAnimationGroup：completionHandler：]&lt;/code&gt;进行过渡动画。 我们可以调用&lt;code&gt;+ [NSAnimationContext currentContext]&lt;/code&gt;来获取动画块中的上下文。 提供这些转换以用于基本用途。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;如果需要复杂的动画，可以考虑直接使用&lt;code&gt;Core Animation&lt;/code&gt;或使用&lt;code&gt;SDWebImageAvoidAutoSetImage&lt;/code&gt;并实现自己的后映像加载完成。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （SDWebImagePrefetcher）</title>
    <link href="http://guohuaden.com/2018/10/27/Read-SDWebImage-SDWebImagePrefetcher/"/>
    <id>http://guohuaden.com/2018/10/27/Read-SDWebImage-SDWebImagePrefetcher/</id>
    <published>2018-10-27T14:32:36.000Z</published>
    <updated>2018-11-02T08:04:38.550Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImagePrefetcher</code> 预先下载（预加载）图片，以方便后续使用，主要是用于部分图片需要先行下载并存储的情况。预先取出缓存中的一些URLs以供将来使用。 图像以低优先级下载。</p><p><code>SDWebImagePrefetcher</code> 设计了两种回调方式：</p><ol><li><p><code>SDWebImagePrefetcherDelegate</code><br>用来处理每一个预下载完成的回调，以及所有下载完成的回调 </p></li><li><p><code>block</code><br>用来处理整体进度的回调，返回的是下载完成的数量和总数量等</p></li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImagePrefetcherDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在预加载图片时调用。</span><br><span class="line"> *</span><br><span class="line"> * @param imagePrefetcher 当前图片预加载类</span><br><span class="line"> * @param imageURL       预加载的图片网址</span><br><span class="line"> * @param finishedCount   预加载的图片总数（成功与否）</span><br><span class="line"> * @param totalCount      预加载的图片总数</span><br><span class="line"> */</span><br><span class="line">- (void)imagePrefetcher:(nonnull SDWebImagePrefetcher *)imagePrefetcher didPrefetchURL:(nullable NSURL *)imageURL finishedCount:(NSUInteger)finishedCount totalCount:(NSUInteger)totalCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在预加载所有图像时调用。</span><br><span class="line"> * @param imagePrefetcher 当前图片的预加载类</span><br><span class="line"> * @param totalCount      预加载的图片总数（无论是否成功）</span><br><span class="line"> * @param skippedCount    跳过的图片总数</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)imagePrefetcher:(nonnull SDWebImagePrefetcher *)imagePrefetcher didFinishWithTotalCount:(NSUInteger)totalCount skippedCount:(NSUInteger)skippedCount;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="两个block代码块"><a href="#两个block代码块" class="headerlink" title="两个block代码块"></a>两个block代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 预加载进度block</span><br><span class="line"> @param noOfFinishedUrls 已经完成的数量，无论成功失败</span><br><span class="line"> @param noOfTotalUrls    总数量</span><br><span class="line"> */</span><br><span class="line">typedef void(^SDWebImagePrefetcherProgressBlock)(NSUInteger noOfFinishedUrls, NSUInteger noOfTotalUrls);</span><br><span class="line">/**</span><br><span class="line"> 预加载完成block</span><br><span class="line"></span><br><span class="line"> @param noOfFinishedUrls 已经完成的数量，无论成功失败</span><br><span class="line"> @param noOfSkippedUrls  跳过的数量</span><br><span class="line"> */</span><br><span class="line">typedef void(^SDWebImagePrefetcherCompletionBlock)(NSUInteger noOfFinishedUrls, NSUInteger noOfSkippedUrls);</span><br></pre></td></tr></table></figure><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 网络图片管理器,只读</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, readonly, nonnull) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *同时预加载的最大URL数。 默认为3。</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) NSUInteger maxConcurrentDownloads;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 预加载的SDWebImageOptions选项。 默认为SDWebImageLowPriority。</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) SDWebImageOptions options;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Prefetcher的队列选项。 默认为主队列。</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_queue_t prefetcherQueue;</span><br><span class="line"></span><br><span class="line">//协议</span><br><span class="line">@property (weak, nonatomic, nullable) id &lt;SDWebImagePrefetcherDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><h3 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回全局图像预加载实例。</span><br><span class="line"> */</span><br><span class="line">+ (nonnull instancetype)sharedImagePrefetcher;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 允许您使用任意图像管理器实例化预加载类。</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithImageManager:(nonnull SDWebImageManager *)manager NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分配URL列表以让SDWebImagePrefetcher对预加载进行排队</span><br><span class="line"> * 目前一次下载一张图片，并跳过下载失败的图像，然后进入列表中的下一个图像。任何先前运行的预加载操作都将被取消。</span><br><span class="line"> * @param urls 预加载的URL列表</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分配URL列表以让SDWebImagePrefetcher对预加载进行排队，目前一次下载一张图片，并跳过下载失败的图像，然后进入列表中的下一个图像。任何先前运行的预加载操作都将被取消。</span><br><span class="line"> * currently one image is downloaded at a time,</span><br><span class="line"> * and skips images for failed downloads and proceed to the next image in the list.</span><br><span class="line"> * Any previously-running prefetch operations are canceled.</span><br><span class="line"> *</span><br><span class="line"> * @param urls           预加载的URL列表</span><br><span class="line"> * @param progressBlock   block块在进度更新时被调用;</span><br><span class="line"> *                        第一个参数是已完成（成功或未成功）请求的数量，</span><br><span class="line"> *                        第二个参数是最初请求预加载的图像总数</span><br><span class="line"> * @param completionBlock Block块在预加载完成时被调用</span><br><span class="line"> *                       第一个参数是已完成（成功或未成功）请求的数量，</span><br><span class="line"> *                        第二个参数是跳过的请求数</span><br><span class="line"> */</span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls</span><br><span class="line">            progress:(nullable SDWebImagePrefetcherProgressBlock)progressBlock</span><br><span class="line">           completed:(nullable SDWebImagePrefetcherCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除并取消排队列表</span><br><span class="line"> */</span><br><span class="line">- (void)cancelPrefetching;</span><br></pre></td></tr></table></figure><h3 id="私有属性声明"><a href="#私有属性声明" class="headerlink" title="私有属性声明"></a>私有属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//.h文件manager管理器声明为只读，这里声明为读写类型。实现外部只能访问，内部可读写。</span><br><span class="line">@property (strong, nonatomic, nonnull) SDWebImageManager *manager;</span><br><span class="line">//可以从不同的队列访问</span><br><span class="line">@property (strong, atomic, nullable) NSArray&lt;NSURL *&gt; *prefetchURLs; </span><br><span class="line"></span><br><span class="line">//已请求的数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger requestedCount;</span><br><span class="line">//已跳过的数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger skippedCount;</span><br><span class="line">//已完成的数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger finishedCount;</span><br><span class="line">//已开始的时间</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval startedTime;</span><br><span class="line">//预加载图片完成代码块</span><br><span class="line">@property (copy, nonatomic, nullable) SDWebImagePrefetcherCompletionBlock completionBlock;</span><br><span class="line">//预加载图片进度代码块</span><br><span class="line">@property (copy, nonatomic, nullable) SDWebImagePrefetcherProgressBlock progressBlock;</span><br></pre></td></tr></table></figure><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (nonnull instancetype)sharedImagePrefetcher &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithImageManager:[SDWebImageManager new]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithImageManager:(SDWebImageManager *)manager &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        //图片管理器</span><br><span class="line">        _manager = manager;</span><br><span class="line">        </span><br><span class="line">        预加载的SDWebImageOptions选项。 默认为SDWebImageLowPriority。</span><br><span class="line">        _options = SDWebImageLowPriority;</span><br><span class="line">        //Prefetcher的队列选项。 默认为主队列。</span><br><span class="line">        _prefetcherQueue = dispatch_get_main_queue();</span><br><span class="line">        //同时预加载的最大URL数。 默认为3。</span><br><span class="line">        self.maxConcurrentDownloads = 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性get和set方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//同时预加载的最大数的set方法</span><br><span class="line">- (void)setMaxConcurrentDownloads:(NSUInteger)maxConcurrentDownloads &#123;</span><br><span class="line">    self.manager.imageDownloader.maxConcurrentDownloads = maxConcurrentDownloads;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同时预加载的最大数的get方法</span><br><span class="line">- (NSUInteger)maxConcurrentDownloads &#123;</span><br><span class="line">    return self.manager.imageDownloader.maxConcurrentDownloads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预加载图片实现方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">- (void)startPrefetchingAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    //创建临时变量，用于存储当前的URL</span><br><span class="line">    NSURL *currentURL;</span><br><span class="line">    </span><br><span class="line">    //同步锁，判断index是否越界，如果越界就返回，否则获取当前的URL，赋值给临时变量currentURL，已请求的数量+1</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        if (index &gt;= self.prefetchURLs.count) return;</span><br><span class="line">        currentURL = self.prefetchURLs[index];</span><br><span class="line">        self.requestedCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //图片管理器加载当前URL的图片</span><br><span class="line">    [self.manager loadImageWithURL:currentURL options:self.options progress:nil completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">        </span><br><span class="line">        //如果已经完成，返回</span><br><span class="line">        if (!finished) return;</span><br><span class="line">        </span><br><span class="line">        //完成的记数+1</span><br><span class="line">        self.finishedCount++;</span><br><span class="line"></span><br><span class="line">        //如果需要过程回调，执行过程回调操作</span><br><span class="line">        if (self.progressBlock) &#123;</span><br><span class="line">            self.progressBlock(self.finishedCount,(self.prefetchURLs).count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果图片不存在，跳过的记数+1</span><br><span class="line">        if (!image) &#123;</span><br><span class="line">            // Add last failed</span><br><span class="line">            self.skippedCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果delegate存在，执行delegate方法</span><br><span class="line">        if ([self.delegate respondsToSelector:@selector(imagePrefetcher:didPrefetchURL:finishedCount:totalCount:)]) &#123;</span><br><span class="line">            [self.delegate imagePrefetcher:self</span><br><span class="line">                            didPrefetchURL:currentURL</span><br><span class="line">                             finishedCount:self.finishedCount</span><br><span class="line">                                totalCount:self.prefetchURLs.count</span><br><span class="line">             ];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果预下载的URLs数量大于已经下载的数量，就说明还有没下载完的任务，继续下载下一个。（这里是使用的递归方法）</span><br><span class="line">        if (self.prefetchURLs.count &gt; self.requestedCount) &#123;</span><br><span class="line">            dispatch_async(self.prefetcherQueue, ^&#123;</span><br><span class="line">                // 我们需要调度来避免函数递归调用。 即使对于巨大的URL列表，这也可以防止堆栈溢出</span><br><span class="line">                [self startPrefetchingAtIndex:self.requestedCount];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else if (self.finishedCount == self.requestedCount) &#123; //如果预下载的URLs数量等于已经下载的数量，说明已经下载完。</span><br><span class="line">        </span><br><span class="line">            //执行预加载完成的delegate方法。</span><br><span class="line">            [self reportStatus];</span><br><span class="line">            </span><br><span class="line">            //如果有需要，执行完成block回调</span><br><span class="line">            if (self.completionBlock) &#123;</span><br><span class="line">                self.completionBlock(self.finishedCount, self.skippedCount);</span><br><span class="line">                </span><br><span class="line">                //将self.completionBlock 置空</span><br><span class="line">                self.completionBlock = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            //将self.progressBlock 置空</span><br><span class="line">            self.progressBlock = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//预加载完成状态的delegate方法</span><br><span class="line">- (void)reportStatus &#123;</span><br><span class="line">    NSUInteger total = (self.prefetchURLs).count;</span><br><span class="line">    if ([self.delegate respondsToSelector:@selector(imagePrefetcher:didFinishWithTotalCount:skippedCount:)]) &#123;</span><br><span class="line">        [self.delegate imagePrefetcher:self</span><br><span class="line">               didFinishWithTotalCount:(total - self.skippedCount)</span><br><span class="line">                          skippedCount:self.skippedCount</span><br><span class="line">         ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配URL列表使得SDWebImagePrefetcher来安排预加载队列，当前同一时间下载一张图片，忽略下载时间的图片并继续执行列表中的下一张图片。任何之前执行的预加载操作都会被取消。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//urls：预加载的URL列表。</span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls &#123;</span><br><span class="line">    [self prefetchURLs:urls progress:nil completed:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls</span><br><span class="line">            progress:(nullable SDWebImagePrefetcherProgressBlock)progressBlock</span><br><span class="line">           completed:(nullable SDWebImagePrefetcherCompletionBlock)completionBlock &#123;</span><br><span class="line">    //防止重复的预加载请求</span><br><span class="line">    [self cancelPrefetching]; </span><br><span class="line">    </span><br><span class="line">    //CFAbsoluteTimeGetCurrent() 返回网络时间同步的时钟时间</span><br><span class="line">    self.startedTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    </span><br><span class="line">    //预加载的URL列表</span><br><span class="line">    self.prefetchURLs = urls;</span><br><span class="line">    </span><br><span class="line">    代码块</span><br><span class="line">    self.completionBlock = completionBlock;</span><br><span class="line">    self.progressBlock = progressBlock;</span><br><span class="line">    </span><br><span class="line">    //如果预加载的URL列表为空，直接回调完成代码块，没有完成的urls和没有跳过的urls都传0</span><br><span class="line">    if (urls.count == 0) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(0,0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 从具有最大允许并发性的列表中的第一个图像开始预加载，然后执行预加载操作</span><br><span class="line">        NSUInteger listCount = self.prefetchURLs.count;</span><br><span class="line">        for (NSUInteger i = 0; i &lt; self.maxConcurrentDownloads &amp;&amp; self.requestedCount &lt; listCount; i++) &#123;</span><br><span class="line">            [self startPrefetchingAtIndex:i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防止重复的预加载请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancelPrefetching &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.prefetchURLs = nil;</span><br><span class="line">        self.skippedCount = 0;</span><br><span class="line">        self.requestedCount = 0;</span><br><span class="line">        self.finishedCount = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.manager cancelAll];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImagePrefetcher&lt;/code&gt; 预先下载（预加载）图片，以方便后续使用，主要是用于部分图片需要先行下载并存储的情况。预先取出缓存中的一些URLs以供将来使用。 图像以低优先级下载。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImagePrefetcher&lt;/code&gt; 设计了两种回调方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SDWebImagePrefetcherDelegate&lt;/code&gt;&lt;br&gt;用来处理每一个预下载完成的回调，以及所有下载完成的回调 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;block&lt;/code&gt;&lt;br&gt;用来处理整体进度的回调，返回的是下载完成的数量和总数量等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六（编码器五：SDWebImageGIFCoder）</title>
    <link href="http://guohuaden.com/2018/10/24/Read-SDWebImage-SDWebImageGIFCoder/"/>
    <id>http://guohuaden.com/2018/10/24/Read-SDWebImage-SDWebImageGIFCoder/</id>
    <published>2018-10-24T14:31:13.000Z</published>
    <updated>2018-10-30T07:54:59.410Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code> 和 <code>SDWebImageProgressiveCoder</code> ）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）。</p><p><code>SDWebImageImageIOCoder</code> ：内置编码器,该类遵守了 <code>SDWebImageCoder</code>协议，但并没有遵守 <code>SDWebImageProgressiveCoder</code>协议，说明该类仅针对git图片的编解码，并不支持git图片的逐行解码功能。<a id="more"></a></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>判断图片格式是否支持编码，该类仅针对动图的操作，所以仅判断图片的格式是否为GIF格式，如果是返回YES，否则返回NO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    return (format == SDImageFormatGIF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据给定的图片格式将图片进行编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    //如果image不存在，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //该类只支持动图的编解码，如果image的格式不是GIF，返回nil</span><br><span class="line">    if (format != SDImageFormatGIF) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //临时变量imageData，用来保存图片数据</span><br><span class="line">    NSMutableData *imageData = [NSMutableData data];</span><br><span class="line">    // 获取GIF图像格式的CFStringRef格式字符串</span><br><span class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</span><br><span class="line">    // 生成图片对象的SDWebImageFrame类型元素的数组</span><br><span class="line">    NSArray&lt;SDWebImageFrame *&gt; *frames = [SDWebImageCoderHelper framesFromAnimatedImage:image];</span><br><span class="line">    </span><br><span class="line">    // 创建图像目标。 GIF不支持EXIF图像方向</span><br><span class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frames.count, NULL);</span><br><span class="line">    </span><br><span class="line">    //如果创建失败，返回nil</span><br><span class="line">    if (!imageDestination) &#123;</span><br><span class="line">        // Handle failure.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (frames.count == 0) &#123;</span><br><span class="line">        // 用于静态单个GIF图片（如果是单帧的动图就直接将图片添加到imageDestination中）</span><br><span class="line">        CGImageDestinationAddImage(imageDestination, image.CGImage, nil);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 用于动画的GIF图片</span><br><span class="line">        //// 获取到动图的循环次数</span><br><span class="line">        NSUInteger loopCount = image.sd_imageLoopCount;</span><br><span class="line">        </span><br><span class="line">        // 创建一个动图属性字典保存循环次数</span><br><span class="line">        NSDictionary *gifProperties = @&#123;(__bridge NSString *)kCGImagePropertyGIFDictionary: @&#123;(__bridge NSString *)kCGImagePropertyGIFLoopCount : @(loopCount)&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        // 为图像目标设置属性</span><br><span class="line">        CGImageDestinationSetProperties(imageDestination, (__bridge CFDictionaryRef)gifProperties);</span><br><span class="line">        </span><br><span class="line">        //循环每一帧的图拼啊</span><br><span class="line">        for (size_t i = 0; i &lt; frames.count; i++) &#123;</span><br><span class="line">             // 获取SDWebImageFrame对象</span><br><span class="line">            SDWebImageFrame *frame = frames[i];</span><br><span class="line">            </span><br><span class="line">            //获取没一帧的显示时间</span><br><span class="line">            float frameDuration = frame.duration;</span><br><span class="line">            </span><br><span class="line">            //获取每一帧取位图图片</span><br><span class="line">            CGImageRef frameImageRef = frame.image.CGImage;</span><br><span class="line">            </span><br><span class="line">            // 创建一个临时变量字典保存每一帧的展示时间</span><br><span class="line">            NSDictionary *frameProperties = @&#123;(__bridge NSString *)kCGImagePropertyGIFDictionary : @&#123;(__bridge NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</span><br><span class="line">            </span><br><span class="line">            // 将位图和其对应的属性添加到imageDestination中</span><br><span class="line">            CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果编码失败就返回nil</span><br><span class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</span><br><span class="line">       </span><br><span class="line">        imageData = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 释放imageDestination对象</span><br><span class="line">    CFRelease(imageDestination);</span><br><span class="line">    </span><br><span class="line">    返回图片数据</span><br><span class="line">    return [imageData copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>判断是否支持图片数据的解码<br>该类仅针对动图的操作，所以仅判断图片的格式是否为GIF格式，如果是支持该图片数据解码，否则返回NO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canDecodeFromData:(nullable NSData *)data &#123;</span><br><span class="line">    return ([NSData sd_imageFormatForImageData:data] == SDImageFormatGIF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图片数据解码为图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    //如果数据为空，返回nil</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#if SD_MAC</span><br><span class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:data];</span><br><span class="line">    NSImage *animatedImage = [[NSImage alloc] initWithSize:imageRep.size];</span><br><span class="line">    [animatedImage addRepresentation:imageRep];</span><br><span class="line">    return animatedImage;</span><br><span class="line">#else</span><br><span class="line">     // 生成图片源</span><br><span class="line">    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);</span><br><span class="line">    //如果图片源不存在，返回nil</span><br><span class="line">    if (!source) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取子图片数量</span><br><span class="line">    size_t count = CGImageSourceGetCount(source);</span><br><span class="line">    </span><br><span class="line">    // 创建临时变量，用来保存动图对象</span><br><span class="line">    UIImage *animatedImage;</span><br><span class="line">    </span><br><span class="line">    //如果子图片个数不大于2，直接将数据转化成图片</span><br><span class="line">    if (count &lt;= 1) &#123;</span><br><span class="line">        animatedImage = [[UIImage alloc] initWithData:data];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 创建可变数组保存SDWebImageFrame对象</span><br><span class="line">        NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</span><br><span class="line">        </span><br><span class="line">        // 遍历子图片对象，并将其包装成SDWebImageFrame对象</span><br><span class="line">        for (size_t i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            // 获取指定帧数的相位图</span><br><span class="line">            CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, i, NULL);</span><br><span class="line">            // 如果没获取到就跳过进入下次循环</span><br><span class="line">            if (!imageRef) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 获取指定帧数的持续时间</span><br><span class="line">            float duration = [self sd_frameDurationAtIndex:i source:source];</span><br><span class="line">            </span><br><span class="line">            // 根据相位图生成图片对象</span><br><span class="line">            UIImage *image = [[UIImage alloc] initWithCGImage:imageRef];</span><br><span class="line">            </span><br><span class="line">            // 释放相位图</span><br><span class="line">            CGImageRelease(imageRef);</span><br><span class="line">            </span><br><span class="line">            // 将一帧的信息封装成SDWebImageFrame对象</span><br><span class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration];</span><br><span class="line">            </span><br><span class="line">            // 将封装好的SDWebImageFrame对象添加到数组中保存</span><br><span class="line">            [frames addObject:frame];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 创建临时变量，用来保存循环次数</span><br><span class="line">        NSUInteger loopCount = 1;</span><br><span class="line">        </span><br><span class="line">        // 获取到图片属性</span><br><span class="line">        NSDictionary *imageProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyProperties(source, nil);</span><br><span class="line">        </span><br><span class="line">        // 获取到GIF相关的图像属性</span><br><span class="line">        NSDictionary *gifProperties = [imageProperties valueForKey:(__bridge NSString *)kCGImagePropertyGIFDictionary];</span><br><span class="line">        </span><br><span class="line">        如果gifProperties存在</span><br><span class="line">        if (gifProperties) &#123;</span><br><span class="line">            //获取GIF循环次数</span><br><span class="line">            NSNumber *gifLoopCount = [gifProperties valueForKey:(__bridge NSString *)kCGImagePropertyGIFLoopCount];</span><br><span class="line">            </span><br><span class="line">            //如果可以转换成NSNumber类型，就将获取到的GIF循环次数赋值给loopCount</span><br><span class="line">            if (gifLoopCount != nil) &#123;</span><br><span class="line">                loopCount = gifLoopCount.unsignedIntegerValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 利用封装好的SDWebImageFrame对象数组生成动图对象</span><br><span class="line">        animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</span><br><span class="line">        // 设置动图对象的循环次数</span><br><span class="line">        animatedImage.sd_imageLoopCount = loopCount;</span><br><span class="line">        //设置动图的图片格式</span><br><span class="line">        animatedImage.sd_imageFormat = SDImageFormatGIF;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //释放图片源source</span><br><span class="line">    CFRelease(source);</span><br><span class="line">    </span><br><span class="line">    //返回动图</span><br><span class="line">    return animatedImage;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行动图的解压操作，就直接返回该图片，动图不支持解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">    // GIF do not decompress</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>获取动图每一帧的显示时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (float)sd_frameDurationAtIndex:(NSUInteger)index source:(CGImageSourceRef)source &#123;</span><br><span class="line">    //临时变量每一帧的显示时间，默认为0.1f</span><br><span class="line">    float frameDuration = 0.1f;</span><br><span class="line">    </span><br><span class="line">    // 获取图片源中指定位置的图片属性</span><br><span class="line">    CFDictionaryRef cfFrameProperties = CGImageSourceCopyPropertiesAtIndex(source, index, nil);</span><br><span class="line">    //如果获取失败，就返回默认每一帧的显示时间</span><br><span class="line">    if (!cfFrameProperties) &#123;</span><br><span class="line">        return frameDuration;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    获取图片属性字典</span><br><span class="line">    NSDictionary *frameProperties = (__bridge NSDictionary *)cfFrameProperties;</span><br><span class="line">    //从图片属性中获取gif属性字典</span><br><span class="line">    NSDictionary *gifProperties = frameProperties[(NSString *)kCGImagePropertyGIFDictionary];</span><br><span class="line">    </span><br><span class="line">    //从git属性中获取当前帧的显示时间</span><br><span class="line">    NSNumber *delayTimeUnclampedProp = gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime];</span><br><span class="line">    </span><br><span class="line">    //如果当前帧的显示时间不为nil，赋值给frameDuration</span><br><span class="line">    if (delayTimeUnclampedProp != nil) &#123;</span><br><span class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果通过key：kCGImagePropertyGIFUnclampedDelayTime 从gifProperties字典中获取不到当前帧的显示时间，则通过另一个key：kCGImagePropertyGIFDelayTime获取</span><br><span class="line">        NSNumber *delayTimeProp = gifProperties[(NSString *)kCGImagePropertyGIFDelayTime];</span><br><span class="line">        </span><br><span class="line">        //如果不为空，赋值给赋值给frameDuration</span><br><span class="line">        if (delayTimeProp != nil) &#123;</span><br><span class="line">            frameDuration = [delayTimeProp floatValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //许多烦人的广告指定0持续时间，以使图像尽快闪现。 我们遵循Firefox的行为，并为指定持续时间&lt;= 10 ms的任何帧使用100 ms的持续时间。</span><br><span class="line">    </span><br><span class="line">    如果当前帧显示的时间实现小于11ms，就重新设置为100ms</span><br><span class="line">    if (frameDuration &lt; 0.011f) &#123;</span><br><span class="line">        frameDuration = 0.100f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //释放cfFrameProperties</span><br><span class="line">    CFRelease(cfFrameProperties);</span><br><span class="line">    </span><br><span class="line">    //返回当前帧显示时间</span><br><span class="line">    return frameDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt; 和 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt; ）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt; ：内置编码器,该类遵守了 &lt;code&gt;SDWebImageCoder&lt;/code&gt;协议，但并没有遵守 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt;协议，说明该类仅针对git图片的编解码，并不支持git图片的逐行解码功能。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
</feed>
