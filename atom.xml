<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>所念皆星辰</title>
  
  <subtitle>踏实、低调、前行。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qinguohua.fun/"/>
  <updated>2021-10-16T14:46:27.587Z</updated>
  <id>https://qinguohua.fun/</id>
  
  <author>
    <name>GUOHUA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 代码规范</title>
    <link href="https://qinguohua.fun/2021/01/30/2021-01-30-iOS-Code-Standards/"/>
    <id>https://qinguohua.fun/2021/01/30/2021-01-30-iOS-Code-Standards/</id>
    <published>2021-01-30T11:39:50.000Z</published>
    <updated>2021-10-16T14:46:27.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>命名应该尽可能的清晰和简洁，避免使用单词的简写，避免有歧义的命名</p><ul><li>命名遵循<a href="https://baike.baidu.com/item/骆驼命名法?fr=aladdin" target="_blank" rel="noopener">驼峰命名法</a></li><li>必须由数字、字母、下滑线组成，不能数字开头。</li><li>见名知意（非常重要，严禁出现无意义的命名，如<strong>aa，cc，data1，data2..</strong>）</li><li>变量名不能重名</li><li>变量名不能和系统关键字重名（如int id 等）</li></ul><p><strong>代码示范：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">insertObject:atIndex:</span><br><span class="line">setBackgroundColor:</span><br><span class="line"></span><br><span class="line">//不推荐</span><br><span class="line">// 不清晰，insert的对象类型和at的位置属性没有说明</span><br><span class="line">insert:at:</span><br><span class="line">// 不清晰，不要使用简写</span><br><span class="line">setBkgdColor:</span><br><span class="line">// 有歧义，是返回sendPort还是send一个Port？</span><br><span class="line">sendPort</span><br></pre></td></tr></table></figure><p>但在 Objective-C 编码过程中有部分单词简写非常常用，以至于成为了一种规范，这些简写可以在代码中直接使用，下面部分列举：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alloc   == Allocate         max    == Maximum</span><br><span class="line">alt     == Alternate        min    == Minimum</span><br><span class="line">app     == Application      msg    == Message</span><br><span class="line">calc    == Calculate        nib    == Interface Builder archive</span><br><span class="line">dealloc == Deallocate       pboard == Pasteboard</span><br><span class="line">func    == Function         rect   == Rectangle</span><br><span class="line">horiz   == Horizontal       Rep    == Representation (used in class name such as NSBitmapImageRep).</span><br><span class="line">info    == Information      temp   == Temporary</span><br><span class="line">init    == Initialize       vert   == Vertical</span><br><span class="line">int     == Integer</span><br></pre></td></tr></table></figure><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>整个工程的命名风格要保持一致性，最好和苹果SDK的代码保持统一。不同类中完成相似功能的方法应该叫一样的名字，比如我们总是用<code>count</code>来返回集合的个数，不能在A类中使用<code>count</code>而在B类中使用<code>getNumber</code> </p><h4 id="工程名"><a href="#工程名" class="headerlink" title="工程名"></a>工程名</h4><p><strong>工程名的命名必须有</strong>强烈的导向性<strong>，让人看到工程名的第一眼就明白该工程对应哪个项目。如</strong>KKLOnLine<strong>。<br>工程名字不能出现中文，不允许有空格。<br>工程名字采用大驼峰式命名法。</strong></p><h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><p><strong>类名的命名遵循</strong>大驼峰式命名法<strong>，应该包含一个<em>名词</em>来表示它代表的对象类型，类名中可以添加</strong>工程的前缀**，防止多个子工程出现类名重复的情况。（如，学习工程中的课程列表STCourseListTableViewController）</p><h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p><strong>方法名的命名规范遵循</strong>小驼峰式命名法**，如果是私有的方法，在方法面前可以加p_，每个方法名之前需要有详细的注释，标明方法的作用。</p><ul><li>可以用一些通用的大写字母缩写打头方法，比如<code>PDF</code>，<code>TIFF</code>等。</li><li>可以用带下划线的前缀来命名私有方法或者类别中的方法。</li><li>若方法表示让对象执行一个动作，使用动词打头来命名（不要使用 <code>do</code>，<code>does</code> 这种多余的关键字）。</li><li>若方法是为了获取对象的一个属性值，直接用属性名称来命名这个方法（不要添加 <code>get</code> 或者其他的动词前缀）。</li></ul><h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><p><strong>变量名的命名规范遵循</strong>小驼峰式命名法<strong>(参数名的命名规则和变量名一直)。</strong></p><h4 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h4><p><strong>常量名的命名模式 k+大驼峰式命名法形式。（如，</strong>kCourseCount**）</p><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p>源码的头文件名应该清晰地暗示它的功能和包含的内容。（如：<strong>NSBundleAdditions.h</strong>）</p><h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p>委托的第一个参数是触发它的对象，第一个关键词是触发对象的类名，除非委托方法只有一个名为<code>sender</code>的参数。根据委托方法触发的时机和目的，使用 <code>should</code>， <code>will</code>， <code>did</code> 等关键词</p><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p><code>[触发通知的类名] + [Did | Will] + [动作] + Notification</code></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p> 函数的的命名遵循<strong>大驼峰式命名法</strong>，一般带有缩写前缀，表示方法所在的框架。</p><ul><li>如果函数通过指针参数来返回值，需要在函数名中使用 <code>Get</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *NSGetSizeAndAlignment(const char *typePtr, unsigned int *sizep, unsigned int *alignp)</span><br></pre></td></tr></table></figure><ul><li>函数的返回类型是BOOL时的命名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL NSDecimalIsNotANumber(const NSDecimal *decimal)</span><br></pre></td></tr></table></figure><ul><li>如果函数返回其参数的某个属性，省略动词：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int NSEventMaskFromType(NSEventType type)</span><br><span class="line">float NSHeight(NSRect aRect)</span><br></pre></td></tr></table></figure><h2 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h2><p> 一份规范的代码必定不能缺少详尽的注释。代码块的注释应该更注重说明<strong>为什么这么做</strong>，而不是<strong>做了什么</strong></p><p>注释的作用：</p><ol><li>方便工作交接和引导新同事熟悉代码</li><li>方便自己之后回忆代码逻辑</li><li>方便生成文档</li></ol><h4 id="属性的注释"><a href="#属性的注释" class="headerlink" title="属性的注释"></a>属性的注释</h4><p>对于属性我们使用 三杠 <strong>///</strong> 进行单行注释 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">///姓名</span><br><span class="line">@property (nonatomic，copy)NSString *name;</span><br></pre></td></tr></table></figure><h4 id="特殊行和代码块的注释"><a href="#特殊行和代码块的注释" class="headerlink" title="特殊行和代码块的注释"></a>特殊行和代码块的注释</h4><p>对于特殊行和代码块的注释使用 双杠 <strong>//</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//设置音量</span><br><span class="line">player.volum = 0.5;</span><br><span class="line">if(liveStatus == kLiveStatusEnded)&#123;//直播结束的操作</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">[[[ResourceTask task] post] subscribeNext:^(ResourceTask *task) &#123;//请求之后的处理</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="方法的注释"><a href="#方法的注释" class="headerlink" title="方法的注释"></a>方法的注释</h4><p>对于方法我们使用<strong>多行注释</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">@abstract 初始化方法 </span><br><span class="line">@param name 姓名 </span><br><span class="line">@param sex  性别 </span><br><span class="line">@result 返回一个初始化实例 </span><br><span class="line">*/</span><br><span class="line">- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex;</span><br></pre></td></tr></table></figure><h4 id="类的注释"><a href="#类的注释" class="headerlink" title="类的注释"></a>类的注释</h4><p>对于类的注释我们使用多行注释  <strong>类的声明部分要对当前类的功能作用进行详细的注释，标明类的作用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  TopView.h</span><br><span class="line">//  KKLOnLine</span><br><span class="line">//</span><br><span class="line">//  Created by zahir on 2017/7/31.</span><br><span class="line">//  Copyright © 2017年 mistong. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">/**</span><br><span class="line"> @class           TopView</span><br><span class="line"> @abstract        TopView 的简单介绍</span><br><span class="line"> @discussion      TopView 的功能介绍 和 一些特殊的使用注意事项</span><br><span class="line"> */</span><br><span class="line">@interface TopView : UIView</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="特定注释"><a href="#特定注释" class="headerlink" title="特定注释"></a>特定注释</h4><ul><li><p><code>///TODO:</code> 有功能代码待编写，需要注明，以便自己和代码审查者全局搜索。</p></li><li><p><code>///FIXME:(禅道bug编号)</code> 用于追溯bug，如果有禅道记录，修复完成后带入禅道的bug号，没有的话，也需要写明bug描述</p></li><li><p><code>///!!!:</code>  代码需要注意</p></li><li><code>///???:</code> 代码有疑问</li><li><code>///MARK:</code> 标记，与#pragma mark 效果相同</li></ul><h4 id="文件的注释"><a href="#文件的注释" class="headerlink" title="文件的注释"></a>文件的注释</h4><p>每一个文件都<strong>必须</strong>写文件注释，文件注释通常包含</p><ul><li>文件所在模块</li><li>作者信息</li><li>历史版本信息</li><li>版权信息</li><li>文件包含的内容，作用</li></ul><p><em>注：文件注释的格式通常不作要求，能清晰易读就可以了，但在整个工程中风格要统一。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*******************************************************************************</span><br><span class="line">    Copyright (C), 2011-2013, Andrew Min Chang</span><br><span class="line"></span><br><span class="line">    File name:  AMCCommonLib.h</span><br><span class="line">    Author:     Andrew Chang (Zhang Min) </span><br><span class="line">    E-mail:     LaplaceZhang@126.com</span><br><span class="line">    </span><br><span class="line">    Description:    </span><br><span class="line">            This file provide some covenient tool in calling library tools. One can easily include </span><br><span class="line">        library headers he wants by declaring the corresponding macros. </span><br><span class="line">            I hope this file is not only a header, but also a useful Linux library note.</span><br><span class="line">            </span><br><span class="line">    History:</span><br><span class="line">        2012-??-??: On about come date around middle of Year 2012, file created as &quot;commonLib.h&quot;</span><br><span class="line">        2012-08-</span><br><span class="line">    Copyright information: 20: Add shared memory library; add message queue.</span><br><span class="line">    2012-08-21: Add socket library (local)</span><br><span class="line">    2012-10-10: Change file name as &quot;AMCCommonLib.h&quot;</span><br><span class="line">    2012-12-04: Add UDP support in AMC socket library</span><br><span class="line">    2013-01-22: Add CFG_LIB_TIMER.</span><br><span class="line">    2013-01-22: Remove CFG_LIB_DATA_TYPE because there is already AMCDataTypes.h</span><br><span class="line"></span><br><span class="line">            This file was intended to be under GPL protocol. However, I may use this library</span><br><span class="line">        in my work as I am an employee. And my company may require me to keep it secret. </span><br><span class="line">        Therefore, this file is neither open source nor under GPL control. </span><br><span class="line">        </span><br><span class="line">********************************************************************************/</span><br></pre></td></tr></table></figure><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><ol><li><p>不要在工程里使用 Tab，使用空格来进行缩进。在 <code>Xcode &gt; Preferences &gt; Text Editing</code> 将 Tab 和自动缩进都设置为<strong>4</strong>个空格。</p></li><li><p><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>=</code> 的前后都应该保留一个空格。</p></li><li>逗号<code>,</code>的前面不应该留有空格，<code>,</code>后面应该保留一个空格</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">NSArray *data = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;];</span><br><span class="line">NSInteger x = 4 * (5 + 3);</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">NSArray* data=@[ @&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot; ];</span><br><span class="line">NSInteger x=4*(5+3);</span><br></pre></td></tr></table></figure><h4 id="每一行的最大长度"><a href="#每一行的最大长度" class="headerlink" title="每一行的最大长度"></a>每一行的最大长度</h4><p>在 <code>Xcode &gt; Preferences &gt; Text Editing &gt; Page guide at column:</code> 中将最大行长设置为<strong>80</strong>，过长的一行代码将会导致可读性问题。</p><h4 id="括号的换行"><a href="#括号的换行" class="headerlink" title="括号的换行"></a>括号的换行</h4><p><strong>方法</strong>及其他大括号(<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code>等)，总是在同一行语句打开但在新行中关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">- (void)foobar &#123;</span><br><span class="line">    if (user.age &gt; 18) &#123;</span><br><span class="line">        // Do something</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">- (void)foobar </span><br><span class="line">&#123;</span><br><span class="line">    if (user.age &gt; 18) </span><br><span class="line">    &#123;</span><br><span class="line">      // Do something  </span><br><span class="line">    &#125; </span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">      // Do something  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数的书写和调用"><a href="#函数的书写和调用" class="headerlink" title="函数的书写和调用"></a>函数的书写和调用</h4><ol><li><p>在 <code>-</code> 和 <code>(void)</code> 之间应该有一个空格，第一个大括号 <code>{</code> 的位置在函数所在行的末尾，同样应该有一个空格。</p></li><li><p>函数有特别多的参数或者名称很长，应该将其按照<code>:</code>来对齐分行显示。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithModel:(IPCModle)model</span><br><span class="line">       ConnectType:(IPCConnectType)connectType</span><br><span class="line">        Resolution:(IPCResolution)resolution</span><br><span class="line">          AuthName:(NSString *)authName</span><br><span class="line">          Password:(NSString *)password</span><br><span class="line">               MAC:(NSString *)mac</span><br><span class="line">              AzIp:(NSString *)az_ip</span><br><span class="line">             AzDns:(NSString *)az_dns</span><br><span class="line">             Token:(NSString *)token</span><br><span class="line">             Email:(NSString *)email</span><br><span class="line">          Delegate:(id&lt;IPCConnectHandlerDelegate&gt;)delegate;</span><br></pre></td></tr></table></figure><h4 id="方法内部避免空白行"><a href="#方法内部避免空白行" class="headerlink" title="方法内部避免空白行"></a>方法内部避免空白行</h4><p>在方法内部尽量避免空白行，如果为了区分功能，请用单行注释进行分割(注释可以增加斜杠数量<code>////</code>表明功能隔离)。</p><h4 id="闭包建议避免以冒号对齐的方式调用"><a href="#闭包建议避免以冒号对齐的方式调用" class="headerlink" title="闭包建议避免以冒号对齐的方式调用"></a>闭包建议避免以冒号对齐的方式调用</h4><ol><li>较短的 block 可以写在一行内。</li><li>block 内的代码采用<strong>4个空格</strong>的缩进</li><li><code>^</code> 和 <code>(</code> 之间，<code>^</code> 和 <code>{</code> 之间都没有空格，参数列表的右括号 <code>)</code> 和 <code>{</code> 之间有一个空格</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 较短的block写在一行内</span><br><span class="line">[operation setCompletionBlock:^&#123; [self onOperationDone]; &#125;];</span><br><span class="line"></span><br><span class="line">// 推荐</span><br><span class="line">  [UIView animateWithDuration:1.0 animations:^&#123;</span><br><span class="line">    // something</span><br><span class="line">  &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">    // something</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  //不推荐</span><br><span class="line">  [UIView animateWithDuration:1.0</span><br><span class="line">              animations:^&#123;</span><br><span class="line">                  // something</span><br><span class="line">               &#125;</span><br><span class="line">              completion:^(BOOL finished) &#123;</span><br><span class="line">                   // something</span><br><span class="line">              &#125;];</span><br></pre></td></tr></table></figure><h3 id="数据结构的语法糖"><a href="#数据结构的语法糖" class="headerlink" title="数据结构的语法糖"></a>数据结构的语法糖</h3><p>应该使用可读性更好的语法糖来构造 <code>NSArray</code>，<code>NSDictionary</code> 等数据结构，避免使用冗长的 <code>alloc</code>,<code>init</code> 方法。</p><p><strong>一行构造，应该在括号两端保留一个空格，使得被构造的元素于与构造语法区分开</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 正确，在语法糖的&quot;[]&quot;或者&quot;&#123;&#125;&quot;两端留有空格</span><br><span class="line">NSArray *array = @[ [foo description], @&quot;Another String&quot;, [bar description] ];</span><br><span class="line">NSDictionary *dic = @&#123; NSForegroundColorAttributeName : [NSColor redColor] &#125;;</span><br><span class="line"></span><br><span class="line">// 不正确，不留有空格降低了可读性</span><br><span class="line">NSArray* array = @[[foo description], [bar description]];</span><br><span class="line">NSDictionary* dic = @&#123;NSForegroundColorAttributeName: [NSColor redColor]&#125;;</span><br></pre></td></tr></table></figure><p><strong>多行构造，构造元素应保留两个空格来进行缩进，右括号 <code>]</code> 或者 <code>}</code>写在新的一行，并且与调用语法糖那行代码的第一个非空字符对齐</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[</span><br><span class="line">  @&quot;This&quot;,</span><br><span class="line">  @&quot;is&quot;,</span><br><span class="line">  @&quot;an&quot;,</span><br><span class="line">  @&quot;array&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">NSDictionary *dictionary = @&#123;</span><br><span class="line">  NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12],</span><br><span class="line">  NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>构造字典时，字典的Key和Value与中间的冒号<code>:</code>都要留有一个空格，多行书写时，也可以将Value对齐</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 推荐，冒号&apos;:&apos;前后留有一个空格</span><br><span class="line">NSDictionary *option1 = @&#123;</span><br><span class="line">  NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12],</span><br><span class="line">  NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 推荐，按照Value来对齐</span><br><span class="line">NSDictionary *option2 = @&#123;</span><br><span class="line">  NSFontAttributeName :            [NSFont fontWithName:@&quot;Arial&quot; size:12],</span><br><span class="line">  NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不推荐，冒号前应该有一个空格</span><br><span class="line">NSDictionary *wrong = @&#123;</span><br><span class="line">  AKey:       @&quot;b&quot;,</span><br><span class="line">  BLongerKey: @&quot;c&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不推荐，每一个元素要么单独成为一行，要么全部写在一行内</span><br><span class="line">NSDictionary *alsoWrong= @&#123; AKey : @&quot;a&quot;,</span><br><span class="line">                            BLongerKey : @&quot;b&quot; &#125;;</span><br><span class="line"></span><br><span class="line">// 不推荐，在冒号前只能有一个空格，冒号后才可以考虑按照Value对齐</span><br><span class="line">NSDictionary *stillWrong = @&#123;</span><br><span class="line">  AKey       : @&quot;b&quot;,</span><br><span class="line">  BLongerKey : @&quot;c&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>TODO：待讨论</strong></p><ul><li><p>在方法之间应该有且只有一行。这样有利于在视觉上更清晰。</p></li><li><p>函数有特别多的参数或者名称很长，应该将其按照<code>:</code>来对齐分行显示。</p></li><li><p>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请<strong>不要</strong>这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。(?????)</p></li><li><p>闭包建议避免以冒号对齐的方式调用。</p></li></ul><h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><p>编码规范简单来说就是为了保证写出来的代码具备三个原则:可复用， 易维护， 可扩展. 这其实也是面向对象的基本原则.</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格</p></li><li><p>一个方法，应该少于50行</p></li><li><p>方法分布区</p></li><li><p>life-Cycle、Delegate、Event-Response、Private-Method、Setters-Getters 顺序进行分区域书写 不是delegate方法的，不是event response方法的，不是life cycle方法的，就是private method了。</p></li><li><p>对于整个单独的功能模块是可以考虑添加category。</p></li><li><p>同一区域中的方法按照经常：容易忘记的、常使用的程度顺序进行排列</p></li><li><p>当一个方法参数过多，其实这样就预示着是否我们可以聚合一个model类，一方面代码整洁；另一方面参数过多逻辑不简容易导致错误</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">- (void)registerUser(User*)user;</span><br><span class="line">//不推荐</span><br><span class="line">-(void)registerUserName:(NSString*)userName password:(NSString*)password email:(NSString*)email;</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>所有的属性特性应该显示的列出来，有助于新手理解代码。</p></li><li><p><code>*</code>应该跟着属性名字，而不是跟在类型后面。</p></li><li><p>集合作为属性时，标注集合内元素类型</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">@property (nonatomic，strong) NSArray&lt;Teacher *&gt; *teacherList;</span><br><span class="line">//不推荐</span><br><span class="line">@property (nonatomic，strong) NSArray *teacherList;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在<code>for()</code>循环。</p></li><li><p>变量进行赋值、比较时避免产生硬编码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">#define kPeopleNumber 2</span><br><span class="line">if(peopleNumber == kPeopleNumber)&#123;</span><br><span class="line">&#125; </span><br><span class="line">//或者 </span><br><span class="line">int studentNumber = kPeopleNumber;</span><br><span class="line">int teacherNumber = kPeopleNumber;</span><br><span class="line">//不推荐</span><br><span class="line">if(peopleNumber == 2)&#123;</span><br><span class="line">&#125;</span><br><span class="line">//或者 </span><br><span class="line">int studentNumber = 2;</span><br><span class="line">int teacherNumber = 2;</span><br></pre></td></tr></table></figure><ul><li>星号表示变量是指针。例如， <code>NSString *text</code> 既不是 <code>NSString* text</code> 也不是 <code>NSString * text</code>。</li><li>尽可能用私有属性代替实例变量的使用。如果有实例变量，要用下划线开头命名<code>NSString *_text</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">@interface GrowthStationVC ()</span><br><span class="line">@property (nonatomic， strong) NSString *fmTitle; </span><br><span class="line">@property (nonatomic， strong) UIView *containerView;</span><br><span class="line">@end</span><br><span class="line">//不推荐</span><br><span class="line">@interface GrowthStationVC () &#123;</span><br><span class="line">    NSString *_fmTitle;</span><br><span class="line">    UIView *containerView;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>当使用<code>enum</code>时，推荐使用<code>NS_ENUM</code>方式，因为它有更强的类型检查和代码补全。现在SDK有一个宏<code>NS_ENUM()</code>来帮助和鼓励你使用固定的基本类型。</p><p><strong>例如：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">typedef NS_ENUM(NSInteger， RWTLeftMenuTopItemType) &#123;</span><br><span class="line">  RWTLeftMenuTopItemMain = 1，</span><br><span class="line">  RWTLeftMenuTopItemShows，</span><br><span class="line">  RWTLeftMenuTopItemSchedule</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//不推荐</span><br><span class="line">enum GlobalConstants &#123;</span><br><span class="line">  kMaxPinSize = 5，</span><br><span class="line">  kMaxPinCount = 500，</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>Objective-C使用<code>YES</code>和<code>NO</code>。因为<code>true</code>和<code>false</code>应该只在C或C++代码使用。不要拿某样东西直接与<code>YES</code>比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">if (someObject) &#123;&#125;</span><br><span class="line">if (![anotherObject boolValue]) &#123;&#125;</span><br><span class="line"></span><br><span class="line">//不推荐</span><br><span class="line">if (someObject == nil) &#123;&#125;</span><br><span class="line">if ([anotherObject boolValue] == NO) &#123;&#125;</span><br><span class="line">if (isAwesome == YES) &#123;&#125; // Never do this.</span><br><span class="line">if (isAwesome == true) &#123;&#125; // Never do this.</span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul><li><p>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，</p><p>even more dangerous defect</p><p>可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">if (!error) &#123;</span><br><span class="line">  return success;</span><br><span class="line">&#125;</span><br><span class="line">//不推荐</span><br><span class="line">if (!error)</span><br><span class="line">  return success;</span><br><span class="line">//或:</span><br><span class="line">if (!error) return success;</span><br></pre></td></tr></table></figure><ul><li><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套<code>if</code>语句，多个返回语句也是OK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">- (void)someMethod &#123;</span><br><span class="line">if (![someOther boolValue]) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">  //Do something important</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不推荐</span><br><span class="line">- (void)someMethod &#123;</span><br><span class="line">  if ([someOther boolValue]) &#123;</span><br><span class="line">    //Do something important</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h3><p>当需要提高代码的清晰性和简洁性时，三元操作符<code>?:</code>才会使用。单个条件求值常常需要它。多个条件求值时，如果使用<code>if</code>语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p><p>Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//推荐</span><br><span class="line">NSInteger value = 5;</span><br><span class="line">result = (value != 0) ? x : y;</span><br><span class="line"></span><br><span class="line">BOOL isHorizontal = YES;</span><br><span class="line">result = isHorizontal ? x : y;</span><br><span class="line"></span><br><span class="line">//不推荐</span><br><span class="line">result = a &gt; b ? x = c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure><h3 id="nil检测"><a href="#nil检测" class="headerlink" title="nil检测"></a>nil检测</h3><p>在 Objective-C 中向 nil 对象发送命令是不会抛出异常或者导致崩溃的，只是完全的“什么都不干”，所以，只在程序中使用 nil 来做逻辑上的检查。</p><p>不要使用诸如 <code>nil == Object</code> 或者 <code>Object == nil</code> 的形式来判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 正确，直接判断</span><br><span class="line">if (!objc) &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误，不要使用nil == Object的形式</span><br><span class="line">if (nil == objc) &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用NSNumber的语法糖"><a href="#使用NSNumber的语法糖" class="headerlink" title="使用NSNumber的语法糖"></a>使用NSNumber的语法糖</h3><p>使用带有<code>@</code>符号的语法糖来生成 NSNumber 对象能使代码更简洁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *phoneNumber = @42;</span><br><span class="line">NSNumber *pi_2 = @(M_PI / 2);</span><br></pre></td></tr></table></figure><h3 id="NSString-在赋值时被复制"><a href="#NSString-在赋值时被复制" class="headerlink" title="NSString 在赋值时被复制"></a>NSString 在赋值时被复制</h3><p>以复制（copy）的方式防止在不知情的情况下 String 的值被其它对象修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFood:(NSString *)food &#123;</span><br><span class="line">  _food = [food copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BOOL的使用"><a href="#BOOL的使用" class="headerlink" title="BOOL的使用"></a>BOOL的使用</h3><ol><li><strong>不要</strong>将 BOOL 类型变量直接和 <code>YES</code>。</li><li>BOOL类型可以和 <code>_Bool</code>,<code>bool</code> 相互转化，但是<strong>不能</strong>和 <code>Boolean</code> 转化。</li><li>不要将其它类型的值作为 BOOL 来返回，这种情况下，BOOL 变量只会取值的最后一个字节来赋值，这样很可能会取到0（NO）。但是，一些逻辑操作符比如 <code>&amp;&amp;</code>,<code>||</code>,<code>!</code>的返回是可以直接赋给 BOOL。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 错误，无法确定|great|的值是否是YES(1)，不要将BOOL值直接与YES比较</span><br><span class="line">BOOL great = [foo isGreat];</span><br><span class="line">if (great == YES)</span><br><span class="line">  // ...be great!</span><br><span class="line"></span><br><span class="line">//正确</span><br><span class="line">BOOL great = [foo isGreat];</span><br><span class="line">if (great)</span><br><span class="line">  // ...be great!</span><br><span class="line"></span><br><span class="line">// 错误，不要将其它类型转化为BOOL返回</span><br><span class="line">- (BOOL)isBold &#123;</span><br><span class="line">  return [self fontTraits] &amp; NSFontBoldTrait;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isValid &#123;</span><br><span class="line">  return [self stringValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">- (BOOL)isBold &#123;</span><br><span class="line">  return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确，逻辑操作符可以直接转化为BOOL</span><br><span class="line">- (BOOL)isValid &#123;</span><br><span class="line">  return [self stringValue] != nil;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isEnabled &#123;</span><br><span class="line">  return [self isValid] &amp;&amp; [self isBold];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不要使用-new-方法"><a href="#不要使用-new-方法" class="headerlink" title="不要使用 new 方法"></a>不要使用 new 方法</h3><p>尽管很多时候能用<code>new</code>代替<code>alloc init</code>方法，但这可能会导致调试内存时出现不可预料的问题。Cocoa的规范就是使用<code>alloc init</code>方法，使用<code>new</code>会让一些读者困惑。</p><h3 id="避免循环引用"><a href="#避免循环引用" class="headerlink" title="避免循环引用"></a>避免循环引用</h3><p>为了保持代码统一性，避免开发中疏忽导致强引用。统一强调在代码块中使用 <code>@weakify(self) ,@strongify(self)</code>来做处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">void(^messageBlock)(NSString *) = ^(NSString *message) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    self.message = message;</span><br><span class="line">    NSLog(@&quot;%@&quot;,message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; title=&quot;命名规范&quot;&gt;&lt;/a&gt;命名规范&lt;/h2&gt;&lt;h4 id=&quot;基本原则&quot;&gt;&lt;a href=&quot;#基本原则&quot; class=&quot;headerlink&quot; title=&quot;基本原则&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://qinguohua.fun/categories/Objective-C/"/>
    
    
      <category term="objc" scheme="https://qinguohua.fun/tags/objc/"/>
    
      <category term="code standards" scheme="https://qinguohua.fun/tags/code-standards/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历（Binary Tree）</title>
    <link href="https://qinguohua.fun/2021/01/30/2019-01-30-Binary-Tree/"/>
    <id>https://qinguohua.fun/2021/01/30/2019-01-30-Binary-Tree/</id>
    <published>2021-01-30T11:14:01.000Z</published>
    <updated>2021-10-16T14:46:27.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>二叉树（Binary Tree）：计算机中数据结构的一种，是树形结构的一个重要类型。结构类型是<strong>每个节点最多有两个子树的树结构</strong>。特点是<strong>每个节点最多只能有了两棵子树，且有左右之分</strong>。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>二叉树</strong>是指树中节点的度不大于2的有序树，是n(n&gt;=0)个节点的有限集合，该集合或者为空集（称为空二叉树），或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树 。</p><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li>叶子节点：也称为终端节点，没有子树的节点或者度为零的节点。</li><li>节点的关系：节点子树的根节点为该节点的<strong>孩子节点</strong>。相应该节点称为孩子节点的<strong>双亲节点</strong>。</li><li>节点的度：一个节点拥有子树的数目称为节点的度</li><li>节点的层级：从根节点开始，假设根节点为第1层，根节点的子节点为第2层，依此类推，如果某一个节点位于第L层，则其子节点位于第L+1层</li><li>数的深度：也称为树的高度，树中所有节点的层次最大值称为树的深度</li></ul><p><img src="http://blog.guohuaden.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.png" alt="树的层级"></p><p><img src="http://blog.guohuaden.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%A6.png" alt="树的度"></p><h2 id="基本形态"><a href="#基本形态" class="headerlink" title="基本形态"></a>基本形态</h2><ul><li>空二叉树</li><li>只有一个跟节点的二叉树</li><li>只有左子树</li><li>只有右子树</li><li>满二叉树</li></ul><p><img src="http://blog.guohuaden.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE.png" alt="二叉树基本类型图"></p><h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><ul><li>满二叉树 ：如果一棵二叉树只有度为0的节点和度为2的节点，并且度为0的节点在同一层上，则这棵二叉树为满二叉树。一棵深度为k且有个结点的二叉树称为满二叉树</li><li>完全二叉树 ：深度为k，有n个节点的二叉树当且仅当其每一个节点都与深度为k的满二叉树中编号从1到n的节点一一对应时，称为完全二叉树 </li></ul><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><h3 id="例图"><a href="#例图" class="headerlink" title="例图"></a>例图</h3><p><img src="http://blog.guohuaden.com/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树示例图"></p><ul><li>先序遍历：根节点 –&gt; 左子树 –&gt; 右子树  ==&gt;  A 、B 、D 、E 、C 、F 、G </li><li>中序遍历 ：左子树 –&gt; 根节点 –&gt; 右子树  ==&gt; D、B、E、A 、F 、C、G</li><li>后序遍历：左子树  –&gt; 右子树 –&gt; 根节点  ==&gt;  D、E、B、F、G、C、A</li><li>层级遍历：也叫层序遍历，按层遍历          ==&gt;  A、B、C、D、E、F、G</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">res,root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(root.val);</span><br><span class="line">    recursive(result,root.left);</span><br><span class="line">    recursive(result,root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">result,root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    recursive(result,root.left);</span><br><span class="line">    result.push(root.val);</span><br><span class="line">    recursive(result,root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">result,root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    recursive(result,root.left);</span><br><span class="line">    recursive(result,root.right);</span><br><span class="line">    result.push(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>非递归实现，其实就是迭代方法，引入栈来替代递归。<strong>由于栈的特性是后进先出，所以进栈的时机和递归是相反的</strong> 。所以利用递归的思路用栈实现时，需要先放右节点进栈，再放左节点进栈。这样可以保证每次出栈取到的节点都是左节点优先，达到和递归顺序一样的效果。</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>先序遍历的顺序：根–左–右</p><p>所以每次访问</p><ul><li>常规解法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span> || node != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            result.push(node.val);</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = stack.pop();<span class="comment">//出栈的同时访问右节点，保证访问顺序是先左后右</span></span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>技巧性解法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        <span class="comment">// 由于栈先进后出的特性，先 push right，再 push left</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历是以 左–根–右 遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span> || node != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = stack.pop();<span class="comment">//出栈的同时访问右节点，保证访问顺序是先左后右</span></span><br><span class="line">            result.push(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>思路：</p><p>对于任意节点P而言</p><ol><li><p>P如果是叶子节点，直接输出</p></li><li><p>P如果有孩子，且孩子没有被访问过，则按照右孩子，左孩子的顺序依次入栈</p></li><li><p>P如果有孩子，而且孩子都已经访问过，则访问P节点</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> node;</span><br><span class="line">    <span class="keyword">let</span> preNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        node = stack[stack.length<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//判断当前节点时，左孩子和右孩子都在根结点前已经被访问</span></span><br><span class="line">        <span class="keyword">let</span> visited = preNode != <span class="literal">null</span> &amp;&amp; (preNode == node.left || preNode == node.right);</span><br><span class="line">        <span class="keyword">if</span>((node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) || visited)&#123;</span><br><span class="line">            result.push(node.val);</span><br><span class="line">            preNode = node;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span> || stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            result.push(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.reverse();  <span class="comment">//这里的反转，相当于从栈中取出来节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(result.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  node = result.pop();</span><br><span class="line">    <span class="comment">//打印每个节点的val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>技巧性解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        result.push(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.reverse();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注：后序遍历：左 -- 右 -- 根 </span></span><br><span class="line"><span class="comment">//题中遍历是以 根--右--左出栈的，顺序和后序遍历顺序相反，所以对结果反转得到的就是后序遍历结果</span></span><br></pre></td></tr></table></figure><p><strong>递归和迭代的时间复杂度和空间复杂度都是O(n)</strong> ,</p><p>区别：在于递归的空间是系统栈维护的</p><p>时间复杂度的推导公式：<strong>Master公式</strong>,Master公式是常用来解决递归问题时间复杂度的通用公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">公式 T(N) = a*T(N / b) + O (N^d)</span><br><span class="line">代入公式得到：T(N)=2T(N/2)+O(1):，其中 a = 2, b = 2, d = 0;</span><br><span class="line">得到 log(2,2) = 1 &gt; 0，代入公式 O(N ^ log(b,a)) = O(N^ log(2,2)) = O(N)</span><br></pre></td></tr></table></figure><h3 id="层级遍历（BFS）"><a href="#层级遍历（BFS）" class="headerlink" title="层级遍历（BFS）"></a>层级遍历（BFS）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层级遍历</span></span><br><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = [];<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">let</span> queue = [];<span class="comment">//队列</span></span><br><span class="line">    queue.push(root);<span class="comment">//进栈</span></span><br><span class="line">    <span class="keyword">let</span> node;</span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = queue.length;<span class="comment">//每个层级下的节点</span></span><br><span class="line">        <span class="keyword">let</span> list = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            node = queue.shift();<span class="comment">//出栈</span></span><br><span class="line">            list.push(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(list);<span class="comment">//这个如果要求自底向上输出，可以每次添加到首位。result.unshift(list)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度：每个节点都需要进栈出栈，所以时间复杂度和空间复杂度都是O(n)</span></span><br></pre></td></tr></table></figure><h3 id="二叉树深度-（BFS-and-DFS）"><a href="#二叉树深度-（BFS-and-DFS）" class="headerlink" title="二叉树深度 （BFS and DFS）"></a>二叉树深度 （BFS and DFS）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;二叉树（Binary Tree）：计算机中数据结构的一种，是树形结构的一个重要类型。结构类型是&lt;strong&gt;每个节点最多有两个子树的树结构
      
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://qinguohua.fun/tags/algorithm/"/>
    
      <category term="二叉树遍历" scheme="https://qinguohua.fun/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    
      <category term="binary tree" scheme="https://qinguohua.fun/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>watchdog</title>
    <link href="https://qinguohua.fun/2020/07/07/2020-07-07-watchdog/"/>
    <id>https://qinguohua.fun/2020/07/07/2020-07-07-watchdog/</id>
    <published>2020-07-07T14:44:50.000Z</published>
    <updated>2021-10-16T14:46:27.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>为了防止一个应用程序占用过多的系统资源，苹果设计一个监督机构 <code>watchdog</code> ,音译：<strong>看门狗机制。</strong></p><p>用户希望应用程序快速启动，并对触摸和手势做出响应。操作系统使用一个监督机构来监控启动时间和应用程序的响应，如果超出了该场景下所规定的运行时间，该机制就会终止无响应的应用程序。</p><p><code>watchdog</code> 完整的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception Type:  EXC_CRASH (SIGKILL)</span><br><span class="line">Exception Codes: 0x0000000000000000, 0x0000000000000000</span><br><span class="line">Exception Note:  EXC_CORPSE_NOTIFY</span><br><span class="line">Termination Reason: Namespace SPRINGBOARD, Code 0x8badf00d</span><br><span class="line">Termination Description: SPRINGBOARD, &lt;RBSTerminateContext| domain:10 code:0x8BADF00D explanation:scene-update watchdog transgression: application&lt;com.kaike.online&gt;:745 exhausted real (wall clock) time allowance of 10.00 seconds | ProcessVisibility: Background | ProcessState: Running | WatchdogEvent: scene-update | WatchdogVisibility: Background | WatchdogCPUStatistics: ( | &quot;Elapsed total CPU time (seconds): 20.230 (user 20.230, system 0.000), 34% CPU&quot;, | &quot;Elapsed application CPU time (seconds): 0.001, 0% CPU&quot; | ) reportType:CrashLog maxTerminationResistance:Interactive&gt;</span><br><span class="line">Triggered by Thread:  0</span><br></pre></td></tr></table></figure><p>通俗讲：</p><p>为了避免应用陷入错误状态导致界面无响应，Apple 设计了 <code>watchdog</code> 机制。一旦超时，强制杀死进程。在不同的生命周期，触发 <code>watchdog</code> 机制的超时时间有所不同：</p><table><thead><tr><th style="text-align:left">生命周期</th><th style="text-align:left">超时时间</th></tr></thead><tbody><tr><td style="text-align:left">启动 Launch</td><td style="text-align:left">20s</td></tr><tr><td style="text-align:left">恢复 Resume</td><td style="text-align:left">10s</td></tr><tr><td style="text-align:left">悬挂 Suspend</td><td style="text-align:left">10s</td></tr><tr><td style="text-align:left">退出Quit</td><td style="text-align:left">6s</td></tr><tr><td style="text-align:left">后台 Background</td><td style="text-align:left">10min</td></tr></tbody></table><p><code>watchdog</code> 的终止使用崩溃报告的终止原因中的代码是 <code>0x8badf00d</code> （发音为“吃了不好的食物”）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception Type:  EXC_CRASH (SIGKILL)</span><br><span class="line">Exception Codes: 0x0000000000000000, 0x0000000000000000</span><br><span class="line">Exception Note:  EXC_CORPSE_NOTIFY</span><br><span class="line">Termination Reason: Namespace SPRINGBOARD, Code 0x8badf00d</span><br></pre></td></tr></table></figure><p><code>watchdog</code> 终止长时间阻塞主线程的应用程序。有很多方法可以延长阻塞主线程，例如：</p><ul><li>同步网络</li><li><p>处理大量数据</p></li><li><p>同步触发大型核心数据存储的轻量级迁移</p></li><li>使用Vision进行分析请求。</li></ul><h3 id="解读App响应式-watchdog-信息"><a href="#解读App响应式-watchdog-信息" class="headerlink" title="解读App响应式 watchdog 信息"></a>解读App响应式 <code>watchdog</code> 信息</h3><p>当应用程序启动或响应事件缓慢时，崩溃报告中的终止信息包含有关应用程序如何花费时间的重要信息。</p><h4 id="崩溃信息一"><a href="#崩溃信息一" class="headerlink" title="崩溃信息一"></a>崩溃信息一</h4><p>例如，卡顿时挂起App在崩溃报告中具有以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Termination Description: SPRINGBOARD, &lt;RBSTerminateContext| domain:10 code:0x8BADF00D explanation:scene-update watchdog transgression: application&lt;com.example.MyCoolApp&gt;:745 exhausted real (wall clock) time allowance of 10.00 seconds </span><br><span class="line">    | ProcessVisibility: Background </span><br><span class="line">    | ProcessState: Running </span><br><span class="line">    | WatchdogEvent: scene-update </span><br><span class="line">    | WatchdogVisibility: Background </span><br><span class="line">    | WatchdogCPUStatistics: ( </span><br><span class="line">    | &quot;Elapsed total CPU time (seconds): 20.230 (user 20.230, system 0.000), 34% CPU&quot;, </span><br><span class="line">    | &quot;Elapsed application CPU time (seconds): 0.001, 0% CPU&quot; </span><br><span class="line">    | )</span><br></pre></td></tr></table></figure><p>上述描述中可以看出：<code>WatchdogEvent</code> 是 <code>scene-update</code> ，说明应用程序是在<strong>场景更新</strong> 时终止的，原因是没有足够快地更新其UI，因为主线程太忙。</p><h4 id="崩溃信息二"><a href="#崩溃信息二" class="headerlink" title="崩溃信息二"></a>崩溃信息二</h4><p>在App启动后没有快速呈现UI，在崩溃报告中具有以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Termination Description: SPRINGBOARD, </span><br><span class="line">    scene-create watchdog transgression: application&lt;com.example.MyCoolApp&gt;:667</span><br><span class="line">    exhausted real (wall clock) time allowance of 19.97 seconds </span><br><span class="line">    | ProcessVisibility: Foreground </span><br><span class="line">    | ProcessState: Running </span><br><span class="line">    | WatchdogEvent: scene-create </span><br><span class="line">    | WatchdogVisibility: Foreground </span><br><span class="line">    | WatchdogCPUStatistics: ( </span><br><span class="line">    |  &quot;Elapsed total CPU time (seconds): 15.290 (user 15.290, system 0.000), 28% CPU&quot;, </span><br><span class="line">    |  &quot;Elapsed application CPU time (seconds): 0.367, 1% CPU&quot; </span><br><span class="line">    | )</span><br></pre></td></tr></table></figure><p>由<code>WatchdogEvent: scene-create</code> 可以看出是在<strong>场景创建</strong>时终止的，原因是没有在允许的启动时间内将UI的第一帧渲染到屏幕上。</p><h4 id="崩溃信息中的信息解析"><a href="#崩溃信息中的信息解析" class="headerlink" title="崩溃信息中的信息解析"></a>崩溃信息中的信息解析</h4><h5 id="1-1-Elapsed-total-CPU-time"><a href="#1-1-Elapsed-total-CPU-time" class="headerlink" title="1.1 Elapsed total CPU time"></a>1.1 Elapsed total CPU time</h5><p><code>Elapsed total CPU time</code> 显示CPU在挂钟时间内系统上的所有进程运行了多少时间。</p><p>此CPU时间以及应用程序CPU时间适用于跨CPU内核的总CPU利用率，可能超过100%。例如，如果一个CPU内核利用率为100%，第二个CPU内核利用率为20%，则总CPU利用率为120%。</p><h5 id="1-2-Elapsed-application-CPU-time"><a href="#1-2-Elapsed-application-CPU-time" class="headerlink" title="1.2 Elapsed application CPU time"></a>1.2 Elapsed application CPU time</h5><p><code>Elapsed application CPU time</code> 显示应用程序在挂钟时间内在CPU上运行所花费的时间。</p><p>如果此数字处于任一极端，则表明存在问题。如果数字很高，则应用程序正在其所有线程中执行大量工作（该数字聚合所有线程，并且不特定于主线程。）</p><p>如果此数字较低，则该应用程序大部分处于空闲状态，因为它正在等待系统资源，例如网络连接。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>异步请求</li><li><p>不要使用 <code>SCNetworkReachability</code>，而是使用 <code>NWPathMonitor</code> 在网络路径更改时接收更新。系统在您调用 <code>start</code>(<code>queue:</code>) 时传入的队列上提供更新，因此路径更新功能安全地脱离主线程。</p></li><li><p>在辅助线程中执行同步网络</p></li><li>大多数情况下不建议手动解析 <code>DNS</code>。使用 <code>URLSession</code> 让系统代表您处理 <code>DNS</code> 解析。如果切换非常困难，并且您仍然需要手动更改 <code>DNS</code> 地址，请使用异步 <code>API</code>，如 <code>CFHost</code> 或 中的 <code>API</code>。</li></ul><p><a href="https://developer.apple.com/documentation/xcode/addressing-watchdog-terminations#Interpret-the-App-Responsiveness-Watchdog-Information" target="_blank" rel="noopener">Addressing Watchdog Terminations</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;为了防止一个应用程序占用过多的系统资源，苹果设计一个监督机构 &lt;code&gt;watchdog&lt;/code&gt; ,音译：&lt;strong&gt;看门狗机制
      
    
    </summary>
    
      <category term="iOS" scheme="https://qinguohua.fun/categories/iOS/"/>
    
    
      <category term="watchdog" scheme="https://qinguohua.fun/tags/watchdog/"/>
    
      <category term="crash" scheme="https://qinguohua.fun/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>Python的小Tips</title>
    <link href="https://qinguohua.fun/2020/03/23/2020-03-23-python-tips/"/>
    <id>https://qinguohua.fun/2020/03/23/2020-03-23-python-tips/</id>
    <published>2020-03-23T14:55:10.000Z</published>
    <updated>2021-10-16T15:00:26.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-默认值在-定义作用域里的函数定义中求值"><a href="#1-默认值在-定义作用域里的函数定义中求值" class="headerlink" title="1. 默认值在 定义作用域里的函数定义中求值"></a>1. 默认值在 <strong>定义</strong>作用域里的函数定义中求值</h3><h4 id="1-1-默认值为不可变对象时，只计算一次"><a href="#1-1-默认值为不可变对象时，只计算一次" class="headerlink" title="1.1 默认值为不可变对象时，只计算一次"></a>1.1 默认值为不可变对象时，只计算一次</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">6</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ff</span><span class="params">(age = i)</span>:</span></span><br><span class="line">print(age)</span><br><span class="line"></span><br><span class="line">i = <span class="number">12</span></span><br><span class="line">ff()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="1-2-默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果"><a href="#1-2-默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果" class="headerlink" title="1.2 默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果"></a>1.2 默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果</h4><p>例如,下面的函数会累积后续调用时传递的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">6</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ff</span><span class="params">(age,ages=[])</span>:</span></span><br><span class="line">ages.append(age)</span><br><span class="line"><span class="keyword">return</span> ages</span><br><span class="line"></span><br><span class="line">print(ff(<span class="number">10</span>))</span><br><span class="line">print(ff(<span class="number">20</span>))</span><br><span class="line">print(ff(<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line">[<span class="number">10</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br></pre></td></tr></table></figure><p>如果不想再后续调用之间共享默认值时，可以用如下方式编写函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ff</span><span class="params">(age,ages=None)</span>:</span></span><br><span class="line"><span class="keyword">if</span> ages <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">ages = []</span><br><span class="line">ages.append(age)</span><br><span class="line"><span class="keyword">return</span> ages</span><br><span class="line"></span><br><span class="line">print(ff(<span class="number">10</span>))</span><br><span class="line">print(ff(<span class="number">20</span>))</span><br><span class="line">print(ff(<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line">[<span class="number">10</span>]</span><br><span class="line">[<span class="number">20</span>]</span><br><span class="line">[<span class="number">30</span>]</span><br></pre></td></tr></table></figure><h3 id="2-解包实参列表"><a href="#2-解包实参列表" class="headerlink" title="2. 解包实参列表"></a>2. 解包实参列表</h3><p>函数调用要求独立的位置参数，但实参在列表或元组里时，要执行相反的操作。</p><p>例如，内置的range()函数要求独立的 start 和 stop 实参，如果这些参数不是独立的，则要在调用函数时，用 <code>*</code> 操作符把实参从列表或元组解包出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(list(range(<span class="number">3</span>,<span class="number">6</span>)))</span><br><span class="line">args = [<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">print(list(range(*args)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-默认值在-定义作用域里的函数定义中求值&quot;&gt;&lt;a href=&quot;#1-默认值在-定义作用域里的函数定义中求值&quot; class=&quot;headerlink&quot; title=&quot;1. 默认值在 定义作用域里的函数定义中求值&quot;&gt;&lt;/a&gt;1. 默认值在 &lt;strong&gt;定义&lt;/st
      
    
    </summary>
    
      <category term="Python" scheme="https://qinguohua.fun/categories/Python/"/>
    
    
      <category term="python" scheme="https://qinguohua.fun/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>循环的技巧</title>
    <link href="https://qinguohua.fun/2020/03/14/2020-03-14-python-for/"/>
    <id>https://qinguohua.fun/2020/03/14/2020-03-14-python-for/</id>
    <published>2020-03-14T14:54:55.000Z</published>
    <updated>2021-10-16T14:59:10.201Z</updated>
    
    <content type="html"><![CDATA[<p>Python 的 for 语句与 C语言中的不同，它是不支持<strong>迭代算术递增数值</strong>这种方式的，但Python迭代列表或者字符串等任意序列，元素的迭代顺序与在序列中出现的顺序一致。</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Python'</span>,<span class="string">'dart'</span>,<span class="string">'Swift'</span>,<span class="string">'Objective-C'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">  print(name,len(name))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line">Python <span class="number">6</span></span><br><span class="line">dart <span class="number">4</span></span><br><span class="line">Swift <span class="number">5</span></span><br><span class="line">Objective-C <span class="number">11</span></span><br></pre></td></tr></table></figure><p>在遍历的同时修改序列内容，通常是开发中的大忌，所以执行这种操作时，需要创建一个新的序列或者遍历序列的副本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Python'</span>,<span class="string">'dart'</span>,<span class="string">'Swift'</span>,<span class="string">'Objective-C'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names.copy():</span><br><span class="line">  <span class="keyword">if</span> name == <span class="string">'dart'</span>:</span><br><span class="line">    names.remove(name)</span><br><span class="line">print(names)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line">[<span class="string">'Python'</span>, <span class="string">'Swift'</span>, <span class="string">'Objective-C'</span>]</span><br></pre></td></tr></table></figure><h4 id="range-搭配-len"><a href="#range-搭配-len" class="headerlink" title="range() 搭配 len()"></a>range() 搭配 len()</h4><p>内置函数range()常用于遍历数字序列。</p><p>如果希望以<strong>迭代算术递增数值</strong> 这种方式做迭代，通常是以range() + len() 这种方式实现，当然也是对便捷的。</p><p>例如，希望获取某个值的下标，可以这样实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(names)):</span><br><span class="line">  <span class="keyword">if</span> names[i] == <span class="string">'Swift'</span>:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>当然也可以将下标和值仪器打印，像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(names)):</span><br><span class="line">  print(i,names[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line"><span class="number">0</span> Python</span><br><span class="line"><span class="number">1</span> dart</span><br><span class="line"><span class="number">2</span> Swift</span><br><span class="line"><span class="number">3</span> Objective-C</span><br></pre></td></tr></table></figure><p>但这种实现方式，通常使用<code>enumerate()</code> 函数会更加便捷一些。</p><h4 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate()函数"></a>enumerate()函数</h4><p>enumerate()函数返回的是一个枚举对象，该枚举对象里是一个个的元组：(index下标, 值)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(names):</span><br><span class="line">  print(i,v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line"><span class="number">0</span> Python</span><br><span class="line"><span class="number">1</span> dart</span><br><span class="line"><span class="number">2</span> Swift</span><br><span class="line"><span class="number">3</span> Objective-C</span><br></pre></td></tr></table></figure><h4 id="reversed-函数"><a href="#reversed-函数" class="headerlink" title="reversed()函数"></a>reversed()函数</h4><p>reversed()函数是将序列翻转。</p><p>假如想将一个list倒序输出的话，可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> reversed(names):</span><br><span class="line">  print(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line">Objective-C</span><br><span class="line">Swift</span><br><span class="line">dart</span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>当然也可以配合range()函数做一些事情，例如将10以内的奇数倒序输出，像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)):</span><br><span class="line">  print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="sorted-函数"><a href="#sorted-函数" class="headerlink" title="sorted()函数"></a>sorted()函数</h4><p>如果想按指定顺序循环序列，就可以使用sorted()来完成。像这样，在不改动原序列的基础上，返回一个重新的序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">languages = [<span class="string">'Python'</span>,<span class="string">'dart'</span>,<span class="string">'flutter'</span>,<span class="string">'shell'</span>,<span class="string">'ruby'</span>,<span class="string">'Python'</span>,<span class="string">'Objective-C'</span>,<span class="string">'Swift'</span>,<span class="string">'Objective-C'</span>]</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> sorted(languages):</span><br><span class="line">  print(language)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line">Objective-C</span><br><span class="line">Objective-C</span><br><span class="line">Python</span><br><span class="line">Python</span><br><span class="line">Swift</span><br><span class="line">dart</span><br><span class="line">flutter</span><br><span class="line">ruby</span><br><span class="line">shell</span><br></pre></td></tr></table></figure><h4 id="set-函数"><a href="#set-函数" class="headerlink" title="set()函数"></a>set()函数</h4><p>set()函数可以去除序列中重复的元素。</p><p>如果想’将一个序列中的重复元素去掉，并排序的话，使用set() 和 sorted()函数结合是一个不错的选择，像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> sorted(set(languages)):</span><br><span class="line">  print(language)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line">Objective-C</span><br><span class="line">Python</span><br><span class="line">Swift</span><br><span class="line">dart</span><br><span class="line">flutter</span><br><span class="line">ruby</span><br><span class="line">shell</span><br></pre></td></tr></table></figure><h4 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip()函数"></a>zip()函数</h4><p>同时循环两个或多个序列时，用zip()函数可以将其内的元素一一匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qustions = [<span class="string">'你是什么语言？'</span>,<span class="string">'很厉害吗？'</span>,<span class="string">'有什么用处？'</span>]</span><br><span class="line">answers = [<span class="string">'Python'</span>,<span class="string">'超厉害'</span>,<span class="string">'我是一门开源性，面向对象的语言，，功能十分强大，有很多内置库，内置工具，而且是语法表达优美，可移植，可扩展'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> q,a <span class="keyword">in</span> zip(qustions,answers):</span><br><span class="line">  print(q,a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line">你是什么语言？ Python</span><br><span class="line">很厉害吗？ 超厉害</span><br><span class="line">有什么用处？ 我是一门开源性，面向对象的语言，，功能十分强大，有很多内置库，内置工具，而且是语法表达优美，可移植，可扩展</span><br></pre></td></tr></table></figure><p>如果两个数组的大小不对等，zip()函数仍然能做到一一匹配，并将不能匹配到的元素丢弃掉，而不是抛出异常，这是一个很好的处理方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qustions = [<span class="string">'你是什么语言？'</span>,<span class="string">'很厉害吗？'</span>,<span class="string">'有什么用处？'</span>,<span class="string">'其他语言能替代你吗？'</span>,<span class="string">'你真厉害！'</span>]</span><br><span class="line">answers = [<span class="string">'Python'</span>,<span class="string">'超厉害'</span>,<span class="string">'我是一门开源性，面向对象的语言，，功能十分强大，有很多内置库，内置工具，而且是语法表达优美，可移植，可扩展'</span>,<span class="string">'不能'</span>]</span><br><span class="line"><span class="keyword">for</span> q,a <span class="keyword">in</span> zip(qustions,answers):</span><br><span class="line">  print(q,a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result:</span><br><span class="line">你是什么语言？ Python</span><br><span class="line">很厉害吗？ 超厉害</span><br><span class="line">有什么用处？ 我是一门开源性，面向对象的语言，，功能十分强大，有很多内置库，内置工具，而且是语法表达优美，可移植，可扩展</span><br><span class="line">其他语言能替代你吗？ 不能</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python 的 for 语句与 C语言中的不同，它是不支持&lt;strong&gt;迭代算术递增数值&lt;/strong&gt;这种方式的，但Python迭代列表或者字符串等任意序列，元素的迭代顺序与在序列中出现的顺序一致。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="Python" scheme="https://qinguohua.fun/categories/Python/"/>
    
    
      <category term="python" scheme="https://qinguohua.fun/tags/python/"/>
    
      <category term="for" scheme="https://qinguohua.fun/tags/for/"/>
    
  </entry>
  
  <entry>
    <title>算法：从尾到头打印链表</title>
    <link href="https://qinguohua.fun/2019/04/20/2019-04-20-Arithmetic-weekly5/"/>
    <id>https://qinguohua.fun/2019/04/20/2019-04-20-Arithmetic-weekly5/</id>
    <published>2019-04-20T12:46:09.000Z</published>
    <updated>2021-10-16T14:46:27.586Z</updated>
    
    <content type="html"><![CDATA[<h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h4><h4 id="题：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下："><a href="#题：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下：" class="headerlink" title="题：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下："></a>题：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  <span class="keyword">int</span>   m_nKey;</span><br><span class="line">  ListNode* m_pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>我们首先想到的是链表的翻转，这也是我们的第一思路。但链表的翻转会改变原来链表的结构，如果不允许在打印链表的时候修改链表的结构呢？</p><p>分析：打印链表首先需要遍历链表，遍历的顺序是从头到尾，但要求的输出顺序是：从尾到头。这种方式为典型的”后进先出”，所以可以用栈实现这种顺序。每遍历一个节点，就将该节点放入栈中。当遍历完整个链表后，再从栈顶开始逐个输出节点的值。这样得到的顺序就是从尾到头的顺序。</p><p>所以完成该题有两种思路：</p><p>1、在没有要求不允许更改链表结构的情况下，利用链表的翻转可以完成该题。</p><p>2、分析该题的要求，根据符合栈的”后进先出”这一特性，利用栈来完成该题。</p><h4 id="代码实践："><a href="#代码实践：" class="headerlink" title="代码实践："></a>代码实践：</h4><p><strong>1、链表翻转</strong></p><p>1.1循环实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">revereList</span><span class="params">(ListNode* pHead)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">ListNode* pNode = pHead;</span><br><span class="line"><span class="comment">//当前节点的上一个节点</span></span><br><span class="line">ListNode* pPrev = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//当前节点的下一个节点</span></span><br><span class="line">ListNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//新链表的头指针</span></span><br><span class="line">ListNode* pReverseHead = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="comment">//如果当前节点不为空，获取该节点的下一个节点</span></span><br><span class="line">pNext = pNode-&gt;p_next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果下一个节点为空，说明遍历到了尾部，将新链表的头指针指向当前节点</span></span><br><span class="line"><span class="keyword">if</span> (pNext == <span class="literal">NULL</span>) &#123;</span><br><span class="line">pReverseHead = pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前的节点的p_next指向前一个节点</span></span><br><span class="line">pNode-&gt;p_next = pPrev;</span><br><span class="line"><span class="comment">//前一个节点指向当前节点</span></span><br><span class="line">pPrev = pNode;</span><br><span class="line"><span class="comment">//当前节点指向下一个节点</span></span><br><span class="line">pNode = pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pReverseHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">ListNode *p1=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">ListNode *p2=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">head-&gt;p_next=p1;</span><br><span class="line">p1-&gt;p_next=p2; </span><br><span class="line"></span><br><span class="line">ListNode *p=revereList(head);</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">p = p-&gt;p_next;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">revereList</span><span class="params">(ListNode* pHead, ListNode* &amp;newHead)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* nextHead = pHead-&gt;p_next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line">newHead = pHead;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">revereList(nextHead, newHead);</span><br><span class="line">nextHead-&gt;p_next = pHead;</span><br><span class="line">pHead-&gt;p_next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">ListNode *p1=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">ListNode *p2=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">head-&gt;p_next=p1;</span><br><span class="line">p1-&gt;p_next=p2; </span><br><span class="line"></span><br><span class="line">ListNode *newhead=<span class="literal">NULL</span>;</span><br><span class="line">ListNode *p=revereList(head,newhead);</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">p = p-&gt;p_next;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、利用栈的”后进先出”实现</strong></p><p>1.1 循环实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListNodeReverse_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt;nodes;</span><br><span class="line"></span><br><span class="line">ListNode* pNode = pHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">nodes.push(pNode);</span><br><span class="line">pNode = pNode-&gt;p_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!nodes.empty()) &#123;</span><br><span class="line">pNode = nodes.top();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,pNode-&gt;val);</span><br><span class="line">nodes.pop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2递归实现</p><p>由于递归本质就是一个栈结构，所以可以直接用递归实现，要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自己，这样链表的输出结果就反过来了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListNodeReverse_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pHead != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pHead -&gt;p_next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">printListNodeReverse_Iteratively(pHead -&gt;p_next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,pHead-&gt;p_value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                  <span class="comment">//测试代码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">ListNode *p1=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">ListNode *p2=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">head-&gt;p_next=p1;</span><br><span class="line">p1-&gt;p_next=p2;</span><br><span class="line">printListNodeReverse_Iteratively(head);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：本篇所有思路均参考或直接引用《剑指offer》一书</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;从尾到头打印链表&quot;&gt;&lt;a href=&quot;#从尾到头打印链表&quot; class=&quot;headerlink&quot; title=&quot;从尾到头打印链表&quot;&gt;&lt;/a&gt;从尾到头打印链表&lt;/h4&gt;&lt;h4 id=&quot;题：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下：&quot;&gt;
      
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm training" scheme="https://qinguohua.fun/tags/algorithm-training/"/>
    
  </entry>
  
  <entry>
    <title>算法：实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;</title>
    <link href="https://qinguohua.fun/2019/04/14/2019-04-14-Arithmetic-weekly4/"/>
    <id>https://qinguohua.fun/2019/04/14/2019-04-14-Arithmetic-weekly4/</id>
    <published>2019-04-14T03:46:09.000Z</published>
    <updated>2021-10-16T14:46:27.586Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”-则输出-“We-20are-20family-”。"><a href="#题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”-则输出-“We-20are-20family-”。" class="headerlink" title="题：实现一个函数，把字符串中的每个空格替换成”%20”。例如：”We are family.”,则输出 “We%20are%20family.”。"></a>题：实现一个函数，把字符串中的每个空格替换成”%20”。例如：”We are family.”,则输出 “We%20are%20family.”。</h4><h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><p>在网络编程中，如果URL参数中含有特殊字符，如空格、’#’等，则可能导致服务器端无法获得正确的参数值。我们需要将这些特殊符号转成服务器可以识别的字符。<strong>转换的规则是在’%’后面跟上ASCII码的两位十六进制的表示</strong>。比如空格的ASCII码是32，即十六进制的0x20，因此空格被替换成’%20’；再比如’#’的ASCII码为35，即十六进制的0x23,它在URL中被替换为’%23’。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>这题的规则很简单，将空格替换成’%20’，那么需要考虑的就是时间复杂度的问题。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>最简单的想法是：直接遍历字符串中的字符，遇到空格便将其替换成’%20’，但有一些问题，空格的长度和’%20’的长度是不等的，那么结果是需要将每个空格后面的字符向后移动。举个例子：如果字符串的长度为n，对每个空格字符，需要移动后面的O(n)个字符，因此对于含有O(n)个空格字符的字符串而言，总的时间复杂度为：O(n^2)。</p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>使用辅助空间，遍历字符串的每个字符，将其添加到辅助字符串中，添加的过程中将空格替换成’%20’。这种方法是牺牲空复杂度间换取时间复杂度。时间复杂度为：O(n)。</p><h5 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h5><p>先遍历一遍字符串，找出其中的空格，确定替换后的字符转的长度。然后从字符串的后面开始复制和替换。首先准备两个指针：P1和P2。P1指向原始字符串的末尾，P2则指向替换之后的字符串的末尾。<strong>实现步骤：</strong>做好之前的准备后，向前移动指针P1，诸葛把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。时间复杂度为：O(n)。</p><h4 id="代码实践："><a href="#代码实践：" class="headerlink" title="代码实践："></a>代码实践：</h4><p><strong>方法一实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">1000</span>] = <span class="string">"We are family."</span>;</span><br><span class="line"><span class="keyword">int</span> stringlen = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">int</span> indexNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringlen; i++)&#123;</span><br><span class="line"><span class="keyword">char</span> charStr = <span class="built_in">string</span>[i];</span><br><span class="line"><span class="keyword">if</span> (charStr == <span class="string">' '</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//将空格之后的字符向后移动</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = stringlen;j &gt; i; j--) &#123;</span><br><span class="line"><span class="built_in">string</span>[j+<span class="number">2</span>] = <span class="built_in">string</span>[j]; </span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span>[++indexNum] = <span class="string">'%'</span>;</span><br><span class="line"><span class="built_in">string</span>[++indexNum] = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">string</span>[++indexNum] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">i = i+<span class="number">2</span>;  </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">indexNum = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n-----one3 %s\n"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p><strong>方法二实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"We are family."</span>;</span><br><span class="line"><span class="keyword">int</span> strLen = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这段代码是用来计算辅助字符串的长度的;</span></span><br><span class="line"><span class="keyword">char</span> replaceStr[] = <span class="string">"%20"</span>;</span><br><span class="line"><span class="comment">//统计空格的数目</span></span><br><span class="line"><span class="keyword">int</span> bankNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++)&#123;</span><br><span class="line"><span class="keyword">char</span> charStr = str[i];</span><br><span class="line"><span class="keyword">if</span> (charStr == <span class="string">' '</span>) &#123;</span><br><span class="line">bankNumber++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> replacelen = bankNumber * (<span class="built_in">strlen</span>(replaceStr)<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> repStrNewlen = strLen + replacelen; </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据计算的字符串长度，创建辅助字符串</span></span><br><span class="line"><span class="keyword">char</span> newStr[repStrNewlen] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将str中的字符复制到辅助字符串中，并将空格替换为'%20'</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (strLen &gt; <span class="number">0</span> &amp;&amp; num &lt;= strLen) &#123;</span><br><span class="line"><span class="keyword">char</span> charS = str[num];</span><br><span class="line"><span class="keyword">if</span> (charS == <span class="string">' '</span>) &#123;</span><br><span class="line">newStr[index++] = <span class="string">'%'</span>;</span><br><span class="line">newStr[index++] = <span class="string">'2'</span>;</span><br><span class="line">newStr[index++] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">newStr[index++] = charS;</span><br><span class="line">&#125;</span><br><span class="line">++num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--------one2Result == %s"</span>,newStr);</span><br></pre></td></tr></table></figure><p><strong>方法三实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">"We are family."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计空格的数目</span></span><br><span class="line"><span class="keyword">int</span> bankNumber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> replaceStr[] = <span class="string">"%20"</span>;</span><br><span class="line"><span class="keyword">int</span> stringlen = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringlen; i++)&#123;</span><br><span class="line"><span class="keyword">char</span> charStr = <span class="built_in">string</span>[i];</span><br><span class="line"><span class="keyword">if</span> (charStr == <span class="string">' '</span>) &#123;</span><br><span class="line">bankNumber++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//替换字符增加的长度</span></span><br><span class="line"><span class="keyword">int</span> replacelen = bankNumber * (<span class="built_in">strlen</span>(replaceStr)<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//替换后的字符串长度</span></span><br><span class="line"><span class="keyword">int</span> repStrNewlen = stringlen + replacelen; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (stringlen &gt;= <span class="number">0</span> &amp;&amp; stringlen &lt; repStrNewlen) &#123;  </span><br><span class="line"><span class="keyword">char</span> char1 = <span class="built_in">string</span>[stringlen];</span><br><span class="line"><span class="keyword">if</span> (char1 == <span class="string">' '</span>) &#123;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = <span class="string">'%'</span>;</span><br><span class="line">bankNumber--;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = char1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--stringlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"result==%s \n"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”-则输出-“We-20are-20family-”。&quot;&gt;&lt;a href=&quot;#题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”
      
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm training" scheme="https://qinguohua.fun/tags/algorithm-training/"/>
    
  </entry>
  
  <entry>
    <title>算法：判断数组中是否含有某个整数</title>
    <link href="https://qinguohua.fun/2019/04/12/2019-04-12-Arithmetic-weekly3/"/>
    <id>https://qinguohua.fun/2019/04/12/2019-04-12-Arithmetic-weekly3/</id>
    <published>2019-04-12T08:00:18.000Z</published>
    <updated>2021-10-16T14:46:27.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。"><a href="#题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。" class="headerlink" title="题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。"></a>题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。</h3><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>二维数组。而且数组的排列顺序也给了规定：每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>二分查找方法，以及利用二维数组的排列顺序规则进行查找。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。"><a href="#1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。" class="headerlink" title="1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。"></a>1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。</h5><h5 id="2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。"><a href="#2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。" class="headerlink" title="2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。"></a>2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>&#125;, &#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>&#125;, &#123;<span class="number">21</span>,<span class="number">23</span>,<span class="number">36</span>&#125;, &#123;<span class="number">33</span>,<span class="number">36</span>,<span class="number">37</span>&#125;, &#123;<span class="number">42</span>,<span class="number">46</span>,<span class="number">49</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>,  <span class="number">7</span> , <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>, <span class="number">12</span>, <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span>, <span class="number">23</span>, <span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="number">33</span>, <span class="number">36</span>, <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="number">42</span>, <span class="number">46</span>, <span class="number">49</span></span><br></pre></td></tr></table></figure><h4 id="代码实践："><a href="#代码实践：" class="headerlink" title="代码实践："></a>代码实践：</h4><p><strong>方案一：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>][<span class="number">3</span>]=&#123; &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>&#125;, &#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>&#125;, &#123;<span class="number">21</span>,<span class="number">23</span>,<span class="number">36</span>&#125;, &#123;<span class="number">33</span>,<span class="number">36</span>,<span class="number">37</span>&#125;, &#123;<span class="number">42</span>,<span class="number">46</span>,<span class="number">49</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> targetNumber =  <span class="number">33</span>;</span><br><span class="line"><span class="keyword">int</span> numbers = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//行数 </span></span><br><span class="line"><span class="keyword">int</span> rowNumbers = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);  <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//列数</span></span><br><span class="line"><span class="keyword">int</span> lineNumbers= <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转成一维数组</span></span><br><span class="line"><span class="keyword">int</span> arrB[numbers];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowNumbers;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; lineNumbers;j++)&#123;</span><br><span class="line">arrB[i*lineNumbers+j] = arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;numbers ; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arrB[j] &gt; arrB[j - <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arrB[j];</span><br><span class="line">arrB[j] = arrB[j - <span class="number">1</span>];</span><br><span class="line">arrB[j - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = numbers;</span><br><span class="line"><span class="keyword">int</span> middle = (start+end)*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(middle &gt;= start || middle &lt;= end)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = arrB[middle];</span><br><span class="line"><span class="keyword">if</span> (num == targetNumber) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----%d-----"</span>,num);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; targetNumber)&#123;</span><br><span class="line">middle =  (end-middle)/<span class="number">2</span> + middle;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; targetNumber)&#123;</span><br><span class="line">middle =  (middle-start)/<span class="number">2</span> + start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">示例二维数组： int example[5][10]</span><br><span class="line">数组的总数为： </span><br><span class="line">sizeof(example) / sizeof(int)// sizeof(example)为该数组的大小(这里是5x10)，sizeof(int)为int类型的大小(4)</span><br><span class="line">数组列数为： </span><br><span class="line">sizeof(example[0])/sizeof(int)// sizeof(example[0])为该数组一行的大小(这里是10)</span><br><span class="line">数组行数则为 ：</span><br><span class="line">( sizeof(example) / sizeof(int) )/ ( sizeof(example[0]) / sizeof(int) )</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int arr[5][3]=&#123; &#123;5,7,10&#125;, &#123;10,12,23&#125;, &#123;21,23,36&#125;, &#123;33,36,37&#125;, &#123;42,46,49&#125; &#125;;</span><br><span class="line"></span><br><span class="line">int targetNumber =  33;</span><br><span class="line">int numbers = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">//行数 </span><br><span class="line">int rowNumbers = sizeof(arr)/sizeof(arr[0]);  // 5</span><br><span class="line">//列数</span><br><span class="line">int lineNumbers= sizeof(arr[0])/sizeof(int);  // 3</span><br><span class="line"></span><br><span class="line">int rowIndex = 0;</span><br><span class="line">bool result = false;</span><br><span class="line">while(lineNumbers &gt;= 0 &amp;&amp; rowNumbers &gt;= 0)&#123;</span><br><span class="line"></span><br><span class="line">int number = arr[rowIndex][lineNumbers-1];</span><br><span class="line">if (number == targetNumber) &#123;</span><br><span class="line">result = true;</span><br><span class="line">printf(&quot;-------%d----&quot;,number);</span><br><span class="line">return;</span><br><span class="line">&#125;else if(number &gt; targetNumber &amp;&amp; lineNumbers &gt;0)&#123;</span><br><span class="line">lineNumbers--;</span><br><span class="line">&#125;else if(number &lt; targetNumber &amp;&amp; rowIndex &lt; rowNumbers)&#123;</span><br><span class="line">rowIndex++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (result == false) &#123;</span><br><span class="line">printf(&quot;数组中未找到该数字&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。&quot;&gt;&lt;a href=&quot;#题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整
      
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm training" scheme="https://qinguohua.fun/tags/algorithm-training/"/>
    
  </entry>
  
  <entry>
    <title>算法：找出数组中重复的数字</title>
    <link href="https://qinguohua.fun/2019/04/11/2019-04-11-Arithmetic-weekly2/"/>
    <id>https://qinguohua.fun/2019/04/11/2019-04-11-Arithmetic-weekly2/</id>
    <published>2019-04-11T03:58:52.000Z</published>
    <updated>2021-10-16T14:46:27.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h3><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如：如果输入长度为 7 的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>从数组中找出重复的数字，如果没有提示！</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>遍历数组进行匹配，考虑时间复杂度问题。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、双重遍历"><a href="#1、双重遍历" class="headerlink" title="1、双重遍历"></a>1、双重遍历</h5><p>将数组中的每一个数与其他数做匹配，如果两者相等，输出，否则输出未找到提示。</p><h5 id="2、排序-遍历"><a href="#2、排序-遍历" class="headerlink" title="2、排序+遍历"></a>2、排序+遍历</h5><p>将数组排序，匹配相邻者数字，如果两者相等，输出，否则输出未找到提示。</p><h5 id="3、哈希表-遍历"><a href="#3、哈希表-遍历" class="headerlink" title="3、哈希表+遍历"></a>3、哈希表+遍历</h5><p>将遍历时的每个数存入哈希表中，每次存入的时候判断下是否</p><h5 id="4、辅助数组-遍历"><a href="#4、辅助数组-遍历" class="headerlink" title="4、辅助数组+遍历"></a>4、辅助数组+遍历</h5><p>创建一个辅助数组，然后逐一把原数组的每个数字复制到辅助数组中，如果原数组中被复制的数字是n,则把它复制到辅助数组中下标为n的位置。如果该位置已有相同的数字，则该数字为重复数字。该方案需要O(n)的辅助空间。</p><h5 id="5、类似二分查找方法"><a href="#5、类似二分查找方法" class="headerlink" title="5、类似二分查找方法"></a>5、类似二分查找方法</h5><p>前提：在一个长度为n的数组里的所有数字都在0~n-1的范围内。我们把从0~n-1的数字从中间的数字【 (n-1)/2】（下面以m表示）分为两部分，前半部分为0~m,后半部分为m+1 ~ n-1。如果1~m的数字个数超过m，则这个区间一定存在重复的数字；否则后半部分区间一定存在重复的数字。继续重复分割数字区间，直到找到一个重复的数字。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践:"></a>代码实践:</h4><p><strong>双重遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&lt;len;j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (number == arr[j]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,number);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"未找到"</span>);</span><br></pre></td></tr></table></figure><p><strong>排序+遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="keyword">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp;j--)&#123;</span><br><span class="line">arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[index];</span><br><span class="line"><span class="keyword">int</span> next = arr[index+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (number == next) &#123;</span><br><span class="line">result = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--%d---"</span>,number);</span><br><span class="line">&#125;</span><br><span class="line">index = index+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result == <span class="literal">false</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"未找到"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哈希表+遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len &lt;= <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =  <span class="number">0</span>; i &lt; len ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span> || arr[i] &gt; len<span class="number">-1</span> ) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> number = arr[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(number != i)&#123;</span><br><span class="line"><span class="keyword">int</span> nextNum = arr[number];</span><br><span class="line"><span class="keyword">if</span>(number == nextNum)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,number);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = number;</span><br><span class="line">arr[i] = nextNum;</span><br><span class="line">arr[number] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、辅助数组+遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr1[len+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[i];</span><br><span class="line"><span class="keyword">int</span> tagerNumber = arr1[number];</span><br><span class="line"><span class="keyword">if</span>(number == tagerNumber)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----%d\n"</span>,number);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">arr1[number] = number;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、类似二分查找方法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line"><span class="keyword">int</span> middle = (end+start)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//计算区间里的数字数目</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;=middle &amp;&amp; arr[i]&gt;=start)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果区间内的数字个数大于区间的应有个数（比如：10-20， 中间数为15，区间为10-15，区间内应有5个数）</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; middle-start+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//说明重复数字在[start,middle]中</span></span><br><span class="line">end = middle;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//说明重复数字在[middle,end]中</span></span><br><span class="line">start = middle+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找索引相遇代表查找结束。</span></span><br><span class="line"><span class="keyword">if</span>(end == start)&#123;</span><br><span class="line"><span class="comment">//count大于0，说明找到重复数字</span></span><br><span class="line"><span class="keyword">if</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,start);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;找出数组中重复的数字&quot;&gt;&lt;a href=&quot;#找出数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;找出数组中重复的数字&quot;&gt;&lt;/a&gt;找出数组中重复的数字&lt;/h3&gt;&lt;h4 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;header
      
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm training" scheme="https://qinguohua.fun/tags/algorithm-training/"/>
    
  </entry>
  
  <entry>
    <title>算法：找出有序数组中和等于指定数的两个数</title>
    <link href="https://qinguohua.fun/2019/04/04/2019-04-04-Arithmetic-weekly1/"/>
    <id>https://qinguohua.fun/2019/04/04/2019-04-04-Arithmetic-weekly1/</id>
    <published>2019-04-04T02:27:55.000Z</published>
    <updated>2021-10-16T14:46:27.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题：找出有序数组中和等于指定数的两个数"><a href="#题：找出有序数组中和等于指定数的两个数" class="headerlink" title="题：找出有序数组中和等于指定数的两个数"></a>题：找出有序数组中和等于指定数的两个数</h3><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>数组是有序的；数组中可能存在两个数相加的和等于给定的值，找出这两个数，如果没有提示。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先想到的必须遍历数组，这点是毋庸置疑的。这时需要考虑的就是怎样遍历数组以及时间复杂度问题。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、双重遍历"><a href="#1、双重遍历" class="headerlink" title="1、双重遍历"></a>1、双重遍历</h5><p>最简单也是最笨重的想法是双重遍历：将每个数与另外的数相加，判断是否等于目标值，时间复杂度为O(n*n)。</p><h5 id="2、快速查找法"><a href="#2、快速查找法" class="headerlink" title="2、快速查找法"></a>2、快速查找法</h5><p><strong>方法一：</strong>从两端开始，分别向中间取值匹配。时间复杂度为O(n)。</p><p>(1)如果两数之和&gt;目标值,说明较大加数需要小些，向数组的较小值方向移位取值继续和原较小值重新匹配。</p><p>(2)如果两数之和&lt;目标值,说明较小加数需要大些，向数组的较大值方向移位取值继续和原较大值重新匹配。</p><p><strong>方法二：</strong>近一步思考：以数组中间下标(index)为分界点，分别向左右两边取值匹配。时间复杂度为O(n)。</p><p>  （1）若两数之和&gt;目标值，说明较小加数还要再小，向数组的较小值方向移位取值与原较大值重新匹配。</p><p>  （2）若两数之和&lt;目标值，说明较大加数还要再大，向数组的较大值方向移位取值与原较小值重新匹配。</p><p><strong>方法三：</strong>换一种方式思考，    两个加数一定满足条件：较小加数小于等于目标值的一半，并且较大值大于等于目标值的一半（较小加数&lt;= (目标值/2) &lt;= 较大加数）；那么只需要找出该数组的较小加数和较大加数分界index，以该分界为起点分别往左右两边逐个取值匹配。比较的方式遵循方法二的(1)(2)。时间复杂度仍为O(n)。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h4><h5 id="双重遍历"><a href="#双重遍历" class="headerlink" title="双重遍历"></a>双重遍历</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;51&quot;,@&quot;60&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">BOOL result = NO;</span><br><span class="line"></span><br><span class="line">for(NSInteger i = 0    ; i&lt; arr.count; i++)&#123;</span><br><span class="line">    NSInteger minNumber = [arr[i] integerValue];</span><br><span class="line">    </span><br><span class="line">    for (NSInteger j = i+1;j&lt; arr.count;j++) &#123;</span><br><span class="line">        NSInteger maxNumber = [arr[j] integerValue];</span><br><span class="line">        if(minNumber + maxNumber == targetNumber )&#123;</span><br><span class="line">            NSLog(@&quot;search3 :::::::%li---%li&quot;,minNumber,maxNumber);</span><br><span class="line">            result = YES;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h5><p><strong>方法一：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;24&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;50&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">BOOL result = NO;</span><br><span class="line">NSInteger minIndex = 0 ;</span><br><span class="line">NSInteger maxIndex = arr.count-1;</span><br><span class="line">do &#123;</span><br><span class="line">    NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">    if(sumNumber &gt; targetNumber)&#123;</span><br><span class="line">        maxIndex -- ;</span><br><span class="line">    &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">        minIndex++;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">        minIndex++;</span><br><span class="line">        maxIndex--;</span><br><span class="line">        result = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; while (minIndex &lt;= maxIndex);</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;24&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;50&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">NSInteger midIndex = arr.count*0.5;</span><br><span class="line">BOOL result = NO;</span><br><span class="line">if(midIndex &gt; 0)&#123;</span><br><span class="line">    NSInteger minIndex = midIndex ;</span><br><span class="line">    NSInteger maxIndex = midIndex+1;</span><br><span class="line">    do &#123;</span><br><span class="line">        NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">        if(sumNumber &gt; targetNumber)&#123;</span><br><span class="line">            minIndex -- ;</span><br><span class="line">        &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">            maxIndex++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">            minIndex--;</span><br><span class="line">            maxIndex++;</span><br><span class="line">            result = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; while (minIndex &gt;= 0 &amp;&amp; maxIndex &lt; arr.count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;51&quot;,@&quot;60&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">NSInteger midIndex = 0;</span><br><span class="line">BOOL result = NO;</span><br><span class="line">for (NSInteger i = 0;i&lt;arr.count;i++) &#123;</span><br><span class="line">    if([arr[i] integerValue] &gt; targetNumber*0.5)&#123;</span><br><span class="line">        midIndex = i - 1;</span><br><span class="line">        NSLog(@&quot;%ld&quot;,midIndex);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(midIndex != -1)&#123;</span><br><span class="line">    NSInteger minIndex = midIndex;</span><br><span class="line">    NSInteger maxIndex =  midIndex + 1;</span><br><span class="line">    do &#123;   </span><br><span class="line">        NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">        if (sumNumber &gt; targetNumber) &#123;</span><br><span class="line">            minIndex--;</span><br><span class="line">        &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">            maxIndex++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">            minIndex--;</span><br><span class="line">            maxIndex++;</span><br><span class="line">            result = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (minIndex &gt;= 0 &amp;&amp; (maxIndex &lt;= arr.count-1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题：找出有序数组中和等于指定数的两个数&quot;&gt;&lt;a href=&quot;#题：找出有序数组中和等于指定数的两个数&quot; class=&quot;headerlink&quot; title=&quot;题：找出有序数组中和等于指定数的两个数&quot;&gt;&lt;/a&gt;题：找出有序数组中和等于指定数的两个数&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm training" scheme="https://qinguohua.fun/tags/algorithm-training/"/>
    
  </entry>
  
  <entry>
    <title>K最近邻算法</title>
    <link href="https://qinguohua.fun/2019/01/07/2019-01-07-Arithmetic6-KNN/"/>
    <id>https://qinguohua.fun/2019/01/07/2019-01-07-Arithmetic6-KNN/</id>
    <published>2019-01-07T13:38:58.000Z</published>
    <updated>2021-10-16T14:46:27.585Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://qinguohua.fun/tags/algorithm/"/>
    
      <category term="K最近邻算法" scheme="https://qinguohua.fun/tags/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>迪克特斯拉算法</title>
    <link href="https://qinguohua.fun/2019/01/06/2019-01-06-Arithmetic5-Dijkstra/"/>
    <id>https://qinguohua.fun/2019/01/06/2019-01-06-Arithmetic5-Dijkstra/</id>
    <published>2019-01-06T14:38:27.000Z</published>
    <updated>2021-10-16T14:46:27.585Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://qinguohua.fun/tags/algorithm/"/>
    
      <category term="迪克特斯拉算法" scheme="https://qinguohua.fun/tags/%E8%BF%AA%E5%85%8B%E7%89%B9%E6%96%AF%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度优先搜索（DFS）</title>
    <link href="https://qinguohua.fun/2019/01/05/2019-01-05-Arithmetic4-DFS/"/>
    <id>https://qinguohua.fun/2019/01/05/2019-01-05-Arithmetic4-DFS/</id>
    <published>2019-01-05T13:37:34.000Z</published>
    <updated>2021-10-16T14:46:27.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>深度优先搜索，英文缩写为DFS，即Depth First Search 。</p><p>是针对图和树的遍历算法，其过程简要来说是对每一个可能的分支路径深入到不能深入为止，而且每个节点只能访问一次。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p><strong>从一个顶点V0开始，沿着一条路走到底，如果发现不能到达目标解，那就返回上一个节点，然后从另一条路走到底，重复上述，一直找到或者确定未找到为止</strong>，通俗点说：DFS是一条道走到黑，没路了就再换一条道走到黑，知道走通为止。</p><h3 id="图解逻辑"><a href="#图解逻辑" class="headerlink" title="图解逻辑"></a>图解逻辑</h3><p><img src="http://blog.guohuaden.com/DFS_1.png" alt="示例图"></p><p><img src="http://blog.guohuaden.com/DFS_2.png" alt="步骤1"></p><p><img src="http://blog.guohuaden.com/DFS_3.png" alt="步骤2"></p><p><img src="http://blog.guohuaden.com/DFS_4.png" alt="步骤3"></p><p><img src="http://blog.guohuaden.com/DFS_5.png" alt="步骤4"></p><p><img src="http://blog.guohuaden.com/DFS_6.png" alt="步骤5"></p><p><img src="http://blog.guohuaden.com/DFS_7.png" alt="步骤6"></p><p><img src="http://blog.guohuaden.com/DFS_8.png" alt="步骤7"></p><p><img src="http://blog.guohuaden.com/DFS_9.png" alt="步骤8"></p><p><img src="http://blog.guohuaden.com/DFS_10.png" alt="步骤9"></p><p><img src="http://blog.guohuaden.com/DFS_11.png" alt="步骤10"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><strong>DFS核心伪代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line">*@param n: 当前开始搜索的节点</span><br><span class="line"></span><br><span class="line">*@param d: 当前到达的深度</span><br><span class="line"></span><br><span class="line">*@return 是否有解 </span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">bool DFS(Node n ,int d) &#123;</span><br><span class="line"></span><br><span class="line">    if (isEnd(n,d)) &#123;//判断是否达到条件</span><br><span class="line">        return trun;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Node nextNode in n)&#123;//遍历相邻的节点nextNode</span><br><span class="line"></span><br><span class="line">        if(!visit[nextNode])&#123;</span><br><span class="line"></span><br><span class="line">            visit[nextNode] = true;//在下一次搜索中，nextNode不能再次出现</span><br><span class="line"></span><br><span class="line">            if(DFS(nextNode,d+1))&#123;//如果搜索出有解</span><br><span class="line"></span><br><span class="line">               //做些其他的事情，例如记录结果深度等</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            //重新设置成false，因为它有可能在下一次搜索的别的 路径中</span><br><span class="line">           visit[nextNode] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码框架</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Node n)&#123;</span><br><span class="line"></span><br><span class="line">    if(达到结束状态)&#123;</span><br><span class="line">        ... //根据题意，做一些相应的操作</span><br><span class="line">        retrun;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(越界/不合法状态)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(Node nextNode in n)&#123;</span><br><span class="line">        if(扩张方法达到合法状态)&#123;</span><br><span class="line">            修改操作;//根据题意，做一些相应的操作</span><br><span class="line">            做访问过标记;</span><br><span class="line">            DFS(nextNode);</span><br><span class="line">            还原标记; //根据题意决定是否加上还原标记，如果加上就是回溯法。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪代码分析"><a href="#伪代码分析" class="headerlink" title="伪代码分析"></a>伪代码分析</h3><ol><li><p>访问路径的确定。根据不同的题目思考怎么访问一个路径，如何实现遍历</p></li><li><p>起点条件。从哪个点开始访问？是否每个点都需要当作起点？所以第一次遍历调用DFS的时机至关重要</p></li><li><p>递归参数。怎么在访问的节点上继续向下个节点访问，实现递归需要传递什么参数？</p></li><li><p>结束条件。访问的结束条件是什么？符合题意的结束条件或者临界点作为结束的判断依据</p></li><li><p>访问标志。将已访问且不符合条件的的节点做标记，防止重复访问</p></li><li><p>优化。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;深度优先搜索，英文缩写为DFS，即Depth First Search 。&lt;/p&gt;
&lt;p&gt;是针对图和树的遍历算法，其过程简要来说是对每一个可
      
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://qinguohua.fun/tags/algorithm/"/>
    
      <category term="dfs" scheme="https://qinguohua.fun/tags/dfs/"/>
    
      <category term="深度优先搜索" scheme="https://qinguohua.fun/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://qinguohua.fun/2019/01/03/2019-01-03-Arithmetic3-DynamicProgramming/"/>
    <id>https://qinguohua.fun/2019/01/03/2019-01-03-Arithmetic3-DynamicProgramming/</id>
    <published>2019-01-03T13:32:21.000Z</published>
    <updated>2021-10-16T14:46:27.585Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://qinguohua.fun/tags/algorithm/"/>
    
      <category term="动态规划" scheme="https://qinguohua.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：选择排序</title>
    <link href="https://qinguohua.fun/2018/12/31/2018-12-31-Arithmetic-Basice-SelectSort/"/>
    <id>https://qinguohua.fun/2018/12/31/2018-12-31-Arithmetic-Basice-SelectSort/</id>
    <published>2018-12-31T12:52:49.000Z</published>
    <updated>2021-10-16T14:46:27.585Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://qinguohua.fun/tags/algorithm/"/>
    
      <category term="sort" scheme="https://qinguohua.fun/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：插入排序</title>
    <link href="https://qinguohua.fun/2018/12/30/2018-12-30-Arithmetic-Basice-InsertSort/"/>
    <id>https://qinguohua.fun/2018/12/30/2018-12-30-Arithmetic-Basice-InsertSort/</id>
    <published>2018-12-30T13:10:56.000Z</published>
    <updated>2021-10-16T14:46:27.585Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://qinguohua.fun/tags/algorithm/"/>
    
      <category term="sort" scheme="https://qinguohua.fun/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>递归和for循环</title>
    <link href="https://qinguohua.fun/2018/12/01/2018-12-01-Arithmetic2-RecursionAndFor/"/>
    <id>https://qinguohua.fun/2018/12/01/2018-12-01-Arithmetic2-RecursionAndFor/</id>
    <published>2018-12-01T13:05:51.000Z</published>
    <updated>2021-10-16T14:46:27.585Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://qinguohua.fun/tags/algorithm/"/>
    
      <category term="sort" scheme="https://qinguohua.fun/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：交换排序</title>
    <link href="https://qinguohua.fun/2018/11/29/2018-11-29-Arithmetic-Basice-ExchangeSort/"/>
    <id>https://qinguohua.fun/2018/11/29/2018-11-29-Arithmetic-Basice-ExchangeSort/</id>
    <published>2018-11-29T12:54:23.000Z</published>
    <updated>2021-10-16T14:46:27.585Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://qinguohua.fun/tags/algorithm/"/>
    
      <category term="sort" scheme="https://qinguohua.fun/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>基础算法一：排序</title>
    <link href="https://qinguohua.fun/2018/11/28/2018-11-28-Arithmetic-basics/"/>
    <id>https://qinguohua.fun/2018/11/28/2018-11-28-Arithmetic-basics/</id>
    <published>2018-11-28T12:14:26.000Z</published>
    <updated>2021-10-16T14:46:27.584Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="https://qinguohua.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://qinguohua.fun/tags/algorithm/"/>
    
      <category term="sort" scheme="https://qinguohua.fun/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 七 （SDWebImageTransition）</title>
    <link href="https://qinguohua.fun/2018/10/30/2018-10-30-Read-SDWebImage-SDWebImageTransition/"/>
    <id>https://qinguohua.fun/2018/10/30/2018-10-30-Read-SDWebImage-SDWebImageTransition/</id>
    <published>2018-10-30T13:32:19.000Z</published>
    <updated>2021-10-16T14:46:27.584Z</updated>
    
    <content type="html"><![CDATA[<p>该类用于在视图类别加载图像完成后提供过渡动画。 </p><ol><li><p>在<code>UIVit + WebCache.h</code> 中的 <code>sd_imageTransition</code> </p><p> 用于<code>UIKit(iOS和tvOS)</code>，使用<br>  <code>+ [UIView transitionWithView：duration：options：animations：completion]</code> 进行过渡动画。 </p></li><li><p>对于<code>AppKit(macOS)</code><br>使用 <code>+ [NSAnimationContext runAnimationGroup：completionHandler：]</code>进行过渡动画。 我们可以调用<code>+ [NSAnimationContext currentContext]</code>来获取动画块中的上下文。 提供这些转换以用于基本用途。 </p></li></ol><ol start="3"><li>如果需要复杂的动画，可以考虑直接使用<code>Core Animation</code>或使用<code>SDWebImageAvoidAutoSetImage</code>并实现自己的后映像加载完成。<a id="more"></a></li></ol><h3 id="动画选项"><a href="#动画选项" class="headerlink" title="动画选项"></a>动画选项</h3><p>分两种情况，如果是 SD_UIKIT 类型，就直接使用系统的动画选项，否则定义的枚举类型只有一种隐式动画</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT</span><br><span class="line">typedef UIViewAnimationOptions SDWebImageAnimationOptions;</span><br><span class="line">#else</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageAnimationOptions) &#123;</span><br><span class="line">    SDWebImageAnimationOptionAllowsImplicitAnimation = 1 &lt;&lt; 0, // specify `allowsImplicitAnimation` for the `NSAnimationContext`</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="三个block代码块"><a href="#三个block代码块" class="headerlink" title="三个block代码块"></a>三个block代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用于动画开始之前要执行的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionPreparesBlock)(__kindof UIView * _Nonnull view, UIImage * _Nullable image, NSData * _Nullable imageData, SDImageCacheType cacheType, NSURL * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//用于控制展示动画的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionAnimationsBlock)(__kindof UIView * _Nonnull view, UIImage * _Nullable image);</span><br><span class="line"></span><br><span class="line">//用于动画结束后要执行的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionCompletionBlock)(BOOL finished);</span><br></pre></td></tr></table></figure><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下，我们将图像设置为动画开头的视图。 您可以禁用此功能并提供自定义设置图像处理</span><br><span class="line">@property (nonatomic, assign) BOOL avoidAutoSetImage;</span><br><span class="line"></span><br><span class="line">//过渡动画的持续时间，以秒为单位。 默认为0.5。</span><br><span class="line">@property (nonatomic, assign) NSTimeInterval duration;</span><br><span class="line"></span><br><span class="line">//用于此过渡动画（macOS）中所有动画的计时功能。</span><br><span class="line">@property (nonatomic, strong, nullable) CAMediaTimingFunction *timingFunction NS_AVAILABLE_MAC(10_7);</span><br><span class="line"></span><br><span class="line">//一个动画选项</span><br><span class="line">@property (nonatomic, assign) SDWebImageAnimationOptions animationOptions;</span><br><span class="line"></span><br><span class="line">//动画开始前所要执行的代码块</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionPreparesBlock prepares;</span><br><span class="line"></span><br><span class="line">动画代码块</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionAnimationsBlock animations;</span><br><span class="line"></span><br><span class="line">//动画结束时要执行的代码块。</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionCompletionBlock completion;</span><br></pre></td></tr></table></figure><h3 id="Conveniences分类"><a href="#Conveniences分类" class="headerlink" title="Conveniences分类"></a>Conveniences分类</h3><p>创建过渡的便捷方式 如果需要，请记住指定持续时间。 对于UIKit，这些转换只使用对应的<code>animationOptions</code>。 默认情况下，我们启用<code>UIViewAnimationOptionAllowUserInteraction</code>以允许用户在转换期间进行交互。 对于AppKit，这些过渡在“动画”中使用了Core Animation。 因此，您的视图必须是图层支持的。 在应用之前设置<code>wantsLayer = YES</code>。</p><h4 id="公共属性和方法"><a href="#公共属性和方法" class="headerlink" title="公共属性和方法"></a>公共属性和方法</h4><p>调用不同的类属性获取不同的动画效果，如果类属性不可用，就调用类方法类获取不同的动画效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#if __has_feature(objc_class_property)</span><br><span class="line">/// 淡出过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *fadeTransition;</span><br><span class="line">/// 从左转换翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromLeftTransition;</span><br><span class="line">/// 从右转换翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromRightTransition;</span><br><span class="line">/// 从顶部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromTopTransition;</span><br><span class="line">/// 从底部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromBottomTransition;</span><br><span class="line">/// 卷起过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlUpTransition;</span><br><span class="line">/// 向下弯曲过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlDownTransition;</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">+ (nonnull instancetype)fadeTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromLeftTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromRightTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromTopTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromBottomTransition;</span><br><span class="line">+ (nonnull instancetype)curlUpTransition;</span><br><span class="line">+ (nonnull instancetype)curlDownTransition;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p><code>SDWebImageTransition</code> 只有一个初始化方法，设置了动画时间为0.5秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation SDWebImageTransition</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.duration = 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>SDWebImageTransition 分类中创建了不同的动画,这里区别了SD_UIKIT 和 其他。（即iOS 、tvOS、部分watchOS ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">+ (SDWebImageTransition *)fadeTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCrossDissolve | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionFade;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromLeftTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromLeft | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromLeft;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromRightTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromRight | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromRight;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromTopTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromTop | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromTop;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromBottomTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromBottom | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromBottom;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)curlUpTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCurlUp | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionReveal;</span><br><span class="line">        trans.subtype = kCATransitionFromTop;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)curlDownTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCurlDown | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionReveal;</span><br><span class="line">        trans.subtype = kCATransitionFromBottom;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该类用于在视图类别加载图像完成后提供过渡动画。 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;UIVit + WebCache.h&lt;/code&gt; 中的 &lt;code&gt;sd_imageTransition&lt;/code&gt; &lt;/p&gt;
&lt;p&gt; 用于&lt;code&gt;UIKit(iOS和tvOS)&lt;/code&gt;，使用&lt;br&gt;  &lt;code&gt;+ [UIView transitionWithView：duration：options：animations：completion]&lt;/code&gt; 进行过渡动画。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于&lt;code&gt;AppKit(macOS)&lt;/code&gt;&lt;br&gt;使用 &lt;code&gt;+ [NSAnimationContext runAnimationGroup：completionHandler：]&lt;/code&gt;进行过渡动画。 我们可以调用&lt;code&gt;+ [NSAnimationContext currentContext]&lt;/code&gt;来获取动画块中的上下文。 提供这些转换以用于基本用途。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;如果需要复杂的动画，可以考虑直接使用&lt;code&gt;Core Animation&lt;/code&gt;或使用&lt;code&gt;SDWebImageAvoidAutoSetImage&lt;/code&gt;并实现自己的后映像加载完成。
    
    </summary>
    
      <category term="SDWebImage手札" scheme="https://qinguohua.fun/categories/SDWebImage%E6%89%8B%E6%9C%AD/"/>
    
      <category term="Objective-C" scheme="https://qinguohua.fun/categories/SDWebImage%E6%89%8B%E6%9C%AD/Objective-C/"/>
    
    
      <category term="objc" scheme="https://qinguohua.fun/tags/objc/"/>
    
      <category term="sdwebimage" scheme="https://qinguohua.fun/tags/sdwebimage/"/>
    
  </entry>
  
</feed>
