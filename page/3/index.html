<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | 所念皆星辰 | 踏实、低调、前行。</title>

  
  <meta name="author" content="Wheat">
  

  
  <meta name="description" content="简单的一个技术博客，用来作为学习笔记和日常记录使用。">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="所念皆星辰"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="所念皆星辰" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">所念皆星辰</a>
    </h1>
    <p class="site-description">踏实、低调、前行。</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/24/Read-SDWebImage-SDWebImageGIFCoder/"><span>读 SDWebImage 六（编码器五：SDWebImageGIFCoder）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/24/Read-SDWebImage-SDWebImageGIFCoder/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-24T14:31:13.000Z">
          2018-10-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code> 和 <code>SDWebImageProgressiveCoder</code> ）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）。</p>
<p><code>SDWebImageImageIOCoder</code> ：内置编码器,该类遵守了 <code>SDWebImageCoder</code>协议，但并没有遵守 <code>SDWebImageProgressiveCoder</code>协议，说明该类仅针对git图片的编解码，并不支持git图片的逐行解码功能。
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/23/Read-SDWebImage-SDWebImageImageIOCoder/"><span>读 SDWebImage 六 （编码器四：SDWebImageImageIOCoder）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/23/Read-SDWebImage-SDWebImageImageIOCoder/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-23T13:57:30.000Z">
          2018-10-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p>
<p><code>SDWebImageImageIOCoder</code> ：内置编码器，支持PNG，JPEG，TIFF，支持逐行解码。该类遵守 <code>SDWebImageProgressiveCoder</code>协议。该协议也遵守<code>SDWebImageCoder</code>协议，所以这个类要实现这两个协议的方法。</p>
<p>  GIF<br>  还支持静态GIF（意思是只处理第一帧）。<br>  要获得完整的GIF支持，我们建议使用<code>FLAnimatedImage</code>或性能较差的<code>SDWebImageGIFCoder</code></p>
<p>  HEIC<br>  该编码器还支持HEIC格式，因为ImageIO本身支持它。但这取决于系统功能，因此无法在所有设备上运行。
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/18/Read-SDWebImage-SDWebImageCodersManager/"><span>读 SDWebImage 六 （编码器三：SDWebImageCodersManager）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/18/Read-SDWebImage-SDWebImageCodersManager/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-18T12:48:55.000Z">
          2018-10-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编解码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p>
<h3 id="编解码管理（-SDWebImageCodersManager-）"><a href="#编解码管理（-SDWebImageCodersManager-）" class="headerlink" title="编解码管理（ SDWebImageCodersManager ）"></a>编解码管理（ <code>SDWebImageCodersManager</code> ）</h3><p>编解码管理器，整体编解码器的入口，该类遵守了 <code>SDWebImageCoder</code> 协议，说明这个类可以提供基本的编解码功能 。编解码器数组是一个优先级队列，也意味着处理多个图片编解码任务时新添加的编解码器将具有最高优先级（即被先调用）
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/15/Read-SDWebImage-SDWebImageCoderHelper/"><span>读 SDWebImage  六 （编码器二：SDWebImageCoderHelper  以及动图处理使用到的 SDWebImageFrame）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/15/Read-SDWebImage-SDWebImageCoderHelper/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-15T13:52:22.000Z">
          2018-10-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p>
<p>本篇只做 <code>SDWebImageCoderHelper</code> 类的分析。该类作为辅助类，主要实现了两个功能：动图处理 和 图片方向处理。每个功能有两种方法，均为互逆方法。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/13/Read-SDWebImage-SDWebImageCoder/"><span>读 SDWebImage 六 （编码器一：SDWebImageCoder）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/13/Read-SDWebImage-SDWebImageCoder/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-13T13:15:04.000Z">
          2018-10-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p>
<p>本篇只做 <code>SDWebImageCoder</code> 的分析。 <code>SDWebImageCoder</code> 是编解码协议，包含两个协议：<code>SDWebImageCoder</code> 和 <code>SDWebImageProgressiveCoder</code>，两个协议定义了图片编解码类的接口。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/11/Read-SDWebImage-SDWebImageDownloaderOperation/"><span>读 SDWebImage 五 （SDWebImageDownloaderOperation）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/11/Read-SDWebImage-SDWebImageDownloaderOperation/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-11T09:58:01.000Z">
          2018-10-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>SDWebImage</code> 的图片下载是由 <code>SDWebImageDownloader</code> 类实现的，该类是一个异步下载管理器。主要工作是下载相关配置项的管理，包括下载队列的先后顺序、最大下载任务数量控制、下载队列中的任务创建、取消、暂停等任务管理，以及其他的 <code>HTTPS</code> 和 <code>HTTP Header</code> 的设置。</p>
<p>而真正实现图片下载的是 <code>SDWebImageDownloaderOperation</code> 类。该类的 <code>Operation</code> 操作依赖系统提供的 <code>NSURLConnection</code> 类来实现图片的下载。在 <code>SDWebImageDownloader</code> 类中，将图片的下载操作封装成了自定义的一个类 <code>SDWebImageDownloaderOperation</code> ，然后添加到了操作队列中。当操作队列调用这个操作时，会调用操作对象的 <code>- (void)start</code> 方法，在重写的这个方法中，生成了任务对象<code>dataTask</code>，并调用<code>resume</code>开始执行任务。<br>因为S<code>DWebImageDownloaderOperation</code>类遵守了<code>dataTask</code>对象的协议，所以<code>dataTask</code>执行的结果会通过代理方法进行回调。在代理方法中，获取并保存了服务器返回的数据，并在任务执行结束后，对数据进行解码、缩放和解压。处理完成后就进行回调。</p>
<p><strong>梳理</strong>：<br> <code>SDWebImageDownloaderOperation</code>是一个自定义、并行的 <code>NSOperation</code> 子类。这个子类主要实现的功能有：<br>由于只自定义的并行 <code>NSOperation</code>,所以需要管理 <code>executing</code> , <code>finished</code> 等各种属性的处理，并且手动触发KVO。<br>在 <code>- (void)start</code> 方法里面实现主要逻辑，在重写的这个方法中生成了任务对象<code>dataTask</code>，并调用<code>resume</code>开始执行任务。<br>在 <code>NSURLSessionTaskDelegate</code> 和 <code>NSURLSessionDataDelegate</code> 中处理数据的加载，以及进度Block的处理。<br>如果 <code>unownedSession</code> 属性因为某种原因是<code>nil</code>，则手动初始化一个做网络请求。<br>在代理方法中对认证、数据拼装、完成回调<code>Block</code>做处理。</p>
<p>通过发送 <code>SDWebImageDownloadStopNotification</code>,<br><code>SDWebImageDownloadFinishNotification</code>,<br><code>SDWebImageDownloadReceiveResponseNotification</code>, <code>SDWebImageDownloadStartNotification</code>来通知 <code>Operation</code> 的状态。</p>
<h3 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h3><p>四个通知，<code>SDWebImageDownloaderOperation</code> 在四种情况下会发送通知：</p>
<ol>
<li>开始下载</li>
<li>接收到数据</li>
<li>停止下载</li>
<li>结束下载</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadStartNotification;</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadReceiveResponseNotification;</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadStopNotification;</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadFinishNotification;</span><br></pre></td></tr></table></figure>
<h3 id="SDWebImageDownloaderOperationInterface协议"><a href="#SDWebImageDownloaderOperationInterface协议" class="headerlink" title="SDWebImageDownloaderOperationInterface协议"></a><code>SDWebImageDownloaderOperationInterface</code>协议</h3><p>如果想要实现一个自定义的下载操作，就必须继承自 <code>NSOperation</code> ,同时实现 <code>SDWebImageDownloaderOperationInterface</code> 这个协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageDownloaderOperationInterface&lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">//使用NSURLRequest,NSURLSession和SDWebImageDownloaderOptions初始化</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options;</span><br><span class="line"></span><br><span class="line">//可以为每一个NSOperation自由的添加相应对象</span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">//是否需要解压图片</span><br><span class="line">- (BOOL)shouldDecompressImages;</span><br><span class="line">//设置是否需要解压图片</span><br><span class="line">- (void)setShouldDecompressImages:(BOOL)value;</span><br><span class="line"></span><br><span class="line">//证书</span><br><span class="line">- (nullable NSURLCredential *)credential;</span><br><span class="line">//设置证书</span><br><span class="line">- (void)setCredential:(nullable NSURLCredential *)value;</span><br><span class="line"></span><br><span class="line">//取消token</span><br><span class="line">- (BOOL)cancel:(nullable id)token;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="属性声明-和-方法"><a href="#属性声明-和-方法" class="headerlink" title="属性声明 和 方法"></a>属性声明 和 方法</h3><p><code>SDWebImageDownloaderOperation</code> 遵守 <code>SDWebImageDownloaderOperationInterface</code>, <code>SDWebImageOperation</code>, <code>NSURLSessionTaskDelegate</code>, <code>NSURLSessionDataDelegate</code> 等协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作任务使用的请求。（外部只读）</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) NSURLRequest *request;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 操作任务（外部只读）</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) NSURLSessionTask *dataTask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//是否需要解压图片</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  用于确定URL连接是否应查询凭据存储以验证连接。</span><br><span class="line"> *  @deprecated Not used for a couple of versions</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) BOOL shouldUseCredentialStorage __deprecated_msg(&quot;Property deprecated. Does nothing. Kept only for backwards compatibility&quot;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The credential used for authentication challenges 在 `-URLSession:task:didReceiveChallenge:completionHandler:`中用于身份验证挑战的凭证.</span><br><span class="line"> *</span><br><span class="line"> * 如果存在请求URL的用户名或密码，则会覆盖此任何共享凭据。</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, nullable) NSURLCredential *credential;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * SDWebImageDownloaderOptions选项 （外部只读）</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic, readonly) SDWebImageDownloaderOptions options;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 预期的数据大小。</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSInteger expectedSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 操作任务返回的响应。</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLResponse *response;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  I初始化`SDWebImageDownloaderOperation` 对象</span><br><span class="line"> *</span><br><span class="line"> *  @see SDWebImageDownloaderOperation</span><br><span class="line"> *</span><br><span class="line"> *  @param request       URL请求</span><br><span class="line"> *  @param session       将运行此操作的URL会话</span><br><span class="line"> *  @param options       下载的选项</span><br><span class="line"> *</span><br><span class="line"> *  @return 初始化实例</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  添加处理程序以进行和完成。 返回可以传递给-cancel的tokent：取消这组回调。</span><br><span class="line"> *</span><br><span class="line"> *  @param progressBlock  当新的数据块到达时执行的块。</span><br><span class="line"> *                        @note 在后台队列上执行进度块</span><br><span class="line"> *  @param completedBlock 当下载完成时执行的代码块</span><br><span class="line"> *                        @note 已完成的代码块在主队列上执行以获得成功。如果发现错误，则代码块可能会在后台队列上执行</span><br><span class="line"> *</span><br><span class="line"> *  @return 用于取消这组处理程序的token</span><br><span class="line"> */</span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  取消一组回调. 一旦所有的回调被取消，该操作取消</span><br><span class="line"> *</span><br><span class="line"> *  @param token代表一组要取消的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 如果操作已停止，则为YES，因为这是要取消的最后一个token。 否则为NO。</span><br><span class="line"> */</span><br><span class="line">- (BOOL)cancel:(nullable id)token;</span><br></pre></td></tr></table></figure>
<h3 id="m文件"><a href="#m文件" class="headerlink" title=".m文件"></a>.m文件</h3><p>信号量实现锁机制，这种锁性能要比NSLock高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">#define UNLOCK(lock) dispatch_semaphore_signal(lock);</span><br></pre></td></tr></table></figure>
<p>静态全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//开始下载的通知</span><br><span class="line">NSString *const SDWebImageDownloadStartNotification = @&quot;SDWebImageDownloadStartNotification&quot;;</span><br><span class="line">//接受数据的通知</span><br><span class="line">NSString *const SDWebImageDownloadReceiveResponseNotification = @&quot;SDWebImageDownloadReceiveResponseNotification&quot;;</span><br><span class="line">//停止下载的通知</span><br><span class="line">NSString *const SDWebImageDownloadStopNotification = @&quot;SDWebImageDownloadStopNotification&quot;;</span><br><span class="line">//结束下载的通知</span><br><span class="line">NSString *const SDWebImageDownloadFinishNotification = @&quot;SDWebImageDownloadFinishNotification&quot;;</span><br><span class="line"></span><br><span class="line">//静态全局变量作为下载进度block字典存储的key</span><br><span class="line">static NSString *const kProgressCallbackKey = @&quot;progress&quot;;</span><br><span class="line">//静态全局变量作为结束下载block字典存储的key</span><br><span class="line">static NSString *const kCompletedCallbackKey = @&quot;completed&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//回调Block列表</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDCallbacksDictionary *&gt; *callbackBlocks;</span><br><span class="line"></span><br><span class="line">//自定义并行Operation需要管理的两个属性。默认是readonly的，我们这里通过声明改为可修改的。方便我们在后面操作。默认情况下_executing和finished都是NO</span><br><span class="line">//是否正在执行</span><br><span class="line">@property (assign, nonatomic, getter = isExecuting) BOOL executing;</span><br><span class="line">//是否结束</span><br><span class="line">@property (assign, nonatomic, getter = isFinished) BOOL finished;</span><br><span class="line">//图片数据</span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableData *imageData;</span><br><span class="line">//缓存数据</span><br><span class="line">@property (copy, nonatomic, nullable) NSData *cachedData; // for `SDWebImageDownloaderIgnoreCachedResponse`</span><br><span class="line"></span><br><span class="line">//通过SDWebImageDownloader传过来。所以这里是weak。因为他是通过SDWebImageDownloader管理的。</span><br><span class="line">@property (weak, nonatomic, nullable) NSURLSession *unownedSession;</span><br><span class="line"></span><br><span class="line">// 如果unownedSession是nil，我们需要手动创建一个并且管理他的生命周期和代理方法</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLSession *ownedSession;</span><br><span class="line"></span><br><span class="line">//dataTask对象</span><br><span class="line">@property (strong, nonatomic, readwrite, nullable) NSURLSessionTask *dataTask;</span><br><span class="line"></span><br><span class="line">//一个锁，以保持对`callbackBlocks`线程安全的访问</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t callbacksLock; // a lock to keep the access to `callbackBlocks` thread-safe</span><br><span class="line"></span><br><span class="line">//一个并行queue。用于控制数据的处理</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_queue_t coderQueue; // the queue to do image decoding</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">//如果用户设置了后台继续加载选线。则通过backgroundTask来继续下载图片</span><br><span class="line">@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundTaskId;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//图片解码器，有意思的是如果图片没有完全下载完成时也可以解码展示部分图片</span><br><span class="line">@property (strong, nonatomic, nullable) id&lt;SDWebImageProgressiveCoder&gt; progressiveCoder;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h4><p>编译器自动添加get和set方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@synthesize executing = _executing;</span><br><span class="line">@synthesize finished = _finished;</span><br></pre></td></tr></table></figure>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithRequest:nil inSession:nil options:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _request = [request copy];</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _options = options;</span><br><span class="line">        _callbackBlocks = [NSMutableArray new];</span><br><span class="line">        //默认情况下_executing和finished都是NO</span><br><span class="line">        _executing = NO;</span><br><span class="line">        _finished = NO;</span><br><span class="line">        _expectedSize = 0;</span><br><span class="line">        _unownedSession = session;</span><br><span class="line">        _callbacksLock = dispatch_semaphore_create(1);</span><br><span class="line">        _coderQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderOperationCoderQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给Operation添加进度和回调Block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 给Operation添加进度和回调Block</span><br><span class="line"> @param progressBlock 进度Block</span><br><span class="line"> @param completedBlock 回调Block</span><br><span class="line"> @return 回调字典</span><br><span class="line"> */</span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    //初始化一个回调Block列表                      </span><br><span class="line">    SDCallbacksDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">    //如果progressBlock 和 completedBlock 存在，就把Operation对应的回调和进度Block添加到回调Block列表中</span><br><span class="line">    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    [self.callbackBlocks addObject:callbacks];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    return callbacks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过key获取回调列表组</span><br><span class="line">- (nullable NSArray&lt;id&gt; *)callbacksForKey:(NSString *)key &#123;</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    NSMutableArray&lt;id&gt; *callbacks = [[self.callbackBlocks valueForKey:key] mutableCopy];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    // 我们需要删除[NSNull null]，因为每个回调可能并不总是有进度Block</span><br><span class="line">    [callbacks removeObjectIdenticalTo:[NSNull null]];</span><br><span class="line">    return [callbacks copy]; // strip mutability here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过token判断是否需要取消Opration</span><br><span class="line">- (BOOL)cancel:(nullable id)token &#123;</span><br><span class="line">    BOOL shouldCancel = NO;</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    //通过token移除对象</span><br><span class="line">    [self.callbackBlocks removeObjectIdenticalTo:token];</span><br><span class="line">    //如果self.callbackBlocks的count为0，则shouldCancel = YES</span><br><span class="line">    if (self.callbackBlocks.count == 0) &#123;</span><br><span class="line">        shouldCancel = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    //如果shouldCancel = YES，则执行取消操作</span><br><span class="line">    if (shouldCancel) &#123;</span><br><span class="line">        [self cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    return shouldCancel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="下载、取消、复位、完成等操作"><a href="#下载、取消、复位、完成等操作" class="headerlink" title="下载、取消、复位、完成等操作"></a>下载、取消、复位、完成等操作</h5><p>并行的Operation需要重写这个方法，在这个方法里面做具体的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    //加同步锁</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        //如果已经被设置为取消状态，就直接重新复位：将Operation从回调Block列表中移除，dataTask设置为nil，并将NSURLSession注销并取消（invalidateAndCancel）</span><br><span class="line">        if (self.isCancelled) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            [self reset];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        //查看是否能获取到UIApplication类</span><br><span class="line">        Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">        BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">        //如果有UIApplication类并设置了Background模式，则设置一个backgroundTask</span><br><span class="line">        if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">        //开始后台下载</span><br><span class="line">            __weak __typeof__ (self) wself = self;</span><br><span class="line">            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">            //后台下载任务结束，做清理工作（取消任务）</span><br><span class="line">                __strong __typeof (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">                if (sself) &#123;</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        //获取传入的网络会话对象</span><br><span class="line">        NSURLSession *session = self.unownedSession;</span><br><span class="line">        //如果SDWebImageDownloader传入的session是nil，则手动初始化一个session对象</span><br><span class="line">        if (!session) &#123;</span><br><span class="line">            NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">            //请求超时时间 15秒</span><br><span class="line">            sessionConfig.timeoutIntervalForRequest = 15;</span><br><span class="line">            session = [NSURLSession sessionWithConfiguration:sessionConfig</span><br><span class="line">                                                    delegate:self</span><br><span class="line">                                               delegateQueue:nil];</span><br><span class="line">            self.ownedSession = session;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果设置了忽略从NSURLCache中获取缓存的选项</span><br><span class="line">        if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</span><br><span class="line">            // 获取缓存的数据以供日后检查，不存在就初始化一个URLCache对象</span><br><span class="line">            NSURLCache *URLCache = session.configuration.URLCache;</span><br><span class="line">            if (!URLCache) &#123;</span><br><span class="line">                URLCache = [NSURLCache sharedURLCache];</span><br><span class="line">            &#125;</span><br><span class="line">            NSCachedURLResponse *cachedResponse;</span><br><span class="line">            // NSURLCache的 `cachedResponseForRequest:` 不是线程安全的，所以这里加了同步锁。 详情看（ https://developer.apple.com/documentation/foundation/nsurlcache#2317483）</span><br><span class="line">            @synchronized (URLCache) &#123;</span><br><span class="line">                cachedResponse = [URLCache cachedResponseForRequest:self.request];</span><br><span class="line">            &#125;</span><br><span class="line">            if (cachedResponse) &#123;</span><br><span class="line">                self.cachedData = cachedResponse.data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //生成NSURLSessionTask类对象</span><br><span class="line">        self.dataTask = [session dataTaskWithRequest:self.request];</span><br><span class="line">        //设置为正在执行状态</span><br><span class="line">        self.executing = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果NSURLSessionTask类对象存在</span><br><span class="line">    if (self.dataTask) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wunguarded-availability&quot;</span><br><span class="line">        //因为NSURLSessionTask的priority这个属性是iOS8.0以后才有的，所以要判断一下</span><br><span class="line">        if ([self.dataTask respondsToSelector:@selector(setPriority:)]) &#123;</span><br><span class="line">        //根据设置的选项设置优先级</span><br><span class="line">            if (self.options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">                self.dataTask.priority = NSURLSessionTaskPriorityHigh;</span><br><span class="line">            &#125; else if (self.options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">                self.dataTask.priority = NSURLSessionTaskPriorityLow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        //发送请求，开始执行任务</span><br><span class="line">        [self.dataTask resume];</span><br><span class="line">        //获取到进度回调代码块并调用</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(0, NSURLResponseUnknownLength, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">        //异步主队列发送下载开始通知</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果没有获取到NSURLSessionTask类对象，就回调错误并返回</span><br><span class="line">        [self callCompletionBlocksWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Task can&apos;t be initialized&quot;&#125;]];</span><br><span class="line">        [self done];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    //如果是后台任务，就关闭后台任务</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123;</span><br><span class="line">        UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:self.backgroundTaskId];</span><br><span class="line">        self.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取消Operation操作。</span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        [self cancelInternal];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">- (void)cancelInternal &#123;</span><br><span class="line">    //如果已经结束，返回</span><br><span class="line">    if (self.isFinished) return;</span><br><span class="line">    [super cancel];</span><br><span class="line">    //如果存在NSURLSessionTask类对象，就取消，并且异步主队列发送下载开始通知</span><br><span class="line">    if (self.dataTask) &#123;</span><br><span class="line">        [self.dataTask cancel];</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // As we cancelled the task, its callback won&apos;t be called and thus won&apos;t</span><br><span class="line">        // maintain the isFinished and isExecuting flags.</span><br><span class="line">        //更新执行状态和结束状态</span><br><span class="line">        if (self.isExecuting) self.executing = NO;</span><br><span class="line">        if (!self.isFinished) self.finished = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //复位</span><br><span class="line">    [self reset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//完成Operation操作</span><br><span class="line">- (void)done &#123;</span><br><span class="line">    //更新执行状态和结束状态</span><br><span class="line">    self.finished = YES;</span><br><span class="line">    self.executing = NO;</span><br><span class="line">     //复位</span><br><span class="line">    [self reset];</span><br><span class="line">&#125;</span><br><span class="line"> //复位</span><br><span class="line">- (void)reset &#123;</span><br><span class="line">    //删除回调block列表中所有的对象</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    [self.callbackBlocks removeAllObjects];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    //NSURLSessionTask类对象置为nil</span><br><span class="line">    self.dataTask = nil;</span><br><span class="line">    </span><br><span class="line">    //注销网络会话对象</span><br><span class="line">    if (self.ownedSession) &#123;</span><br><span class="line">        [self.ownedSession invalidateAndCancel];</span><br><span class="line">        self.ownedSession = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置结束状态</span><br><span class="line">- (void)setFinished:(BOOL)finished &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">    _finished = finished;</span><br><span class="line">    [self didChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置执行状态</span><br><span class="line">- (void)setExecuting:(BOOL)executing &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;isExecuting&quot;];</span><br><span class="line">    _executing = executing;</span><br><span class="line">    [self didChangeValueForKey:@&quot;isExecuting&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断Operation是否是并发</span><br><span class="line">- (BOOL)isConcurrent &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NSURLSessionDataDelegate"><a href="#NSURLSessionDataDelegate" class="headerlink" title="NSURLSessionDataDelegate"></a>NSURLSessionDataDelegate</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">//收到服务端响应，再一次请求中只会执行一次</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</span><br><span class="line">    //获取要下载图片的长度</span><br><span class="line">    NSInteger expected = (NSInteger)response.expectedContentLength;</span><br><span class="line">    expected = expected &gt; 0 ? expected : 0;</span><br><span class="line">    //设置当前expectedSize</span><br><span class="line">    self.expectedSize = expected;</span><br><span class="line">    //设置当前response</span><br><span class="line">    self.response = response;</span><br><span class="line">    </span><br><span class="line">    //根据状态代码判断氢气的状态</span><br><span class="line">    NSInteger statusCode = [response respondsToSelector:@selector(statusCode)] ? ((NSHTTPURLResponse *)response).statusCode : 200;</span><br><span class="line">    BOOL valid = statusCode &lt; 400;</span><br><span class="line">   </span><br><span class="line">    //&apos;304 Not Modified&apos;是一个特殊的。 如果没有缓存数据，则应将其视为已取消。</span><br><span class="line">    //当服务器响应304并且URLCache命中时，URLSession当前行为将返回200状态代码。 但这不是标准行为，我们只是添加一个检查</span><br><span class="line">    if (statusCode == 304 &amp;&amp; !self.cachedData) &#123;</span><br><span class="line">        valid = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果状态代码是有效的</span><br><span class="line">    if (valid) &#123;</span><br><span class="line">        //遍历进度回调块并触发进度block回调</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(0, expected, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 状态代码无效并标记为已取消。 不要调用`[self.dataTask cancel]` which may mass up URLSession life cycle</span><br><span class="line">        disposition = NSURLSessionResponseCancel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //异步主队列发送接受数据通知</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:weakSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //表示允许继续加载</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//每次收到数据都会触发， 可能多次调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    </span><br><span class="line">    //向可变数据中添加接收到的数据</span><br><span class="line">    if (!self.imageData) &#123;</span><br><span class="line">        self.imageData = [[NSMutableData alloc] initWithCapacity:self.expectedSize];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line"></span><br><span class="line">    //如果设置了SDWebImageDownloaderProgressiveDownload选项下载（即展示已经下载的部分,并expectedSize返回的图片size大于0）</span><br><span class="line">    if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0) &#123;</span><br><span class="line">        // 获得图片数据</span><br><span class="line">        __block NSData *imageData = [self.imageData copy];</span><br><span class="line">        // 获得下载的总字节数</span><br><span class="line">        const NSInteger totalSize = imageData.length;</span><br><span class="line">        // 获得结束的状态</span><br><span class="line">        BOOL finished = (totalSize &gt;= self.expectedSize);</span><br><span class="line">        </span><br><span class="line">        //如果图片解码器不存在</span><br><span class="line">        if (!self.progressiveCoder) &#123;</span><br><span class="line">            // 因为增量解码需要保留解码后的上下文，我们将为每个下载操作分配一个具有相同类的新实例，以避免冲突</span><br><span class="line">            for (id&lt;SDWebImageCoder&gt;coder in [SDWebImageCodersManager sharedInstance].coders) &#123;</span><br><span class="line">                if ([coder conformsToProtocol:@protocol(SDWebImageProgressiveCoder)] &amp;&amp;</span><br><span class="line">                    [((id&lt;SDWebImageProgressiveCoder&gt;)coder) canIncrementallyDecodeFromData:imageData]) &#123;</span><br><span class="line">                    self.progressiveCoder = [[[coder class] alloc] init];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 逐步解码编码器队列中的图像，自定义串行队列异步执行</span><br><span class="line">        dispatch_async(self.coderQueue, ^&#123;</span><br><span class="line">           //解码生成图片（增量解码图像数据到图像）</span><br><span class="line">            UIImage *image = [self.progressiveCoder incrementallyDecodedImageWithData:imageData finished:finished];</span><br><span class="line">             //如果图片存在，通过URL获取key，再对image进行缩放操作</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">                //image进行缩放操作</span><br><span class="line">                image = [self scaledImageForKey:key image:image];</span><br><span class="line">                //如果需要压缩图片，就执行压缩操作</span><br><span class="line">                if (self.shouldDecompressImages) &#123;</span><br><span class="line">                    image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(NO)&#125;];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //当`finished`=YES时，不再保留逐行解码图片。 因为它们用于视图渲染但不从下载器选项中获取全部功能。 并且一些编码器实现可能在逐行解码和正常解码之间不一致。</span><br><span class="line">                //进行完成回调</span><br><span class="line">                [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //回调进度</span><br><span class="line">    for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">        progressBlock(self.imageData.length, self.expectedSize, self.request.URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当NSURLSessionDataTask弯成接受所有预期数据后会调用这个代理方法，询问代理对象是否将响应存储在缓存中</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line"> willCacheResponse:(NSCachedURLResponse *)proposedResponse</span><br><span class="line"> completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    //获取缓存响应</span><br><span class="line">    NSCachedURLResponse *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    //如果设置了缓存选项（SDWebImageDownloaderUseNSURLCache），就回调缓存响应，否则就回调nil，不缓存</span><br><span class="line">    if (!(self.options &amp; SDWebImageDownloaderUseNSURLCache)) &#123;</span><br><span class="line">        // Prevents caching of responses</span><br><span class="line">        cachedResponse = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //调用完成代码块并传参</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NSURLSessionTaskDelegate-代理实现"><a href="#NSURLSessionTaskDelegate-代理实现" class="headerlink" title="NSURLSessionTaskDelegate 代理实现"></a>NSURLSessionTaskDelegate 代理实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">//当NSURLSessionTask已经完成传输数据时会调用这个代理方法</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">    //同步锁</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        //将保存任务对象的属性置为nil</span><br><span class="line">        self.dataTask = nil;</span><br><span class="line">        </span><br><span class="line">        //主队列异步发送下载停止通知，如果没有错误，发送下载结束通知</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">            if (!error) &#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:weakSelf];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果出错就回调错误，并调用完成方法</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        [self callCompletionBlocksWithError:error];</span><br><span class="line">        [self done];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果有完成回调的代码块</span><br><span class="line">        if ([self callbacksForKey:kCompletedCallbackKey].count &gt; 0) &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 如果您指定使用`NSURLCache`，那么您在此处获得的响应就是您所需要的。</span><br><span class="line">             */</span><br><span class="line">             //如果有下载的imageData</span><br><span class="line">            __block NSData *imageData = [self.imageData copy];</span><br><span class="line">            if (imageData) &#123;</span><br><span class="line">                /**  if you specified to only use cached data via `SDWebImageDownloaderIgnoreCachedResponse`,</span><br><span class="line">                 *  then we should check if the cached data is equal to image data</span><br><span class="line">                 */</span><br><span class="line">                 如果设置了忽略缓存响应选项（SDWebImageDownloaderIgnoreCachedResponse），并且缓存数据和下载的图片数据相同</span><br><span class="line">                if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; [self.cachedData isEqualToData:imageData]) &#123;</span><br><span class="line">                    //回调完成block nil，并调用完成方法</span><br><span class="line">                    [self callCompletionBlocksWithImage:nil imageData:nil error:nil finished:YES];</span><br><span class="line">                    [self done];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 在自定义串行异步执行</span><br><span class="line">                    dispatch_async(self.coderQueue, ^&#123;</span><br><span class="line">                      //对下载图片数据进行解码，通过imageData获取图片</span><br><span class="line">                        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:imageData];</span><br><span class="line">                        //获取图片url对应的key</span><br><span class="line">                        NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">                        //图片缩放操作</span><br><span class="line">                        image = [self scaledImageForKey:key image:image];</span><br><span class="line">                        //生成变量图片是否应该解码，</span><br><span class="line">                        BOOL shouldDecode = YES;</span><br><span class="line">                        // 如果是gif动态图片（图片组）就不需要解码</span><br><span class="line">                        if (image.images) &#123;</span><br><span class="line">                            shouldDecode = NO;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">#ifdef SD_WEBP              </span><br><span class="line">                            //如果是webp个事的也不需要解码</span><br><span class="line">                            SDImageFormat imageFormat = [NSData sd_imageFormatForImageData:imageData];</span><br><span class="line">                            if (imageFormat == SDImageFormatWebP) &#123;</span><br><span class="line">                                shouldDecode = NO;</span><br><span class="line">                            &#125;</span><br><span class="line">#endif</span><br><span class="line">                        &#125;</span><br><span class="line">                        //如果需要解码，执行解码操作</span><br><span class="line">                        if (shouldDecode) &#123;</span><br><span class="line">                            //是否需要解压图片，需要就执行解压操作</span><br><span class="line">                            if (self.shouldDecompressImages) &#123;</span><br><span class="line">                                //是否需要缩小图片</span><br><span class="line">                                BOOL shouldScaleDown = self.options &amp; SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">                                //解压操作</span><br><span class="line">                                image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //获取处理好的图片尺寸</span><br><span class="line">                        CGSize imageSize = image.size;</span><br><span class="line">                        //如果图片的宽或者长为0，就回调错误，否则回调完成block</span><br><span class="line">                        if (imageSize.width == 0 || imageSize.height == 0) &#123;</span><br><span class="line">                            [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloaded image has 0 pixels&quot;&#125;]];</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            //回调完成</span><br><span class="line">                            [self callCompletionBlocksWithImage:image imageData:imageData error:nil finished:YES];</span><br><span class="line">                        &#125;</span><br><span class="line">                        //调用完成方法</span><br><span class="line">                        [self done];</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //如果没有下载的图片数据，就回调错误，并执行完成方法</span><br><span class="line">                [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Image data is nil&quot;&#125;]];</span><br><span class="line">                [self done];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果没有完成回调代码块，直接执行完成方法</span><br><span class="line">            [self done];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当task接受到身份验证时，会回调这个代理方法</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    //设置临时变量保存数据</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line">    </span><br><span class="line">    //若验证方式为NSURLAuthenticationMethodServerTrust</span><br><span class="line">    if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">        //如果没有设置允许不可信的SSL证书，就设置蓄力方式为默认的NSURLSessionAuthChallengePerformDefaultHandling，否则就设置验证模式为指定证书验证，并生成证书</span><br><span class="line">        if (!(self.options &amp; SDWebImageDownloaderAllowInvalidSSLCertificates)) &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //若验证方式不是NSURLAuthenticationMethodServerTrust</span><br><span class="line">        if (challenge.previousFailureCount == 0) &#123;</span><br><span class="line">            //判断是否有证书，如果有就设置证书，验证模式为通过指定证书验证，否则就设置验证模式为不需要验证证书</span><br><span class="line">            if (self.credential) &#123;</span><br><span class="line">                credential = self.credential;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果认证的失败次数设置超过0次，就设置验证模式为不需要验证证书</span><br><span class="line">            disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //调用完成代码并传参</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Helper-methods"><a href="#Helper-methods" class="headerlink" title="Helper methods"></a>Helper methods</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//缩放操作</span><br><span class="line">- (nullable UIImage *)scaledImageForKey:(nullable NSString *)key image:(nullable UIImage *)image &#123;</span><br><span class="line">    return SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//是否允许app后台继续下载图片</span><br><span class="line">- (BOOL)shouldContinueWhenAppEntersBackground &#123;</span><br><span class="line">    return self.options &amp; SDWebImageDownloaderContinueInBackground;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//错误完成回调方法</span><br><span class="line">- (void)callCompletionBlocksWithError:(nullable NSError *)error &#123;</span><br><span class="line">    [self callCompletionBlocksWithImage:nil imageData:nil error:error finished:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//完成回调方法</span><br><span class="line">- (void)callCompletionBlocksWithImage:(nullable UIImage *)image</span><br><span class="line">                            imageData:(nullable NSData *)imageData</span><br><span class="line">                                error:(nullable NSError *)error</span><br><span class="line">                             finished:(BOOL)finished &#123;</span><br><span class="line">    NSArray&lt;id&gt; *completionBlocks = [self callbacksForKey:kCompletedCallbackKey];</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        for (SDWebImageDownloaderCompletedBlock completedBlock in completionBlocks) &#123;</span><br><span class="line">            completedBlock(image, imageData, error, finished);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/04/Read-SDWebImage-SDWebImageDownloader/"><span>读 SDWebImage 四 (SDWebImageDownloader)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/04/Read-SDWebImage-SDWebImageDownloader/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-04T11:38:50.000Z">
          2018-10-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>SDWebImage</code> 的图片下载是由 <code>SDWebImageDownloader</code> 这个类实现的，该类是一个异步下载管理器。主要工作是下载相关配置项的管理，包括下载队列的先后顺序、最大下载任务数量控制、下载队列中的任务创建、取消、暂停等任务管理，以及其他的 <code>HTTPS</code> 和 <code>HTTP Header</code> 的设置。而真正实现图片下载的是 <code>SDWebImageDownloaderOperation</code>类。该类的 <code>Operation</code> 操作依赖系统提供的NSURLConnection类来实现图片的下载。</p>
<h3 id="下载选项"><a href="#下载选项" class="headerlink" title="下载选项"></a>下载选项</h3><p>枚举列出不同的下载选项 （选项使用掩码形式，如 <code>1 &lt;&lt; 2</code> 表示将1左移2位，即：00000010，也就是2。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line"></span><br><span class="line">    //默认模式，将下载放入低优先级队列 和 低优先级任务中</span><br><span class="line">    SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 该选项启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。（该选项在返回进度Block的同时也返回completedBlock，里面的UIImage就是当前下载时的图片，可以实现将图片一点点显示出来的功能）</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，http请求会阻止使用NSURLCache。 使用此标志，NSURLCache将与默认策略一起使用。</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果从NSURLCache缓存中读取图片，则使用nil作为image/imageData的参数来调用block代码块。</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 在iOS 4+ 系统中，允许程序进入后台后继续下载图片，该操作通过向系统申请额外的时间来完成后台下载请求，如果后台任务终止，则操作被取消。</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过设置NSMutableURLRequest，HTTPShouldHandleCookies =  YES来处理存储在NSHTTPCookieStore中的cookie;</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *允许允许不受信任的SSL证书。用于测试目的。 在生产中谨慎使用。</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将下载放入高队列优先级和高任务优先级中。</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 缩小图像（默认情况下，图片会按照它的原始大小来解码显示。这个属性会根据设备的内存限制调整图片的尺寸到合适的大小。如果`SDWebImageProgressiveDownload`标记被设置了，则这个flag不起作用。）</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDownloaderScaleDownLargeImages = 1 &lt;&lt; 8,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="下载操作的执行顺序"><a href="#下载操作的执行顺序" class="headerlink" title="下载操作的执行顺序"></a>下载操作的执行顺序</h3><p>两种执行顺序： 先进先出 和 后进先出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 默认值。 所有下载操作都将以队列样式执行（先进先出）。</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDownloaderFIFOExecutionOrder,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所有下载操作都将以栈的方式执行（后进先出）。</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDownloaderLIFOExecutionOrder</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="外部定义的系统通知标示"><a href="#外部定义的系统通知标示" class="headerlink" title="外部定义的系统通知标示"></a>外部定义的系统通知标示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开始下载通知</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadStartNotification;</span><br><span class="line">//停止下载通知</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadStopNotification;</span><br></pre></td></tr></table></figure>
<h3 id="两个代码块"><a href="#两个代码块" class="headerlink" title="两个代码块"></a>两个代码块</h3><p>每个下载操作的下载进度回调和下载完成回调，这两个回调稍后将保存在下载管理器的URLCallbacks字典中，key为URL，value为一个数组，数组里面又存放一个保存了下载进度回调和完成回调代码块的字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//下载进度代码块</span><br><span class="line">typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL);</span><br><span class="line">//下载完成回调代码块</span><br><span class="line">typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, BOOL finished);</span><br></pre></td></tr></table></figure></p>
<h3 id="三个字典"><a href="#三个字典" class="headerlink" title="三个字典"></a>三个字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//请求头字典</span><br><span class="line">typedef NSDictionary&lt;NSString *, NSString *&gt; SDHTTPHeadersDictionary;</span><br><span class="line">typedef NSMutableDictionary&lt;NSString *, NSString *&gt; SDHTTPHeadersMutableDictionary;</span><br><span class="line"></span><br><span class="line">//自定义请求头，通过Block传值，可以拿到一些参数，然后加工成我们需要的数据，最后返回</span><br><span class="line">typedef SDHTTPHeadersDictionary * _Nullable (^SDWebImageDownloaderHeadersFilterBlock)(NSURL * _Nullable url, SDHTTPHeadersDictionary * _Nullable headers);</span><br></pre></td></tr></table></figure>
<h3 id="SDWebImageDownloadToken"><a href="#SDWebImageDownloadToken" class="headerlink" title="SDWebImageDownloadToken"></a>SDWebImageDownloadToken</h3><p>作为下载操作的唯一标识，在创建 <code>operation</code> 的时候初始化绑定，当需要去 <code>cancel</code> 操作的时候就需要这个 <code>token</code>。<br><code>SDWebImageDownloadToken</code> 为每一个下载任务的唯一身份标识，<code>SDWebImageDownloader</code> 和我们平时开发中的下载有一些不同，它弱化了下载过程，比较强调的是下载结果，不支持断点下载。</p>
<h4 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloadToken : NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">下载的URL。 这应该是只读的，你不应该修改</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, nullable) NSURL *url;</span><br><span class="line">/**</span><br><span class="line"> 取消token 可以从 “id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]” 方法获得，这应该是只读的，你不应该修改。</span><br><span class="line"> @note 使用 `-[SDWebImageDownloadToken cancel]`方法去取消下载token</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, nullable) id downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="m文件"><a href="#m文件" class="headerlink" title=".m文件"></a>.m文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloadToken ()</span><br><span class="line"></span><br><span class="line">//下载操作</span><br><span class="line">@property (nonatomic, weak, nullable) NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *downloadOperation;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SDWebImageDownloadToken</span><br><span class="line"></span><br><span class="line">//取消下载</span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    if (self.downloadOperation) &#123;</span><br><span class="line">        SDWebImageDownloadToken *cancelToken = self.downloadOperationCancelToken;</span><br><span class="line">        if (cancelToken) &#123;</span><br><span class="line">            [self.downloadOperation cancel:cancelToken];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="SDWebImageDownloader-h文件"><a href="#SDWebImageDownloader-h文件" class="headerlink" title="SDWebImageDownloader.h文件"></a>SDWebImageDownloader.h文件</h2><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解压缩下载和缓存的图像可以提高性能，但会占用大量内存。</span><br><span class="line"> * 默认是YES. 如果由于过多的内存消耗而遇到崩溃，可以设置为NO</span><br><span class="line"> */</span><br><span class="line"> //当图片下载完成以后，解码图片。如果因为过多的内存消耗导致一个奔溃，可以把这个属性设置为NO</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最大兵法下载数目</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSInteger maxConcurrentDownloads;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 显示仍需要下载的当前下载量</span><br><span class="line"> */</span><br><span class="line">@property (readonly, nonatomic) NSUInteger currentDownloadCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  下载操作的超时值（秒为单位），默认15秒</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval downloadTimeout;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 内部NSURLSession使用的配置</span><br><span class="line"> * 直接变换此对象无效</span><br><span class="line"> *</span><br><span class="line"> * @see createNewSessionWithConfiguration:</span><br><span class="line"> */</span><br><span class="line">@property (readonly, nonatomic, nonnull) NSURLSessionConfiguration *sessionConfiguration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 改变下载操作的执行顺序 默认值是 `SDWebImageDownloaderFIFOExecutionOrder`.</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) SDWebImageDownloaderExecutionOrder executionOrder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  设置要为请求操作设置的默认URL凭据。</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLCredential *urlCredential;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置用户名</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, nullable) NSString *username;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置密码</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, nullable) NSString *password;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置过滤器以选择用于下载图像HTTP请求的标头</span><br><span class="line"> *</span><br><span class="line"> * 将为每个下载图像请求调用此块，返回的NSDictionary将用作相应HTTP请求中的标头。</span><br><span class="line"> */</span><br><span class="line"> //http头部的过滤函数</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageDownloaderHeadersFilterBlock headersFilter;</span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">//下载管理器单例函数</span><br><span class="line">+ (nonnull instancetype)sharedDownloader;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用指定的会话配置创建下载程序的实例。（初始化方法）</span><br><span class="line"> * @note `timeoutIntervalForRequest` 将被覆盖</span><br><span class="line"> * @return 下载器的新事例</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置要附加到每个下载HTTP请求的HTTP标头的值。</span><br><span class="line"> *</span><br><span class="line"> * @param value The value for the header field. 值为 `nil` 移除请求头文件.</span><br><span class="line"> * @param field 设置http请求头部字段.</span><br><span class="line"> */</span><br><span class="line">- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(nullable NSString *)field;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回指定的HTTP标头字段的值。</span><br><span class="line"> *</span><br><span class="line"> * @return 与标题字段字段关联的值，如果没有相应的标题字段，则为“nil”。</span><br><span class="line"> */</span><br><span class="line">- (nullable NSString *)valueForHTTPHeaderField:(nullable NSString *)field;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * 将`SDWebImageDownloaderOperation`的子类设置为默认值</span><br><span class="line">  * 每次SDWebImage构造请求时都要使用`NSOperation`</span><br><span class="line">  * 下载图像的操作。</span><br><span class="line">  *</span><br><span class="line">  * @param operationClass要设置的`SDWebImageDownloaderOperation`的子类</span><br><span class="line">  *默认。 传递`nil`将恢复为`SDWebImageDownloaderOperation`。</span><br><span class="line">  */</span><br><span class="line">- (void)setOperationClass:(nullable Class)operationClass;</span><br><span class="line"></span><br><span class="line">/ **</span><br><span class="line">  * 使用给定的URL创建SDWebImageDownloader异步下载器实例</span><br><span class="line">  *</span><br><span class="line">  * 图像完成下载或发生错误时将通知代理。</span><br><span class="line">  *</span><br><span class="line">  * @see SDWebImageDownloaderDelegate</span><br><span class="line">  *</span><br><span class="line">  * @param url要下载的图像的URL</span><br><span class="line">  * @param options用于此下载的选项</span><br><span class="line">  * @param progressBlock在下载图像时重复调用的块</span><br><span class="line">  * @note在后台队列上执行进度块</span><br><span class="line">  * @param completedBlock下载完成后调用的块。</span><br><span class="line">  * 如果下载成功，则设置image参数，如果出错，</span><br><span class="line">  * 错误参数设置为错误。最后一个参数始终为YES</span><br><span class="line">  * 如果没有使用SDWebImageDownloaderProgressiveDownload。随着</span><br><span class="line">  * SDWebImageDownloaderProgressiveDownload选项，调用此块</span><br><span class="line">  * 重复使用部分图像对象，并将完成的参数设置为NO</span><br><span class="line">  * 之前用完整的图像和完成的参数调用最后一次</span><br><span class="line">  * 设为是。如果出错，则完成的参数始终为YES。</span><br><span class="line">  *</span><br><span class="line">  * @return可以传递给-cancel的令牌（SDWebImageDownloadToken）：取消此操作</span><br><span class="line">  * /</span><br><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 取消之前使用排队的下载 获取token使用 “-downloadImageWithURL:options:progress:completed:”方法</span><br><span class="line"> *</span><br><span class="line"> * @param token 从“-downloadImageWithURL:options:progress:completed:”方法获取的token应该被取消</span><br><span class="line"> */</span><br><span class="line">- (void)cancel:(nullable SDWebImageDownloadToken *)token;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置下载队列挂起状态</span><br><span class="line"> */</span><br><span class="line">- (void)setSuspended:(BOOL)suspended;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 取消队列中的所有下载操作</span><br><span class="line"> */</span><br><span class="line">- (void)cancelAllDownloads;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 强制SDWebImageDownloader 创建和使用一个给定配置的初始化NSURLSession（队列中的所有现有下载操作都将被取消；请求超时的时间也被重写）</span><br><span class="line"> *</span><br><span class="line"> * @param sessionConfiguration 使用新的NSURLSession配置</span><br><span class="line"> */</span><br><span class="line">- (void)createNewSessionWithConfiguration:(nonnull NSURLSessionConfiguration *)sessionConfiguration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * //取消operation并且session设置为Invalidates （如果您使用自定义下载程序而不是共享下载程序，则在不使用它时避免内存泄漏时需要调用此方法）</span><br><span class="line"> * @param cancelPendingOperations 是否取消挂起的操作。</span><br><span class="line"> * @note 在共享下载程序上调用此方法无效。</span><br><span class="line"> */</span><br><span class="line">- (void)invalidateSessionAndCancel:(BOOL)cancelPendingOperations;</span><br></pre></td></tr></table></figure>
<h2 id="SDWebImageDownloader-m文件"><a href="#SDWebImageDownloader-m文件" class="headerlink" title="SDWebImageDownloader.m文件"></a>SDWebImageDownloader.m文件</h2><h3 id="属性声明-1"><a href="#属性声明-1" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloader () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;</span><br><span class="line"></span><br><span class="line">//下载队列</span><br><span class="line">@property (strong, nonatomic, nonnull) NSOperationQueue *downloadQueue;</span><br><span class="line">//最新添加的操作</span><br><span class="line">@property (weak, nonatomic, nullable) NSOperation *lastAddedOperation;</span><br><span class="line">//操作的类</span><br><span class="line">@property (assign, nonatomic, nullable) Class operationClass;</span><br><span class="line">//下载操作的集合</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableDictionary&lt;NSURL *, SDWebImageDownloaderOperation *&gt; *URLOperations;</span><br><span class="line">//HTTP头文件集合</span><br><span class="line">@property (strong, nonatomic, nullable) SDHTTPHeadersMutableDictionary *HTTPHeaders;</span><br><span class="line">//操作锁</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t operationsLock; // a lock to keep the access to `URLOperations` thread-safe</span><br><span class="line">//头文件锁</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t headersLock; // a lock to keep the access to `HTTPHeaders` thread-safe</span><br><span class="line"></span><br><span class="line">// The session in which data tasks will run</span><br><span class="line">//NSURLSession</span><br><span class="line">@property (strong, nonatomic) NSURLSession *session;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h4><p><code>SDWebImageDownloader</code> 提供了一个initialize方法 四个初始化方法和一个注销方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">    //绑定SDNetworkActivityIndicator（如果可用），如果使用它，需要导入&quot;SDNetworkActivityIndicator.h&quot;头文件</span><br><span class="line">    //主要是用来加载图片的时候，状态栏会转小菊花。（该方法是为了给图片下载绑定一个SDNetworkActivityIndicator，只有当这个SDNetworkActivityIndicator文件存在的情况下才会执行，目的就是当下载图片时，状态栏会转小菊花。）</span><br><span class="line">    if (NSClassFromString(@&quot;SDNetworkActivityIndicator&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">//LLVM 3.0 编译器可以用以下代码消除 warning </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        id activityIndicator = [NSClassFromString(@&quot;SDNetworkActivityIndicator&quot;) performSelector:NSSelectorFromString(@&quot;sharedActivityIndicator&quot;)];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line"></span><br><span class="line">        // 如果之前已经添加，先移除观察者</span><br><span class="line">        [[NSNotificationCenter defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStartNotification object:nil];</span><br><span class="line">        [[NSNotificationCenter defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStopNotification object:nil];</span><br><span class="line">        </span><br><span class="line">        //添加观察者</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:NSSelectorFromString(@&quot;startActivity&quot;)</span><br><span class="line">                                                     name:SDWebImageDownloadStartNotification object:nil];</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:NSSelectorFromString(@&quot;stopActivity&quot;)</span><br><span class="line">                                                     name:SDWebImageDownloadStopNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//单例，返回SDWebImageDownloader对象</span><br><span class="line">+ (nonnull instancetype)sharedDownloader &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化一个请求对象</span><br><span class="line">- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation class];</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        _downloadQueue = [NSOperationQueue new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">        _downloadQueue.name = @&quot;com.hackemist.SDWebImageDownloader&quot;;</span><br><span class="line">        _URLOperations = [NSMutableDictionary new];</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/webp,image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#else</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#endif</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(1);</span><br><span class="line">        _headersLock = dispatch_semaphore_create(1);</span><br><span class="line">        _downloadTimeout = 15.0;</span><br><span class="line"></span><br><span class="line">        [self createNewSessionWithConfiguration:sessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化一个新的请求对象</span><br><span class="line">- (void)createNewSessionWithConfiguration:(NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    [self cancelAllDownloads];</span><br><span class="line"></span><br><span class="line">    if (self.session) &#123;</span><br><span class="line">        [self.session invalidateAndCancel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sessionConfiguration.timeoutIntervalForRequest = self.downloadTimeout;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  Create the session for this task</span><br><span class="line">     *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span><br><span class="line">     *  method calls and completion handler calls.</span><br><span class="line">     */</span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:sessionConfiguration</span><br><span class="line">                                                 delegate:self</span><br><span class="line">                                            delegateQueue:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///取消operation并且session设置为Invalidates</span><br><span class="line">- (void)invalidateSessionAndCancel:(BOOL)cancelPendingOperations &#123;</span><br><span class="line">    if (self == [SDWebImageDownloader sharedDownloader]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cancelPendingOperations) &#123;</span><br><span class="line">        [self.session invalidateAndCancel];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.session invalidateAndCancel];</span><br><span class="line">    self.session = nil;</span><br><span class="line"></span><br><span class="line">    [self.downloadQueue cancelAllOperations];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Set-和-Get-方法"><a href="#Set-和-Get-方法" class="headerlink" title="Set 和 Get 方法"></a><code>Set</code> 和 <code>Get</code> 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//设置请求报文头部</span><br><span class="line">- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(nullable NSString *)field &#123;</span><br><span class="line">    LOCK(self.headersLock);</span><br><span class="line">    if (value) &#123;</span><br><span class="line">        self.HTTPHeaders[field] = value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.HTTPHeaders removeObjectForKey:field];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.headersLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取请求报文头部</span><br><span class="line">- (nullable NSString *)valueForHTTPHeaderField:(nullable NSString *)field &#123;</span><br><span class="line">    if (!field) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return [[self allHTTPHeaderFields] objectForKey:field];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//全部的请求报文头部</span><br><span class="line">- (nonnull SDHTTPHeadersDictionary *)allHTTPHeaderFields &#123;</span><br><span class="line">    LOCK(self.headersLock);</span><br><span class="line">    SDHTTPHeadersDictionary *allHTTPHeaderFields = [self.HTTPHeaders copy];</span><br><span class="line">    UNLOCK(self.headersLock);</span><br><span class="line">    return allHTTPHeaderFields;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置下载队列的最大并发数</span><br><span class="line">- (void)setMaxConcurrentDownloads:(NSInteger)maxConcurrentDownloads &#123;</span><br><span class="line">    _downloadQueue.maxConcurrentOperationCount = maxConcurrentDownloads;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取下载队列的当前operation数</span><br><span class="line">- (NSUInteger)currentDownloadCount &#123;</span><br><span class="line">    return _downloadQueue.operationCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取下载队列的最大并发数</span><br><span class="line">- (NSInteger)maxConcurrentDownloads &#123;</span><br><span class="line">    return _downloadQueue.maxConcurrentOperationCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    return self.session.configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置一个`SDWebImageDownloaderOperation`的子类作为`NSOperation`来构建request来下载一张图片</span><br><span class="line">- (void)setOperationClass:(nullable Class)operationClass &#123;</span><br><span class="line">    if (operationClass &amp;&amp; [operationClass isSubclassOfClass:[NSOperation class]] &amp;&amp; [operationClass conformsToProtocol:@protocol(SDWebImageDownloaderOperationInterface)]) &#123;</span><br><span class="line">        _operationClass = operationClass;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation class];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下载方法"><a href="#下载方法" class="headerlink" title="下载方法"></a>下载方法</h4><p>下载管理器的主要实现为 <code>downloadImageWithURL:options:progress:completed:</code> 方法(调用该方法创建 <code>operation</code> 操作)，这个方法调用 <code>- (void)addProgressCallback:completedBlock:forURL: createCallback:</code> 方法来将请求的信息和一些回调函数存入管理器中，同时在创建回调的 <code>block</code> 中创建新 <code>operation</code> 操作,新的操作由管理器中存储的信息配置后，放入到 <code>downloadQueue</code> 操作队列中，最后返回新创建的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 下载图片</span><br><span class="line"> @param url 图片url</span><br><span class="line"> @param options 下载选项</span><br><span class="line"> @param progressBlock 下载进度blockhui</span><br><span class="line"> @param completedBlock 下载完成block</span><br><span class="line"> @return  返回一个SDWebImageDownloadToken，用于关联一个请求</span><br><span class="line">    调用addProgressCallback方法 return token，addProgressCallback的回调里进行以下操作</span><br><span class="line">    &#123;</span><br><span class="line">        1.1设置下载时间</span><br><span class="line">        1.2创建request</span><br><span class="line">        1.3创建operation对象 传入 request session options</span><br><span class="line">        1.4设置身份认证</span><br><span class="line">        1.5设置下载优先级</span><br><span class="line">        1.6设置下载顺序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __weak SDWebImageDownloader *wself = self;</span><br><span class="line">    // 调用- (void)addProgressCallback:completedBlock:forURL: createCallback:方法来将请求的信息和一些回调函数存入管理器中，同时在创建回调的block中创建新operation操作,新的操作由管理器中存储的信息配置后，放入到downloadQueue操作队列中，最后返回新创建的操作</span><br><span class="line">    return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</span><br><span class="line">        __strong __typeof (wself) sself = wself;</span><br><span class="line">        //获取超时时间，如果没有设置，默认为15秒</span><br><span class="line">        NSTimeInterval timeoutInterval = sself.downloadTimeout;</span><br><span class="line">        if (timeoutInterval == 0.0) &#123;</span><br><span class="line">            timeoutInterval = 15.0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 为了防止潜在的重复缓存（NSURLCache 和 SDImageCache同时缓存），如果另有说明，我们会禁用图像请求的缓存</span><br><span class="line">        NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line">        </span><br><span class="line">        //创建请求对象，并根据options参数设置其属性</span><br><span class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                                                    cachePolicy:cachePolicy</span><br><span class="line">                                                                timeoutInterval:timeoutInterval];</span><br><span class="line">        </span><br><span class="line">        //使用cookies</span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        //使用管道</span><br><span class="line">        request.HTTPShouldUsePipelining = YES;</span><br><span class="line">        //添加自定义请求头</span><br><span class="line">        if (sself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</span><br><span class="line">        &#125;</span><br><span class="line">        //初始化一个自定义NSOperation对象</span><br><span class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line">        //当图片下载完成以后，解码图片。如果因为过多的内存消耗导致一个奔溃，可以把这个属性设置为NO</span><br><span class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line">        </span><br><span class="line">        //指定验证信息（url证书）</span><br><span class="line">        if (sself.urlCredential) &#123;</span><br><span class="line">            operation.credential = sself.urlCredential;</span><br><span class="line">        &#125; else if (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">            //基础验证</span><br><span class="line">            operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //指定优先级</span><br><span class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //指定下载顺序（ 如果是LIFO这种模式，则需要手动指定operation之间的依赖关系）</span><br><span class="line">        if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            // 如果是LIFO，则让前面的operation依赖于最新添加的operation</span><br><span class="line">            [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">            sself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return operation;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取消一个图片的下载操作</span><br><span class="line">- (void)cancel:(nullable SDWebImageDownloadToken *)token &#123;</span><br><span class="line">    //如果url不存在，则返回</span><br><span class="line">    NSURL *url = token.url;</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取该操作，通过token来确定操作是否取消（移除），如果取消，则在URLOperations中移除url</span><br><span class="line">    LOCK(self.operationsLock);</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    if (operation) &#123;</span><br><span class="line">        BOOL canceled = [operation cancel:token.downloadOperationCancelToken];</span><br><span class="line">        if (canceled) &#123;</span><br><span class="line">            [self.URLOperations removeObjectForKey:url];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.operationsLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//给下载过程添加进度</span><br><span class="line">/**</span><br><span class="line">    1.生成URLOperations字典 下载url作为key value是具体的下载operation</span><br><span class="line">    2.将操作添加到操作队列中</span><br><span class="line">    3.将进度progressBlock和下载结束completedBlock封装成字典SDCallbacksDictionary，装入数组callbackBlocks，</span><br><span class="line">    4.生成token标识，并返回token</span><br><span class="line">*/</span><br><span class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(nullable NSURL *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123;</span><br><span class="line">    // url作为回调字典里的key，因此url不能为空，如果url为空则立即调用已完成代码块（image、imageData都传nil），并直接返回</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">        if (completedBlock != nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LOCK(self.operationsLock);</span><br><span class="line">    获取url下载的操作</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    // 有一种情况是操作可能被标记为已完成，但未从“self.URLOperations”中删除。</span><br><span class="line">    if (!operation || operation.isFinished) &#123;</span><br><span class="line">    //创建一个operation，并且添加到URLOperation中</span><br><span class="line">        operation = createCallback();</span><br><span class="line">        __weak typeof(self) wself = self;</span><br><span class="line">        </span><br><span class="line">        //设置operation操作完成以后的回调</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            __strong typeof(wself) sself = wself;</span><br><span class="line">            if (!sself) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            LOCK(sself.operationsLock);</span><br><span class="line">            //完成以后从URLOperations中移除该URL的operation操作</span><br><span class="line">            [sself.URLOperations removeObjectForKey:url];</span><br><span class="line">            UNLOCK(sself.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        //将该url的operation操作添加到URLOperations中</span><br><span class="line">        [self.URLOperations setObject:operation forKey:url];</span><br><span class="line"></span><br><span class="line">        //仅在根据Apple的doc完成所有配置后才将操作添加到操作队列。`addOperation：`不同步执行`operation.completionBlock`，所以这不会导致死锁。</span><br><span class="line">        //把operation添加进入NSOperationQueue中，当operation添加到downloadQueue，会触发相应的start方法，开始下载。</span><br><span class="line">        [self.downloadQueue addOperation:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.operationsLock);</span><br><span class="line"></span><br><span class="line">    //获取downloadOperationCancelToken</span><br><span class="line">    id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    </span><br><span class="line">    //创建一个新的token，给各属性赋值，并返回token</span><br><span class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.downloadOperation = operation;</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">    return token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置下载队列全部暂停/开始</span><br><span class="line">- (void)setSuspended:(BOOL)suspended &#123;</span><br><span class="line">    self.downloadQueue.suspended = suspended;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//全部取消下载队列中的下载操作</span><br><span class="line">- (void)cancelAllDownloads &#123;</span><br><span class="line">    [self.downloadQueue cancelAllOperations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark Helper methods</span><br><span class="line">//根据task获取下载操作operation</span><br><span class="line">- (SDWebImageDownloaderOperation *)operationWithTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    SDWebImageDownloaderOperation *returnOperation = nil;</span><br><span class="line">    for (SDWebImageDownloaderOperation *operation in self.downloadQueue.operations) &#123;</span><br><span class="line">        if (operation.dataTask.taskIdentifier == task.taskIdentifier) &#123;</span><br><span class="line">            returnOperation = operation;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return returnOperation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="NSURLSessionDataDelegate"><a href="#NSURLSessionDataDelegate" class="headerlink" title="NSURLSessionDataDelegate"></a>NSURLSessionDataDelegate</h4><p>当收到数据的时候，会触发这些代理方法，最后调用SDWebImageDownloaderOperation中的代理方法，来实际处理事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self operationWithTask:dataTask];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session dataTask:dataTask didReceiveResponse:response completionHandler:completionHandler];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line"></span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self operationWithTask:dataTask];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveData:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line"> willCacheResponse:(NSCachedURLResponse *)proposedResponse</span><br><span class="line"> completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self operationWithTask:dataTask];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:dataTask:willCacheResponse:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session dataTask:dataTask willCacheResponse:proposedResponse completionHandler:completionHandler];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionHandler) &#123;</span><br><span class="line">            completionHandler(proposedResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="NSURLSessionTaskDelegate"><a href="#NSURLSessionTaskDelegate" class="headerlink" title="NSURLSessionTaskDelegate"></a>NSURLSessionTaskDelegate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">    </span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self operationWithTask:task];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:task:didCompleteWithError:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self operationWithTask:task];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session task:task willPerformHTTPRedirection:response newRequest:request completionHandler:completionHandler];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionHandler) &#123;</span><br><span class="line">            completionHandler(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self operationWithTask:task];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:task:didReceiveChallenge:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session task:task didReceiveChallenge:challenge completionHandler:completionHandler];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/02/Read-SDWebImage-SDImageCache/"><span>读 SDWebImage 三 (SDImageCache)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/02/Read-SDWebImage-SDImageCache/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-02T02:38:36.000Z">
          2018-10-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p><code>SDImageCache</code> 是 <code>SDWebImage</code> 处理图片缓存的类。图片的存储是针对内存和磁盘有一点区别：内存中直接存储图片，磁盘中存中 <code>imagedata</code><br>在 <code>SDWebImageManager</code> 中使用的存储图片、判断图片是否已存储在磁盘/内存等方法均是调用该类中的方法。<code>SDWebImage</code> 设计时做了很好的分工，以至于去分析代码都带有一种享受感。</p>
<blockquote>
<p>简单做个思考，如果自己实现一个缓存类，需要做哪些东西：<br>1、初始化、缓存地址。<br>3、查询、删除、存储方法（增删改查功能）<br>4、计算缓存大小<br>5、计算缓存数量…</p>
</blockquote>
<p>然后在接下来的分析中看看跟自己的思路的偏差：</p>
<p>在 <code>SDImageCache</code> 的 <code>.h</code> 文件中引用了 <code>SDWebImageCompat</code> 和 <code>SDImageCacheConfig</code> 头文件。<code>SDWebImageCompat</code> 类在 <code>SDWebImageManager</code> 结尾已经分析过，该类只包含一个方法，用来实现图片缩放的操作。</p>
<p><code>SDImageCacheConfig</code> 类则是管理缓存配置信息的，这里先单独拉出来看下</p>
<h3 id="2、SDImageCacheConfig-类"><a href="#2、SDImageCacheConfig-类" class="headerlink" title="2、SDImageCacheConfig 类"></a>2、<code>SDImageCacheConfig</code> 类</h3><p><code>SDImageCacheConfig</code> 类是用于配置缓存信息的，继承自 <code>NSObject</code>。</p>
<h4 id="2-1、-h文件"><a href="#2-1、-h文件" class="headerlink" title="2.1、.h文件"></a>2.1、.h文件</h4><p>缓存配置过期类型，枚举<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, SDImageCacheConfigExpireType) &#123;</span><br><span class="line">    //访问图片时，它将更新此值 （访问日期）</span><br><span class="line">    SDImageCacheConfigExpireTypeAccessDate,</span><br><span class="line">    //图片从磁盘缓存中获取 （修改日期）</span><br><span class="line">    SDImageCacheConfigExpireTypeModificationDate</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义配置属性如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解压缩下载和缓存的图片可以提高性能，但会占用大量内存。</span><br><span class="line"> * 默认为YES。 如果由于过多的内存消耗而遇到崩溃，请将此项设置为NO。</span><br><span class="line"> */</span><br><span class="line">//是否解压图片，默认YES</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否禁用iCloud备份，默认YES</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDisableiCloud;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否使用内存缓存，默认YES</span><br><span class="line"> * 禁用内存缓存时，也会禁用弱内存缓存。</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 控制图片的弱内存缓存的选项.启用时, SDImageCache 的内存缓存将使用弱映射表在存储到内存的同时存储图像，并同时删除.</span><br><span class="line"> * 但是当触发内存警告时，由于弱映射表没有强烈的图像实例引用，即使内存缓存本身被清除，UIImageViews或其他实时实例强烈保留的一些图像也可以再次恢复，以避免 稍后从磁盘缓存或网络重新查询。 这可能对这种情况有所帮助，例如，当app进入后台并清除内存时，会在重新输入前景后导致单元格闪烁。</span><br><span class="line"> * 默认为YES。 您可以动态更改此选项。</span><br><span class="line"> */</span><br><span class="line">//是否使用弱内存缓存，默认为YES</span><br><span class="line">@property (assign, nonatomic) BOOL shouldUseWeakMemoryCache;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从磁盘读取缓存时的读取选项</span><br><span class="line"> * 默认为 0. 可以设置为 `NSDataReadingMappedIfSafe` 以提高性能.</span><br><span class="line"> */</span><br><span class="line">//磁盘缓存读取选项，枚举</span><br><span class="line">@property (assign, nonatomic) NSDataReadingOptions diskCacheReadingOptions;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将缓存写入磁盘时的写入选项</span><br><span class="line"> * 默认为 NSDataWritingAtomic. 可以将其设置为 `NSDataWritingWithoutOverwriting` 以防止覆盖现有文件</span><br><span class="line"> */</span><br><span class="line">//磁盘缓存写入选项，枚举</span><br><span class="line">@property (assign, nonatomic) NSDataWritingOptions diskCacheWritingOptions;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在缓存中保留图片的最长时间，秒为单位</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSInteger maxCacheAge;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 缓存的最大值，字节为单位，默认为0，表示不做限制</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxCacheSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 清理磁盘缓存时将检查清理缓存的属性</span><br><span class="line"> * 默认修改日期</span><br><span class="line"> */</span><br><span class="line">//缓存配置过期类型，枚举 ，默认修改日期</span><br><span class="line">@property (assign, nonatomic) SDImageCacheConfigExpireType diskCacheExpireType;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2、-m文件"><a href="#2-2、-m文件" class="headerlink" title="2.2、.m文件"></a>2.2、.m文件</h4><p>静态不可变 <code>NSInteger</code> 类型的 <code>kDefaultCacheMaxCacheAge</code> 表示在缓存中图像保存时间的最大长度，以秒为单位 默认是一周时间（60 ＊ 60 ＊ 24 ＊ 7）。<br><code>_maxCacheAge</code> 属性在 <code>.h</code> 中声明，可以外部修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</span><br><span class="line"></span><br><span class="line">//属性初始化赋值</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _shouldDisableiCloud = YES;</span><br><span class="line">        _shouldCacheImagesInMemory = YES;</span><br><span class="line">        _shouldUseWeakMemoryCache = YES;</span><br><span class="line">        _diskCacheReadingOptions = 0;</span><br><span class="line">        _diskCacheWritingOptions = NSDataWritingAtomic;</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line">        _maxCacheSize = 0;</span><br><span class="line">        _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、SDImageCache类"><a href="#3、SDImageCache类" class="headerlink" title="3、SDImageCache类"></a>3、<code>SDImageCache</code>类</h3><p><code>SDImageCache</code> 维护内存缓存和可选的磁盘缓存。磁盘缓存写入操作是异步执行的，因此不会给UI增加不必要的延迟。</p>
<h4 id="3-1、-h文件"><a href="#3-1、-h文件" class="headerlink" title="3.1、.h文件"></a>3.1、.h文件</h4><p><strong>缓存类型，枚举</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 图像不能用 SDWebImage 缓存，但能从网上下载 （不缓存）。</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line">    /**</span><br><span class="line">     * 图片从磁盘中获取（缓存到磁盘中）</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line">    /**</span><br><span class="line">     *图片从内存中获取（缓存到内存中）</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheTypeMemory</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>缓存选项，枚举</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDImageCacheOptions) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此选项可以强制同时查询磁盘数据。</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheQueryDataWhenInMemory = 1 &lt;&lt; 0,</span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此选项可以强制同步查询磁盘缓存。</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheQueryDiskSync = 1 &lt;&lt; 1,</span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，图像会根据其原始大小进行解码。在iOS上，此选项会将图像缩小到与设备的受限内存兼容的大小。</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheScaleDownLargeImages = 1 &lt;&lt; 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>三个回调代码块</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询完成的block</span><br><span class="line">typedef void(^SDCacheQueryCompletedBlock)(UIImage * _Nullable image, NSData * _Nullable data, SDImageCacheType cacheType);</span><br><span class="line"></span><br><span class="line">//检查完成的block</span><br><span class="line">typedef void(^SDWebImageCheckCacheCompletionBlock)(BOOL isInCache);</span><br><span class="line"></span><br><span class="line">//计算缓存大小的block</span><br><span class="line">typedef void(^SDWebImageCalculateSizeBlock)(NSUInteger fileCount, NSUInteger totalSize);</span><br></pre></td></tr></table></figure>
<p><strong>SDImageCache的属性 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  缓存配置对象，存储所有类型的设置</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCost;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 缓存应持有的对象的的最大数量。</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;</span><br></pre></td></tr></table></figure>
<p><strong>SDImageCache的单例和初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回全局共享缓存实例</span><br><span class="line"> *</span><br><span class="line"> * @return SDImageCache全局实例</span><br><span class="line"> */</span><br><span class="line">+ (nonnull instancetype)sharedImageCache;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用特定命名空间初始化一个新的缓存存储，里面就是去获取磁盘缓存路径，然后在进行一系列的初始化操作</span><br><span class="line"> *</span><br><span class="line"> * @param ns 用于此缓存存储的命名空间</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用特定的命名空间和目录初始化一个新的缓存存储</span><br><span class="line"> * @param ns 用于此缓存存储的命名空间</span><br><span class="line"> * @param directory 用于缓存磁盘映像的目录</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p><strong>缓存路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//初始化磁盘缓存路径</span><br><span class="line">- (nullable NSString *)makeDiskCachePath:(nonnull NSString*)fullNamespace;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 添加只读缓存路径用来搜索由SDImageCache预先缓存的图片</span><br><span class="line"> * 如果想要预先加载的图片和应用程序捆绑在一起，则非常有用。去找图片也可以在这个路径中添加</span><br><span class="line"> *</span><br><span class="line"> * @param path 此只读缓存路径使用的路径</span><br><span class="line"> */</span><br><span class="line">- (void)addReadOnlyCachePath:(nonnull NSString *)path;</span><br></pre></td></tr></table></figure>
<p><strong>存储操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> *</span><br><span class="line"> * @param image           需要缓存的图片</span><br><span class="line"> * @param key             唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param completionBlock 操作完成后执行的块</span><br><span class="line"> */</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> * （根据toDisk来判断是否要存储到磁盘中，这里的磁盘缓存是可选的）</span><br><span class="line"> * @param image           需要缓存的图片</span><br><span class="line"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param toDisk          是否缓存到磁盘中</span><br><span class="line"> * @param completionBlock 操作完成后执行的块</span><br><span class="line"> */</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> * （这里面的方法会根据imageData如果没有，但是image有的话，就会考虑到图片格式的问题）</span><br><span class="line"> * @param image         需要缓存的图片</span><br><span class="line"> * @param imageData     服务器返回的图像数据，此表示将用于磁盘存储，而不是将给定的图像对象转换为可存储/压缩的图像格式，以节省质量和CPU</span><br><span class="line"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param toDisk          是否缓存到磁盘中</span><br><span class="line"> * @param completionBlock 操作完成后执行的块</span><br><span class="line"> */</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据key将图片data同步缓存到内存和磁盘中</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * @param imageData  需要缓存的图片data</span><br><span class="line"> * @param key       唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> */</span><br><span class="line">- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key;</span><br></pre></td></tr></table></figure>
<p><strong>查询和检索操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  异步检查磁盘缓存中是否存在图片（不加载图片），回调返回结果</span><br><span class="line"> *</span><br><span class="line"> *  @param key             描述url的key</span><br><span class="line"> *  @param completionBlock 检查完成时要执行的块。</span><br><span class="line"> *  @note  将在主队列上始终执行完成块</span><br><span class="line"> */</span><br><span class="line">- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果</span><br><span class="line"> *</span><br><span class="line"> *  @param key             描述url的key</span><br><span class="line"> */</span><br><span class="line">- (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  根据key同步查询图片数据data</span><br><span class="line"> *</span><br><span class="line"> *  @param key 用来存储所需图片唯一的key</span><br><span class="line"> *  @return  根据key返回查找的图片，如果未找到，返回nil</span><br><span class="line"> */</span><br><span class="line">- (nullable NSData *)diskImageDataForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步查询缓存并在完成后调用完成的操作。</span><br><span class="line"> *</span><br><span class="line"> * @param key      用来存储所需图片唯一的key</span><br><span class="line"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span><br><span class="line"> *</span><br><span class="line"> * @return       包含缓存操作的NSOperation实例</span><br><span class="line"> */</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步查询缓存并在完成后调用完成的操作。</span><br><span class="line"> *</span><br><span class="line"> * @param key      用来存储所需图片唯一的key</span><br><span class="line"> * @param options  用于指定用于此高速缓存查询的选项</span><br><span class="line"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span><br><span class="line"> *</span><br><span class="line"> * @return     包含缓存操作的NSOperation实例</span><br><span class="line"> */</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 同步查询内存缓存</span><br><span class="line"> *</span><br><span class="line"> * @param key     用来存储所需图片唯一的key</span><br><span class="line"> * @return 根据key返回查找的图片，如果未找到，返回nil</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 同步查询磁盘缓存</span><br><span class="line"> *</span><br><span class="line"> * @param key 用来存储所需图片唯一的key</span><br><span class="line"> * @return 根据key返回查找的图片，如果未找到，返回nil</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 检查缓存后，同步查询缓存（磁盘或内存）</span><br><span class="line"> *</span><br><span class="line"> * @param key 用来存储所需图片唯一的key</span><br><span class="line"> * @return 根据key返回查找的图片，如果未找到，返回nil</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key;</span><br></pre></td></tr></table></figure>
<p><strong>移除操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从内存或者磁盘缓存中异步移除图片</span><br><span class="line"> *</span><br><span class="line"> * @param key            唯一的图片缓存key</span><br><span class="line"> * @param completion      删除图像后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从内存和可选磁盘缓存中异步移除图片</span><br><span class="line"> *</span><br><span class="line"> * @param key            唯一的图片缓存key</span><br><span class="line"> * @param fromDisk        是否也从磁盘中移除</span><br><span class="line"> * @param completion      删除图像后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br></pre></td></tr></table></figure>
<p><strong>缓存清理操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 清理所有的内存缓存图片</span><br><span class="line"> */</span><br><span class="line">- (void)clearMemory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步清除所有磁盘缓存的图片。 非阻塞方法 - 立即返回。</span><br><span class="line"> * @param completion   缓存过期完成后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line">- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步从磁盘中删除所有过期的缓存图片。 非阻塞方法 - 立即返回。</span><br><span class="line"> * @param completionBlock 缓存过期完成后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br></pre></td></tr></table></figure>
<p><strong>缓存信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取磁盘缓存使用的大小</span><br><span class="line"> */</span><br><span class="line">- (NSUInteger)getSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取磁盘缓存中的图片数量</span><br><span class="line"> */</span><br><span class="line">- (NSUInteger)getDiskCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步计算磁盘缓存的大小。</span><br><span class="line"> */</span><br><span class="line">- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock;</span><br></pre></td></tr></table></figure>
<p><strong>缓存路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  需要根路径和key来查询文件所在的位置 (需要缓存路径根文件夹）</span><br><span class="line"> *</span><br><span class="line"> *  @param key  the key (可以使用cacheKeyForURL从url获取)</span><br><span class="line"> *  @param path 缓存路径根文件夹</span><br><span class="line"> *</span><br><span class="line"> *  @return 缓存路径</span><br><span class="line"> */</span><br><span class="line">- (nullable NSString *)cachePathForKey:(nullable NSString *)key inPath:(nonnull NSString *)path;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  根据key获取相应文件的默认的缓存路径</span><br><span class="line"> *</span><br><span class="line"> *  @param key the key (可以使用cacheKeyForURL从url获取)</span><br><span class="line"> *</span><br><span class="line"> *  @return 默认的缓存路径</span><br><span class="line"> */</span><br><span class="line">- (nullable NSString *)defaultCachePathForKey:(nullable NSString *)key;</span><br></pre></td></tr></table></figure>
<h4 id="3-2、-m文件"><a href="#3-2、-m文件" class="headerlink" title="3.2、.m文件"></a>3.2、.m文件</h4><p>C语言函数，本质是计算diskImage所要占用的字节数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;</span><br><span class="line">#if SD_MAC</span><br><span class="line">    return image.size.height * image.size.width;</span><br><span class="line">#elif SD_UIKIT || SD_WATCH</span><br><span class="line">    return image.size.height * image.size.width * image.scale * image.scale;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>私有</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">// Private</span><br><span class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, nonnull) SDImageCacheConfig *config;</span><br><span class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; // strong-weak cache</span><br><span class="line">@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; // a lock to keep the access to `weakCache` thread-safe</span><br><span class="line"></span><br><span class="line">- (instancetype)init NS_UNAVAILABLE;</span><br><span class="line">- (instancetype)initWithConfig:(nonnull SDImageCacheConfig *)config;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SDMemoryCache</span><br><span class="line"></span><br><span class="line">目前这似乎没有用在macOS上（macOS使用虚拟内存，并且在内存警告时不清除缓存）。 所以我们只在iOS / tvOS平台上覆盖。</span><br><span class="line">//但是将来可能会有更多的子类选项和功能。</span><br><span class="line">#if SD_UIKIT</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    //移除内存警告通知</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // 使用存储二级缓存的强弱映射表。 按照NSCache不复制密钥的文档</span><br><span class="line">        // 当内存警告，缓存被清除时，这很有用。 但是，图像实例可以由其他实例保留，例如imageViews和alive。</span><br><span class="line">        // 在这种情况下，我们可以同步弱缓存，而不需要从磁盘缓存加载</span><br><span class="line">        self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class="line">        self.weakCacheLock = dispatch_semaphore_create(1);</span><br><span class="line">        self.config = config;</span><br><span class="line">        //添加内粗警告的通知</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(didReceiveMemoryWarning:)</span><br><span class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning:(NSNotification *)notification &#123;</span><br><span class="line">    //只删除缓存，但保持弱缓存</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// `setObject:forKey:` 只需调用0即可，覆盖这就足够了</span><br><span class="line">- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g &#123;</span><br><span class="line">    //调用系统的NSCache方法</span><br><span class="line">    [super setObject:obj forKey:key cost:g];</span><br><span class="line">    //如果缓存配置不使用弱内存缓存，返回</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &amp;&amp; obj) &#123;</span><br><span class="line">        //若果key和obj存在，存储弱缓存</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        [self.weakCache setObject:obj forKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过key获取object</span><br><span class="line">- (id)objectForKey:(id)key &#123;</span><br><span class="line">    id obj = [super objectForKey:key];</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &amp;&amp; !obj) &#123;</span><br><span class="line">        // 若果key存在，obj不存在，存储弱缓存</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        obj = [self.weakCache objectForKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">        if (obj) &#123;</span><br><span class="line">            //同步缓存</span><br><span class="line">            NSUInteger cost = 0;</span><br><span class="line">            if ([obj isKindOfClass:[UIImage class]]) &#123;</span><br><span class="line">                //diskImage所要占用的字节数</span><br><span class="line">                cost = SDCacheCostForImage(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            [super setObject:obj forKey:key cost:cost];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据key移除对象</span><br><span class="line">- (void)removeObjectForKey:(id)key &#123;</span><br><span class="line">    [super removeObjectForKey:key];</span><br><span class="line">    //如果缓存配置不使用弱内存缓存，返回</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        // 如果key存在，移除缓存</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        [self.weakCache removeObjectForKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//移除所有对象</span><br><span class="line">- (void)removeAllObjects &#123;</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">    //如果缓存配置不使用弱内存缓存，返回</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 手动删除也应该删除弱缓存</span><br><span class="line">    LOCK(self.weakCacheLock);</span><br><span class="line">    [self.weakCache removeAllObjects];</span><br><span class="line">    UNLOCK(self.weakCacheLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">//如果是macos，直接初始化</span><br><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><strong>属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCache ()</span><br><span class="line"></span><br><span class="line">#pragma mark - 属性</span><br><span class="line">//内存缓存</span><br><span class="line">@property (strong, nonatomic, nonnull) SDMemoryCache *memCache;</span><br><span class="line">//磁盘缓存路径</span><br><span class="line">@property (strong, nonatomic, nonnull) NSString *diskCachePath;</span><br><span class="line">//自定义路径</span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableArray&lt;NSString *&gt; *customPaths;</span><br><span class="line">@property (strong, nonatomic, nullable) dispatch_queue_t ioQueue;</span><br><span class="line">//文件管理器</span><br><span class="line">@property (strong, nonatomic, nonnull) NSFileManager *fileManager;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><strong>初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 单例, 初始化, dealloc</span><br><span class="line"></span><br><span class="line">+ (nonnull instancetype)sharedImageCache &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    //初始化，namespace 默认为：default</span><br><span class="line">    return [self initWithNamespace:@&quot;default&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns &#123;</span><br><span class="line">    //获取磁盘缓存路径，默认的是：~/default （ns为default，拼接到缓存路径的最后面）</span><br><span class="line">    NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">    return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line">        </span><br><span class="line">        // 创建IO串行队列</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        </span><br><span class="line">        //初始化缓存配置</span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        </span><br><span class="line">        // 初始化内存缓存</span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        // 初始化磁盘缓存</span><br><span class="line">        if (directory != nil) &#123;</span><br><span class="line">        //如果路径不为nil，在路径的结尾拼接fullNamespace</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           //如果路径为nil，获取路径</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            //初始化文件管理器</span><br><span class="line">            self.fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        //添加删除通知</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(deleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line"></span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缓存路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//添加只读缓存路径用来搜索由SDImageCache预先缓存的图片</span><br><span class="line">- (void)addReadOnlyCachePath:(nonnull NSString *)path &#123;</span><br><span class="line">    if (!self.customPaths) &#123;</span><br><span class="line">        self.customPaths = [NSMutableArray new];</span><br><span class="line">    &#125;</span><br><span class="line">    //不包含就添加</span><br><span class="line">    if (![self.customPaths containsObject:path]) &#123;</span><br><span class="line">        [self.customPaths addObject:path];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//需要根路径和key来查询文件所在的位置 (需要缓存路径根文件夹）</span><br><span class="line">- (nullable NSString *)cachePathForKey:(nullable NSString *)key inPath:(nonnull NSString *)path &#123;</span><br><span class="line">    //根据key获取缓存文件名</span><br><span class="line">    NSString *filename = [self cachedFileNameForKey:key];</span><br><span class="line">    return [path stringByAppendingPathComponent:filename];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据key获取默认缓存路径</span><br><span class="line">- (nullable NSString *)defaultCachePathForKey:(nullable NSString *)key &#123;</span><br><span class="line">    return [self cachePathForKey:key inPath:self.diskCachePath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据key获取缓存文件名</span><br><span class="line">- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key &#123;</span><br><span class="line">    const char *str = key.UTF8String;</span><br><span class="line">    if (str == NULL) &#123;</span><br><span class="line">        str = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</span><br><span class="line">                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]];</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据fullNamespace获取磁盘缓存路径</span><br><span class="line">- (nullable NSString *)makeDiskCachePath:(nonnull NSString*)fullNamespace &#123;</span><br><span class="line">    NSArray&lt;NSString *&gt; *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);</span><br><span class="line">    return [paths[0] stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>存储操作</strong></p>
<p>根据key将图片异步缓存到内存和磁盘中（默认存到内存和磁盘）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> *</span><br><span class="line"> * @param image           需要缓存的图片</span><br><span class="line"> * @param key             唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param completionBlock 操作完成后执行的块</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    [self storeImage:image imageData:nil forKey:key toDisk:YES completion:completionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key将图片异步缓存到内存和磁盘中 （默认存储到内存，根据判断是否存储到磁盘中）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> * （根据toDisk来判断是否要存储到磁盘中，这里的磁盘缓存是可选的）</span><br><span class="line"> * @param image           需要缓存的图片</span><br><span class="line"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param toDisk          是否缓存到磁盘中</span><br><span class="line"> * @param completionBlock 操作完成后执行的块</span><br><span class="line"> */</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    [self storeImage:image imageData:nil forKey:key toDisk:toDisk completion:completionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key将图片异步缓存到内存和磁盘中 （默认存储到内存，根据判断是否存储到磁盘）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> * （这里面的方法会根据imageData如果没有，但是image有的话，就会考虑到图片格式的问题）</span><br><span class="line"> * @param image         需要缓存的图片</span><br><span class="line"> * @param imageData     服务器返回的图像数据，此表示将用于磁盘存储，而不是将给定的图像对象转换为可存储/压缩的图像格式，以节省质量和CPU</span><br><span class="line"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param toDisk          是否缓存到磁盘中</span><br><span class="line"> * @param completionBlock 操作完成后执行的块  typedef void(^SDWebImageNoParamsBlock)(void); 不需要传任何参数</span><br><span class="line"> */ </span><br><span class="line"></span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    //若图片或者key不存在，则不存储，执行回调，返回</span><br><span class="line">    if (!image || !key) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果启用了内存缓存</span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        //根据key缓存image，</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //若需要缓存到磁盘</span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        //异步执行缓存操作</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            @autoreleasepool &#123; //自动释放池（里面创建了很多临时变量，当@autoreleasepool结束时，里面的内存就会回收）</span><br><span class="line">                NSData *data = imageData;</span><br><span class="line">                if (!data &amp;&amp; image) &#123;</span><br><span class="line">                    // 如果我们没有任何数据来检测图像格式，请检查它是否包含使用PNG或JPEG格式的Alpha通道</span><br><span class="line">                    SDImageFormat format;</span><br><span class="line">                    if (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</span><br><span class="line">                        format = SDImageFormatPNG;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        format = SDImageFormatJPEG;</span><br><span class="line">                    &#125;</span><br><span class="line">                    将图片编码为图片数据，该方法在SDWebImageCoder类中</span><br><span class="line">                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</span><br><span class="line">                &#125;</span><br><span class="line">                //根据key存储imageData</span><br><span class="line">                [self _storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //如果需要回调，在主线程执行回调</span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       //如果不存储磁盘，执行完成回调</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key将图片data同步缓存到磁盘中<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key将图片data同步缓存到内存和磁盘中</span><br><span class="line"> *</span><br><span class="line"> * @param imageData  需要缓存的图片data</span><br><span class="line"> * @param key       唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</span><br><span class="line">     //若图片或者key不存在，则不能存储</span><br><span class="line">    if (!imageData || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        [self _storeImageDataToDisk:imageData forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key将图片data同步缓存到内存和磁盘中（确保通过调用者调用表单io队列）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</span><br><span class="line">    //若图片或者key不存在，则不能存储</span><br><span class="line">    if (!imageData || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果文件管理器中不存在磁盘缓存的路径，则创建</span><br><span class="line">    if (![self.fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [self.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //通过key获取缓存路径</span><br><span class="line">    NSString *cachePathForKey = [self defaultCachePathForKey:key];</span><br><span class="line">    // 转换成 NSUrl</span><br><span class="line">    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line">    </span><br><span class="line">    //将图片写入fileURL中（options写入的选项，默认的配置为：NSDataWritingAtomic）</span><br><span class="line">    [imageData writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</span><br><span class="line">    </span><br><span class="line">    // 禁用iCloud备份</span><br><span class="line">    if (self.config.shouldDisableiCloud) &#123;</span><br><span class="line">        //NSURLIsExcludedFromBackupKey：如果应从备份中排除资源，则为true，否则为false（读写，值类型为boolean NSNumber）。 此属性仅用于排除备份中不需要的缓存和其他应用程序支持文件。 通常对用户文档执行的某些操作将导致此属性重置为false，因此不应在用户文档上使用此属性。</span><br><span class="line">        [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>查询和检索操作</strong></p>
<p>异步检查磁盘缓存中是否存在图片（不加载图片），回调返回结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  异步检查串行队列的磁盘缓存中是否存在图片（不加载图片），回调返回结果</span><br><span class="line"> *</span><br><span class="line"> *  @param key             描述url的key</span><br><span class="line"> *  @param completionBlock 检查完成时要执行的块。</span><br><span class="line"> *  @note  将在主队列上始终执行完成块</span><br><span class="line"> */</span><br><span class="line">- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        // 根据key判断磁盘中是否图片数据</span><br><span class="line">        BOOL exists = [self _diskImageDataExistsWithKey:key];</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            //如果回调代码存在，主线程执行完成查询的回调</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(exists);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果</span><br><span class="line"> *</span><br><span class="line"> *  @param key             描述url的key</span><br><span class="line"> */</span><br><span class="line">- (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    //如果key不存在，返回查询结果为NO ，否则同步根据key同步查询是否存在图片，返回结果</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    __block BOOL exists = NO;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        exists = [self _diskImageDataExistsWithKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key判断磁盘中是否存在图片数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)_diskImageDataExistsWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    //如果key不存在，返回查询结果为NO </span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    //key存在，则判断文件管理器中是否存在该key的缓存路径，如果存在返回，</span><br><span class="line">    BOOL exists = [self.fileManager fileExistsAtPath:[self defaultCachePathForKey:key]];</span><br><span class="line">    </span><br><span class="line">    // 如果不存在，进一步判断是否存在该key删除扩展名的缓存路径，返回判断结果</span><br><span class="line">    if (!exists) &#123;</span><br><span class="line">        //stringByDeletingPathExtension：从文件的最后一部分删除扩展名</span><br><span class="line">        exists = [self.fileManager fileExistsAtPath:[self defaultCachePathForKey:key].stringByDeletingPathExtension];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key同步查询图片数据data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSData *)diskImageDataForKey:(nullable NSString *)key &#123;</span><br><span class="line">     //如果key不存在，返回nil</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //根据key搜索所有的路径获取磁盘图片data</span><br><span class="line">    __block NSData *imageData = nil;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        imageData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key同步查询内存缓存图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    return [self.memCache objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key同步查询磁盘缓存图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    //根据key查询磁盘缓存图片，最终调用的是：- (UIImage *)diskImageForKey: data: options:这个方法</span><br><span class="line">    UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">    </span><br><span class="line">    //如果图片存在，并且需要缓存到内存中，则计算所占用字节数，并缓存到内存中</span><br><span class="line">    if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return diskImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>检查缓存后，同步查询缓存（磁盘或内存）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    // 先从内存中查询缓存图片，如果存在，结束查询并返回图片</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果内存中未查到该key的图片，则从磁盘中查询，返回最后查询的结果</span><br><span class="line">    image = [self imageFromDiskCacheForKey:key];</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key搜索所有的路径获取磁盘图片data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123;</span><br><span class="line">    //根据key获取默认的缓存路径</span><br><span class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</span><br><span class="line">    //self.config.diskCacheReadingOptions ：默认是0，即：NSDataReadingMappedIfSafe</span><br><span class="line">    //根据缓存路径和磁盘缓存读取选项，获取图片data，若存在则返回data，不存在则继续读取该key删除扩展名的缓存路径</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //读取该key删除扩展名的缓存路径，获取图片data，若存在则返回data</span><br><span class="line">    data = [NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    如果上面均未读取tupiandata，则依据上面的方法查找自定义路径，若存在返回data，如果仍未找到则返回nil</span><br><span class="line">    NSArray&lt;NSString *&gt; *customPaths = [self.customPaths copy];</span><br><span class="line">    for (NSString *path in customPaths) &#123;</span><br><span class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imageData = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key获取磁盘图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">缓存图片到磁盘是存储的imageData；到内存是存储的image。</span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key &#123;</span><br><span class="line">    //现获取imagedata，再转换成image</span><br><span class="line">    NSData *data = [self diskImageDataForKey:key];</span><br><span class="line">    return [self diskImageForKey:key data:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key和data得到磁盘图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data &#123;</span><br><span class="line">    return [self diskImageForKey:key data:data options:0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//最终调用的方法，根据key和data、选项获取磁盘图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data options:(SDImageCacheOptions)options &#123;</span><br><span class="line">    //如果图片的data存在，进行进一步的转换，否则返回nil</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        //将data转换成image</span><br><span class="line">        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];</span><br><span class="line">        //对图片进行缩放操作</span><br><span class="line">        image = [self scaledImageForKey:key image:image];</span><br><span class="line">        //如果需要解压缩操作，就进行其操作，否则直接返回图片</span><br><span class="line">        if (self.config.shouldDecompressImages) &#123;</span><br><span class="line">            //默认情况下，图像会根据其原始大小进行解码。在iOS上，此选项会将图像缩小到与设备的受限内存兼容的大小。</span><br><span class="line">            BOOL shouldScaleDown = options &amp; SDImageCacheScaleDownLargeImages;</span><br><span class="line">            /**</span><br><span class="line">              *- (nullable UIImage *)decompressedImageWithImage:(nullable UIImage *)image</span><br><span class="line">                                            data:(NSData * _Nullable * _Nonnull)data</span><br><span class="line">                                         options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict;</span><br><span class="line">              * 使用原始图像和图像数据解压缩图像。</span><br><span class="line">              *</span><br><span class="line">              * @param image要解压缩的原始图像</span><br><span class="line">              * @param data指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span><br><span class="line">              * @param optionsDict包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span><br><span class="line">              * @return解压缩的图像</span><br><span class="line">              */</span><br><span class="line">            </span><br><span class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//图片缩放操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)scaledImageForKey:(nullable NSString *)key image:(nullable UIImage *)image &#123;</span><br><span class="line">    return SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异步查询缓存并在完成后调用完成的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步查询缓存并在完成后调用完成的操作。</span><br><span class="line"> *</span><br><span class="line"> * @param key      用来存储所需图片唯一的key</span><br><span class="line"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span><br><span class="line"> *</span><br><span class="line"> * @return       包含缓存操作的NSOperation实例</span><br><span class="line"> */</span><br><span class="line">- (NSOperation *)queryCacheOperationForKey:(NSString *)key done:(SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    return [self queryCacheOperationForKey:key options:0 done:doneBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异步查询缓存并在完成后调用完成的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步查询缓存并在完成后调用完成的操作。</span><br><span class="line"> *</span><br><span class="line"> * @param key      用来存储所需图片唯一的key</span><br><span class="line"> * @param options  用于指定用于此高速缓存查询的选项</span><br><span class="line"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span><br><span class="line"> *</span><br><span class="line"> * @return     包含缓存操作的NSOperation实例</span><br><span class="line"> */</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    //如果key不存在，返回查询操作为nil，如果执行回调，则image，data传nil，类型传SDImageCacheTypeNone</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(nil, nil, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 先从内存中查找图片，</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</span><br><span class="line">    如果image存在，并且只从内存中查找，返回NSOperation为nil，，如果执行回调，则传image为查找的image，data传nil，类型传SDImageCacheTypeMemory</span><br><span class="line">    if (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, nil, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //创建一个NSOperation来获取磁盘图片</span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    void(^queryDiskBlock)(void) =  ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            // 如果操作被取消，则不执行回调</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //在自动释放池中执行，当@autoreleasepool结束时，里面的内存就会回收</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            //获取缓存data</span><br><span class="line">            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            UIImage *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                // 如果从内存中查找的image存在，赋值给diskImage，缓存类型为SDImageCacheTypeMemory</span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">            &#125; else if (diskData) &#123;</span><br><span class="line">                // 如果内存缓存未找到image，并且缓存data存在，通过diskData转换为image</span><br><span class="line">                diskImage = [self diskImageForKey:key data:diskData options:options];</span><br><span class="line">                if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                    //磁盘图片存在，并且需要缓存到内存，则做内存存储图片操作</span><br><span class="line">                    NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                    [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //完成回调存在，如果选项为：SDImageCacheQueryDiskSync（此选项可以强制同步查询磁盘缓存），则执行同步回调，否则在主线程执行回调</span><br><span class="line">            if (doneBlock) &#123;</span><br><span class="line">                if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    //如果选项为：SDImageCacheQueryDiskSync（此选项可以强制同步查询磁盘缓存），则执行同步执行上面的queryDiskBlock代码块，否则异步执行</span><br><span class="line">    if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">        queryDiskBlock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>移除操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从内存或者磁盘缓存中异步移除图片</span><br><span class="line"> *</span><br><span class="line"> * @param key            唯一的图片缓存key</span><br><span class="line"> * @param completion      删除图像后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    [self removeImageForKey:key fromDisk:YES withCompletion:completion];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line"> * 从内存和可选磁盘缓存中异步移除图片</span><br><span class="line"> *</span><br><span class="line"> * @param key            唯一的图片缓存key</span><br><span class="line"> * @param fromDisk        是否也从磁盘中移除</span><br><span class="line"> * @param completion      删除图像后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    //key为空，返回</span><br><span class="line">    if (key == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果缓存配置允许缓存到内存上，则需要在内存上也删除该key的缓存</span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        [self.memCache removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    //如果需要从磁盘上移除缓存，则执行磁盘移除缓存操作</span><br><span class="line">    if (fromDisk) &#123;</span><br><span class="line">        //异步执行移除磁盘缓存操作</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            [self.fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil];</span><br><span class="line">            </span><br><span class="line">            //主线程执行完成回调</span><br><span class="line">            if (completion) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completion();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (completion)&#123;</span><br><span class="line">        //执行完成回调</span><br><span class="line">        completion();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缓存清理操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">//清理缓存</span><br><span class="line">- (void)clearMemory &#123;</span><br><span class="line">    //清理所有内存缓存</span><br><span class="line">    [self.memCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异步清理磁盘缓存，回调结果</span><br><span class="line">- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        //删除该磁盘缓存路径，之后再重新创建一个作为新的缓存路径（其实就是同一个路径，目的就是删除缓存数据）</span><br><span class="line">        [self.fileManager removeItemAtPath:self.diskCachePath error:nil];</span><br><span class="line">        [self.fileManager createDirectoryAtPath:self.diskCachePath</span><br><span class="line">                withIntermediateDirectories:YES</span><br><span class="line">                                 attributes:nil</span><br><span class="line">                                      error:NULL];</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            //主线程执行完成回调</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completion();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除过期的文件</span><br><span class="line">- (void)deleteOldFiles &#123;</span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异步从磁盘中删除所有过期的缓存图片</span><br><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        //获取磁盘缓存的默认根目录</span><br><span class="line">        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">        // 计算用于测试的内容日期key</span><br><span class="line">        NSURLResourceKey cacheContentDateKey = NSURLContentModificationDateKey;</span><br><span class="line">        switch (self.config.diskCacheExpireType) &#123;</span><br><span class="line">            case SDImageCacheConfigExpireTypeAccessDate:</span><br><span class="line">                cacheContentDateKey = NSURLContentAccessDateKey;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case SDImageCacheConfigExpireTypeModificationDate:</span><br><span class="line">                cacheContentDateKey = NSURLContentModificationDateKey;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //记录遍历需要预先获取文件的哪些属性</span><br><span class="line">        NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, cacheContentDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">        // diskCacheURL 和 resourceKeys 这两个变量主要是为了下面生成NSDirectoryEnumerator准备的</span><br><span class="line">        //此枚举器为我们的缓存文件预取有用的属性。</span><br><span class="line">        /**</span><br><span class="line">          * 递归地遍历diskCachePath这个文件夹中的所有目录，此处不是直接使用diskCachePath，而是使用其生成的NSURL</span><br><span class="line">          * 此处使用includingPropertiesForKeys:resourceKeys，这样每个file的resourceKeys对应的属性也会在遍历时预先获取到</span><br><span class="line">          * NSDirectoryEnumerationSkipsHiddenFiles表示不遍历隐藏文件</span><br><span class="line">          */</span><br><span class="line"></span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">          * 获取文件的过期时间，SDWebImage中默认是一个星期</span><br><span class="line">          * expirationDate为过期时间，例如：现在时间是2018/10/16/00:00:00，当前时间减去1个星期，得到</span><br><span class="line">          * 2018/10/09/00:00:00，这个时间为函数中的expirationDate</span><br><span class="line">          * 用这个expirationDate和最后一次修改时间modificationDate比较看谁更晚就行</span><br><span class="line">          */</span><br><span class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge];</span><br><span class="line">        //用来存储对应文件的一些属性，比如文件所需磁盘空间</span><br><span class="line">        NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">        //记录党建已经使用的磁盘缓存大小</span><br><span class="line">        NSUInteger currentCacheSize = 0;</span><br><span class="line"></span><br><span class="line">        // 在缓存的目录开始遍历文件.  此次遍历有两个目的:</span><br><span class="line">        //  1. 移除过期的文件</span><br><span class="line">        //  2. 同时存储每个文件的属性（比如该file是否是文件夹、该file所需磁盘大小，修改时间）</span><br><span class="line">        NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSError *error;</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</span><br><span class="line"></span><br><span class="line">            // 当前扫描的是目录，就跳过</span><br><span class="line">            if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 移除过期文件(这里判断过期的方式：对比文件的最后一次修改日期和expirationDate谁更晚，如果expirationDate更晚，就认为该文件已经过期)</span><br><span class="line">            NSDate *modifiedDate = resourceValues[cacheContentDateKey];</span><br><span class="line">            if ([[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 计算当前已经使用的cache大小,并将对应file的属性存到cacheFiles中</span><br><span class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">            cacheFiles[fileURL] = resourceValues;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 根据需要移除文件的url来移除对应file</span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">            [self.fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         // 如果我们当前cache的大小已经超过了允许配置的缓存大小，那就删除已经缓存的文件</span><br><span class="line">         // 删除策略就是，首先删除修改时间更早的缓存文件</span><br><span class="line">        if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123;</span><br><span class="line">            // 直接将当前cache大小降到允许最大的cache大小的一般</span><br><span class="line">            //预期的缓存大小</span><br><span class="line">            const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;</span><br><span class="line"></span><br><span class="line">             // 根据文件修改时间来给所有缓存文件排序，按照修改时间越早越在前的规则排序</span><br><span class="line">            NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</span><br><span class="line">                                                                     usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">                                                                         return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">                                                                     &#125;];</span><br><span class="line"></span><br><span class="line">             // 每次删除file后，就计算此时的cache的大小.</span><br><span class="line">            //如果此时的cache大小已经降到期望的大小了，就停止删除文件了</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">                if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123;</span><br><span class="line">                    // 获取该文件对应的属性</span><br><span class="line">                    NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    // 根据resourceValues获取该文件所需磁盘空间大小</span><br><span class="line">                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                    // 计算当前cache大小</span><br><span class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line"></span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        如果当前的缓存小于预期的缓存，结束删除file操作</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 如果有completionBlock，就在主线程中调用</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">//后台删除过期文件</span><br><span class="line">- (void)backgroundDeleteOldFiles &#123;</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">    //如果backgroundTask对应的时间结束了，任务还没有处理完成，则直接终止任务</span><br><span class="line">    __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        //通过标记您的位置来清理任何未完成的任务业务</span><br><span class="line">        //完全停止或结束任务。</span><br><span class="line">        //当任务非正常终止的时候，做清理工作</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 启动长时间运行的任务并立即返回。</span><br><span class="line">    //图片清理结束以后，处理完成</span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:^&#123;</span><br><span class="line">        //清理完成以后，终止任务</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><strong>缓存信息</strong></p>
<p>获取磁盘缓存使用的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getSize &#123;</span><br><span class="line">    __block NSUInteger size = 0;</span><br><span class="line">    // 需要同步操作：等待队列self.ioQueue中的任务执行完后（有可能队列中的任务正在添加图片或者删除图片操作），再进行获取文件大小计算</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        for (NSString *fileName in fileEnumerator) &#123;</span><br><span class="line">            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *attrs = [self.fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取磁盘缓存中的图片数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getDiskCount &#123;</span><br><span class="line">    __block NSUInteger count = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        count = fileEnumerator.allObjects.count;</span><br><span class="line">    &#125;);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步计算磁盘缓存的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock &#123;</span><br><span class="line">    NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSUInteger fileCount = 0;</span><br><span class="line">        NSUInteger totalSize = 0;</span><br><span class="line"></span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:@[NSFileSize]</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSNumber *fileSize;</span><br><span class="line">            [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL];</span><br><span class="line">            totalSize += fileSize.unsignedIntegerValue;</span><br><span class="line">            fileCount += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(fileCount, totalSize);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>属性Get和Set方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span><br><span class="line">- (NSUInteger)maxMemoryCost &#123;</span><br><span class="line">    return self.memCache.totalCostLimit;</span><br><span class="line">&#125;</span><br><span class="line">//设置缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span><br><span class="line">- (void)setMaxMemoryCost:(NSUInteger)maxMemoryCost &#123;</span><br><span class="line">    self.memCache.totalCostLimit = maxMemoryCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//缓存应持有的对象的的最大数量</span><br><span class="line">- (NSUInteger)maxMemoryCountLimit &#123;</span><br><span class="line">    return self.memCache.countLimit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置缓存应持有的对象的的最大数量</span><br><span class="line">- (void)setMaxMemoryCountLimit:(NSUInteger)maxCountLimit &#123;</span><br><span class="line">    self.memCache.countLimit = maxCountLimit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/01/Read-SDWebImage-SDWebImageManager/"><span>读SDWebImage 二 (SDWebImageManager)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/01/Read-SDWebImage-SDWebImageManager/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-01T01:38:06.000Z">
          2018-10-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1、整体框架"><a href="#1、整体框架" class="headerlink" title="1、整体框架"></a>1、整体框架</h2><p>看下整体的框架图：<br><img src="http://blog.guohuaden.com/SDWebImageClassDiagram.png" alt="SDWebImage框架"><br>从图中可以更清晰的看出，<code>SDWebImage</code>库是围绕<code>SDWebImageManager</code>、<code>SDWebImageCache</code>、<code>SDWebImageDownloader</code>三个类展开的，而这三个类又是以<code>SDWebImageManager</code>作为核心类。</p>
<p>下面就重点分析<code>SDWebImageManager</code>：<br><code>SDWebImageManager</code>是 <code>SDWebImage</code> 的管理以及操作类。也是<code>SDWebImage</code>的核心类，拥有一个<code>SDWebImageCache</code> 和 <code>SDWebImageDownloader</code> 属性，分别用于图片缓存和下载处理。</p>
<h2 id="2、SDWebImageManager类分析"><a href="#2、SDWebImageManager类分析" class="headerlink" title="2、SDWebImageManager类分析"></a>2、<code>SDWebImageManager</code>类分析</h2><h3 id="先看下-h文件"><a href="#先看下-h文件" class="headerlink" title="先看下.h文件"></a>先看下.h文件</h3><h3 id="2-1、公共枚举"><a href="#2-1、公共枚举" class="headerlink" title="2.1、公共枚举"></a>2.1、公共枚举</h3><p>该枚举定义了图像加载的可选项:<br><strong>options 选项（枚举类型）</strong></p>
<blockquote>
<p><code>SDWebImageRetryFailed = 1 &lt;&lt; 0,</code><br>默认情况下当通过URL下载图片失败后，该URL就被加入黑名单，之后SDWebImage不会再去尝试下载。此标志作用就是禁用该黑名单，也就是说使用SDWebImageRetryFailed后，图片下载失败仍会尝试下载</p>
<p><code>SDWebImageLowPriority = 1 &lt;&lt; 1,</code><br>默认情况下图片在UI交互期间下载，此标志的作用就是禁用该功能。例如：在UIScrollView减速时导致延迟下载。</p>
<p><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</code><br>此标志作用是：图片下载完成后仅缓存到内存，不缓存在磁盘上</p>
<p><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</code><br>此标志作用是：图片下载完成后仅缓存到内存，不缓存在磁盘上</p>
<p><code>SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</code><br>此标志启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。<br>默认情况下，图像仅在完全下载后显示。</p>
<p><code>SDWebImageRefreshCached = 1 &lt;&lt; 4,</code><br>即使缓存中存在该图片，也尊重HTTP响应缓存控制，在需要时从远程刷新图片。<br>磁盘缓存将由 <code>NSURLCache</code> 替代 <code>SDWebImage</code> 去处理，这样也将导致性能略有下降。<br>该选项有助于处理同一个URL请求但更换图片的情况，例如Facebook图形api配置文件的图片。<br>如果刷新了缓存图片，则使用缓存图片调用一次完成block代码块，再使用最终的图片调用完成block代码块。<br>仅当你无法使用嵌入式缓存清除参数使URL保持静态时，才使用该标志。</p>
<p><code>SDWebImageContinueInBackground = 1 &lt;&lt; 5,</code><br>在<code>iOS 4+</code>中，如果app进入后台也继续下载图片，这是通过询问系统实现的。<br>在后台有额外的时间让请求完成，如果后台任务到期，则操作被取消。</p>
<p><code>SDWebImageHandleCookies = 1 &lt;&lt; 6,</code><br>通过<code>NSMutableURLRequest.HTTPShouldHandleCookies = YES</code>设置处理在 <code>NSHTTPCookieStore</code>中的cookies。</p>
<p><code>SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</code><br>启用允许不受信任的SSL证书（用于测试目的，在生产中谨慎使用）</p>
<p><code>SDWebImageHighPriority = 1 &lt;&lt; 8,</code><br>默认情况下，图像按其排队顺序加载，此标志将它们移动到队列的前面</p>
<p><code>SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</code><br>默认情况下，加载图像时会加载占位符。 此标志将延迟加载占位符图像，直到图像加载完毕。</p>
<p><code>SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</code><br>我们通常不会在动画图像上调用transformDownloadedImage委托方法，因为大多数转换代码会破坏它。如果使用必须使用此标志来转换它们。</p>
<p><code>SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</code><br>默认情况下，下载后会将图像添加到imageView。 但在某些情况下，我们想要<br>在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志</p>
<p><code>SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</code><br>默认情况下，图像会根据其原始大小进行解码。 在iOS上，此标志将缩小图像尺寸与设备的受限内存兼容。（如果设置了“SDWebImageProgressiveDownload”标志，则停用缩小比例。）</p>
<p><code>SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</code><br>默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此掩码可以强制同时查询磁盘数据。<br>建议将此标志与<code>SDWebImageQueryDiskSync</code>一起使用，以确保图像在同一个runloop中加载。</p>
<p><code>SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</code><br>默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此掩码可以强制同步查询磁盘缓存，以确保在同一个runloop中加载映像。<br>如果禁用内存缓存或在某些其他情况下，此标志可以避免在单元重用期间闪烁。</p>
<p><code>SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</code><br>默认情况下，当缓存丢失时，将从网络下载映像。此标志可以阻止网络仅从缓存加载。</p>
<p><code>SDWebImageForceTransition = 1 &lt;&lt; 16</code><br>默认情况下，当您使用 <code>SDWebImageTransition</code> 在图像加载完成后进行某些视图转换时，此转换仅适用于从网络下载图像。 此掩码也可以强制为内存和磁盘缓存应用视图转换。</p>
</blockquote>
<h3 id="2-2、公共类型定义"><a href="#2-2、公共类型定义" class="headerlink" title="2.2、公共类型定义"></a>2.2、公共类型定义</h3><p>四个回调代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//用于外部分类中完成回调的block</span><br><span class="line">typedef void(^SDExternalCompletionBlock)(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//用于该类内部完成回调的block</span><br><span class="line">typedef void(^SDInternalCompletionBlock)(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//将url处理成缓存图像用的key的方法，返回字符串作为存储时的key，可以删除url中的产讯字段</span><br><span class="line">//用于在使用某url生成key之前，先把url的某些动态信息除掉，以便可以用简洁一点的url来生成key。因此这个block的内容就是对url的操作，返回值是一个简洁版的url。</span><br><span class="line">typedef NSString * _Nullable(^SDWebImageCacheKeyFilterBlock)(NSURL * _Nullable url);</span><br><span class="line"></span><br><span class="line">//将图像缓存到磁盘的解码算法，返回的是data。</span><br><span class="line">typedef NSData * _Nullable(^SDWebImageCacheSerializerBlock)(UIImage * _Nonnull image, NSData * _Nullable data, NSURL * _Nullable imageURL);</span><br></pre></td></tr></table></figure>
<h3 id="2-3、协议：SDWebImageManagerDelegate"><a href="#2-3、协议：SDWebImageManagerDelegate" class="headerlink" title="2.3、协议：SDWebImageManagerDelegate"></a>2.3、协议：<code>SDWebImageManagerDelegate</code></h3><p>使用协议的优点在于：</p>
<ol>
<li>不需要担心循环引用问题</li>
<li>有利于程序的结构化与层次化</li>
<li>有利于代码的封装</li>
</ol>
<p><code>SDWebImageManager</code>提供的三个都是可选协议，这也是我们平时常用的方式，遵守协议的类根据需要实现协议方法，不需要编译器警告提示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当缓存没有发现当前图片，会查看调用者是否实现该方法，如果返回NO，则不会继续下载该图片</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager 当前的 `SDWebImageManager`</span><br><span class="line"> * @param imageURL    应该下载的图像的URL</span><br><span class="line"> *</span><br><span class="line"> * @return  返回结果，返回NO时阻止去下载，如果不执行，默认的是YES</span><br><span class="line"> Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span><br><span class="line"> */</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 当图片下载失败时，会查看调用者是否将该图片URL标记为失败，如果返回YES，则将此URL标记为失败。</span><br><span class="line"> 注意：如果委托实现此方法，将不会使用内置方式根据错误代码将URL标记为失败;</span><br><span class="line"> @param imageManager 当前的`SDWebImageManager`</span><br><span class="line"> @param imageURL 图像的网址</span><br><span class="line"> @param error URL下载的错误</span><br><span class="line"> @return 是否阻止失败的URL再去下载，返回YES，将URL标记为失败，不再下载</span><br><span class="line"> */</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldBlockFailedURL:(nonnull NSURL *)imageURL withError:(nonnull NSError *)error;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 允许在下载后立即转换图像，然后将图像缓存到磁盘和内存中。</span><br><span class="line"> * 注意：从全局队列调用此方法，以便不阻止主线程。</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager  当前的`SDWebImageManager`</span><br><span class="line"> * @param image        要转换的图像</span><br><span class="line"> * @param imageURL     要转换的图像的网址</span><br><span class="line"> *</span><br><span class="line"> * @return 转换后的图像对象。</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;</span><br></pre></td></tr></table></figure>
<h3 id="2-4、协议：属性和方法"><a href="#2-4、协议：属性和方法" class="headerlink" title="2.4、协议：属性和方法"></a>2.4、协议：属性和方法</h3><p>声明属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//代理</span><br><span class="line">@property (weak, nonatomic, nullable) id &lt;SDWebImageManagerDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">//图片缓存</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDImageCache *imageCache;</span><br><span class="line">//图片下载</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDWebImageDownloader *imageDownloader;</span><br><span class="line"></span><br><span class="line">//缓存过滤器代码块（每次SDWebImageManager将URL转换为缓存所需要的key时使用的代码块，这个可以用于删除图片URL的动态部分）</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//高速缓存序列化器，用于将解码图像（愿下载数据）转换为用于存储到磁盘高速缓存的世纪数据的代码块，如果返回nil，则表示从图像实例生成数据。</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheSerializerBlock cacheSerializer;</span><br><span class="line"></span><br><span class="line">//全局SDWebImageManager实例。</span><br><span class="line">+ (nonnull instancetype)sharedManager;</span><br><span class="line"></span><br><span class="line">//允许指定与图像管理器一起使用的缓存和图像下载器的实例。</span><br><span class="line">//返回带有指定缓存和下载器的`SDWebImageManager`的新实例。</span><br><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果缓存中不存在，就下载给定URL的图像，存在就返回缓存的版本</span><br><span class="line"> Downloads the image at the given URL if not present in cache or return the cached version otherwise.</span><br><span class="line"> *</span><br><span class="line"> * @param url           图像的URL</span><br><span class="line"> * @param options       用于指定此请求的选项掩码</span><br><span class="line"> * @param progressBlock 下载图像时调用的代码块（在后台队列上执行的进度代码块）</span><br><span class="line"> *                      </span><br><span class="line"> * @param completedBlock  操作完成时调用的代码块</span><br><span class="line">* @return 返回 SDWebImageDownloaderOperation 的一个实例</span><br><span class="line">  </span><br><span class="line">completedBlock 即：typedef void(^SDInternalCompletionBlock)(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL);</span><br><span class="line"> </span><br><span class="line"> 该代码块没有返回值，将请求到的UIImage作为第一个参数；NSData作为第二个参数；如果出错，则image参数为nil，第三个参数可能包含NSError；第四个参数是一个`SDImageCacheType`枚举，指明图像的来源（本地缓存中检索、内存缓存、网络下载。）第五个参数用来判断下载是否完成；最后一个参数为原始图像的URL</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                              options:(SDWebImageOptions)options</span><br><span class="line">                                             progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                            completed:(nullable SDInternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将图像保存到给定的URL的缓存中</span><br><span class="line"> *</span><br><span class="line"> * @param image要缓存的图像</span><br><span class="line"> * @param url   图像的URL</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">//</span><br><span class="line">- (void)saveImageToCache:(nullable UIImage *)image forURL:(nullable NSURL *)url;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> //取消当前所有的操作</span><br><span class="line">- (void)cancelAll;</span><br><span class="line"></span><br><span class="line"> //检查一个或多个正在运行的操作</span><br><span class="line">- (BOOL)isRunning;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  异步检查图像是否已被缓存</span><br><span class="line"> *</span><br><span class="line"> *  @param url              图像 url</span><br><span class="line"> *  @param completionBlock  检查完成时要执行的代码块</span><br><span class="line"> *  </span><br><span class="line"> *  @note 完成代码块总是在主队列上执行</span><br><span class="line"> */</span><br><span class="line">- (void)cachedImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">                     completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  异步检查图像是否已仅缓存在磁盘上</span><br><span class="line"> *</span><br><span class="line"> *  @param url             图像 url</span><br><span class="line"> *  @param completionBlock  检查完成时要执行的代码块</span><br><span class="line"> *</span><br><span class="line"> *  @note 完成代码块总是在主队列上执行</span><br><span class="line"> */</span><br><span class="line">- (void)diskImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">                   completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//返回给定URL的缓存key</span><br><span class="line">- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url;</span><br></pre></td></tr></table></figure>
<h3 id="再看-m文件-的声明"><a href="#再看-m文件-的声明" class="headerlink" title="再看.m文件 的声明"></a>再看.m文件 的声明</h3><h3 id="2-5-SDWebImageCombinedOperation的属性声明和协议方法实现"><a href="#2-5-SDWebImageCombinedOperation的属性声明和协议方法实现" class="headerlink" title="2.5 SDWebImageCombinedOperation的属性声明和协议方法实现"></a>2.5 <code>SDWebImageCombinedOperation</code>的属性声明和协议方法实现</h3><p>定义一个<code>SDWebImageCombinedOperation</code>类，该类遵循 <code>SDWebImageOperation</code>协议 ，该协议仅定义了一个cancel的方法。<br>之所以在这里定义这个类，而不是直接使用<code>SDWebImageDownloaderOperation</code>类来表示下载任务，原因有两方面：</p>
<ol>
<li>为了可以在下面使用中修改<code>cancelled</code>属性的值，在<code>SDWebImageDownloaderOperation</code>中 <code>cancelled</code>属于对外是只读的</li>
<li>一个操作表示一个获取图像的动作，通常优先从缓存中取出图像，缓存中没鱼哦才需要下载，而<code>SDWebImageDownloderOperation</code>是专门用来下载的，没有包含查找缓存的功能。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line">//是否已取消</span><br><span class="line">@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;</span><br><span class="line">//下载任务</span><br><span class="line">@property (strong, nonatomic, nullable) SDWebImageDownloadToken *downloadToken;</span><br><span class="line">//取消操作</span><br><span class="line">@property (strong, nonatomic, nullable) NSOperation *cacheOperation;</span><br><span class="line">//管理类</span><br><span class="line">@property (weak, nonatomic, nullable) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>实现<code>SDWebImageOperation</code>协议的cancel的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@implementation SDWebImageCombinedOperation</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        //设置为取消状态</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        //取消的操作存在，就执行该取消操作，并置为nil</span><br><span class="line">        if (self.cacheOperation) &#123;</span><br><span class="line">            [self.cacheOperation cancel];</span><br><span class="line">            self.cacheOperation = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        //在管理类的下载任务中取消该下载任务</span><br><span class="line">        if (self.downloadToken) &#123;</span><br><span class="line">            //在下载SDWebImageDownloader类中执行取消任务操作</span><br><span class="line">            [self.manager.imageDownloader cancel:self.downloadToken];</span><br><span class="line">        &#125;</span><br><span class="line">        //安全移除该操作</span><br><span class="line">        [self.manager safelyRemoveOperationFromRunning:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    if (!operation) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //加锁是为了安全，防止正在移除该操作时有变化</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations removeObject:operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-SDWebImageManager的属性声明"><a href="#2-6-SDWebImageManager的属性声明" class="headerlink" title="2.6 SDWebImageManager的属性声明"></a>2.6 <code>SDWebImageManager</code>的属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageManager ()</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, readwrite, nonnull) SDImageCache *imageCache;</span><br><span class="line">@property (strong, nonatomic, readwrite, nonnull) SDWebImageDownloader *imageDownloader;</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t failedURLsLock; // a lock to keep the access to `failedURLs` thread-safe</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t runningOperationsLock; // a lock to keep the access to `runningOperations` thread-safe</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>imageCache</code> 和 <code>imageDownloader</code> 在.h文件中已经声明，但是只读类型。这里重复声明成读写类型，实现外部为只读，内部为读写类型。</p>
<p>两个可变集合体<code>failedURLs</code> 和 <code>runningOperations</code> 前者存储<code>NSURL</code> 类型，记录失败的urls，后者存储<code>SDWebImageCombinedOperation</code>类型，记录正在运行的操作。</p>
<p>两个信号量<code>failedURLsLock</code> 和 <code>runningOperationsLock</code>锁，为了保持访问<code>failedURLs</code> 和 <code>runningOperations</code>线程安全的。</p>
<h3 id="2-7、SDWebImageManager的方法实现"><a href="#2-7、SDWebImageManager的方法实现" class="headerlink" title="2.7、SDWebImageManager的方法实现"></a>2.7、<code>SDWebImageManager</code>的方法实现</h3><h4 id="2-7-1、初始化"><a href="#2-7-1、初始化" class="headerlink" title="2.7.1、初始化"></a>2.7.1、初始化</h4><p>三个初始化方法，单例模式确保全局只有一个实例，避免每次调用时创建新的实例。</p>
<p>使用GCD中的<code>dispatch_once</code>创建的实例对象必须确保只有一个，所以使用static修饰 <code>static dispatch_once_t once; static id instance;</code><br><code>dispatch_once</code>可以简化代码且保证线程安全，开发者无需担心加锁或同步。所有问题都在GCD底层处理。此外，<code>dispatch_once</code>更高效。它没有使用重量级的同步机制。使用同步机制，每次运行代码都需要获取锁。<code>dispatch_once</code>采用“原子访问”来查询标记，判断代码是否执行过。</p>
<p><code>[self new]</code>是一种比较老式的写法，而<code>alloc/init</code>的引入则是因为<code>new</code>不够灵活，因为使用<code>new</code>的话，会使得初始化方法被固定死只能调用<code>init</code>。而这里就是使用的<code>new</code>方法，所以调用的顺序只能是<code>sharedManager ---&gt; init ---&gt; initWithCache: downloader:</code>。</p>
<p>在<code>init</code>初始化中，可以看出<code>cache</code> 和 <code>downloader</code>也是单例模式，其实也是使用的<code>new</code>方法，原理和这里的相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//单例模式</span><br><span class="line">+ (nonnull instancetype)sharedManager &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化 cache 和 downloader</span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</span><br><span class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    return [self initWithCache:cache downloader:downloader];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里实现一些属性的初始化。</span><br><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _imageCache = cache;</span><br><span class="line">        _imageDownloader = downloader;</span><br><span class="line">        _failedURLs = [NSMutableSet new];</span><br><span class="line">        _failedURLsLock = dispatch_semaphore_create(1);</span><br><span class="line">        _runningOperations = [NSMutableSet new];</span><br><span class="line">        _runningOperationsLock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-2、功能实现方法"><a href="#2-7-2、功能实现方法" class="headerlink" title="2.7.2、功能实现方法"></a>2.7.2、功能实现方法</h4><ol>
<li>通过URL获取缓存时使用的key<br> 利用Image的URL生成一个缓存时需要的key.<br> 如果检测到cacheKeyFilter不为空时,利用cacheKeyFilter来处理URL生成一个key；否则直接返回URL的string内容,当做key.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url &#123;</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        return @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.cacheKeyFilter) &#123;</span><br><span class="line">        return self.cacheKeyFilter(url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return url.absoluteString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>图像放缩操作：根据图片中的图片组 或 scale 重新计算返回图片。该方法专门使用了一个类（<code>SDWebImageCompat</code>）来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)scaledImageForKey:(nullable NSString *)key image:(nullable UIImage *)image &#123;</span><br><span class="line">    return SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存图像</p>
</li>
</ol>
<p>通过URL缓存图像到内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)cachedImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">                     completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    //获取缓存所需的key</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    //判断内存中是否已缓存该图像</span><br><span class="line">    BOOL isInMemoryCache = ([self.imageCache imageFromMemoryCacheForKey:key] != nil);</span><br><span class="line">    </span><br><span class="line">    //如果已经缓存，在主线程中执行完成回调代码块</span><br><span class="line">    if (isInMemoryCache) &#123;</span><br><span class="line">        // making sure we call the completion block on the main queue</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                completionBlock(YES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果还未缓存，则调用 diskImageExistsWithKey，该方法会将图像缓存到磁盘中（在存储之前也会判断磁盘中是否已缓存该图像），该方法在异步线程执行。</span><br><span class="line">    [self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) &#123;</span><br><span class="line">        // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(isInDiskCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将图像缓存到磁盘中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)diskImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">                   completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">    [self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) &#123;</span><br><span class="line">        // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(isInDiskCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将图像缓存到内存中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)saveImageToCache:(nullable UIImage *)image forURL:(nullable NSURL *)url &#123;</span><br><span class="line">    if (image &amp;&amp; url) &#123;</span><br><span class="line">        NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">        [self.imageCache storeImage:image forKey:key toDisk:YES completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>取消掉所有正在执行的操作Operation</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancelAll &#123;</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    NSSet&lt;SDWebImageCombinedOperation *&gt; *copiedOperations = [self.runningOperations copy];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    [copiedOperations makeObjectsPerformSelector:@selector(cancel)]; // This will call `safelyRemoveOperationFromRunning:` and remove from the array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>判断是否有正在运行的操作Operation</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isRunning &#123;</span><br><span class="line">    BOOL isRunning = NO;</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    isRunning = (self.runningOperations.count &gt; 0);</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    return isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>安全移除正在运行的操作Operation</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    if (!operation) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations removeObject:operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>回调方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)callCompletionBlockForOperation:(nullable SDWebImageCombinedOperation*)operation</span><br><span class="line">                             completion:(nullable SDInternalCompletionBlock)completionBlock</span><br><span class="line">                                  error:(nullable NSError *)error</span><br><span class="line">                                    url:(nullable NSURL *)url &#123;</span><br><span class="line">    [self callCompletionBlockForOperation:operation completion:completionBlock image:nil data:nil error:error cacheType:SDImageCacheTypeNone finished:YES url:url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callCompletionBlockForOperation:(nullable SDWebImageCombinedOperation*)operation</span><br><span class="line">                             completion:(nullable SDInternalCompletionBlock)completionBlock</span><br><span class="line">                                  image:(nullable UIImage *)image</span><br><span class="line">                                   data:(nullable NSData *)data</span><br><span class="line">                                  error:(nullable NSError *)error</span><br><span class="line">                              cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                               finished:(BOOL)finished</span><br><span class="line">                                    url:(nullable NSURL *)url &#123;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        if (operation &amp;&amp; !operation.isCancelled &amp;&amp; completionBlock) &#123;</span><br><span class="line">            completionBlock(image, data, error, cacheType, finished, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>通过url建立一个operation用来下载图片. 返回operation</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    // Invoking this method without a completedBlock is pointless</span><br><span class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line">     //在没有completedBlock的情况下调用此方法毫无意义 ， NSAssert（completedBlock！= nil，@“如果你的意思是预取图像，请使用 - [SDWebImagePrefetcher prefetchURLs]代替”）;</span><br><span class="line"></span><br><span class="line">    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won&apos;t</span><br><span class="line">    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span><br><span class="line">  （非常常见的错误是使用NSString对象而不是NSURL发送URL。 出于某些奇怪的原因，Xcode不会抛出此类型不匹配的任何警告。在这里，我们通过允许URL作为NSString传递来确保此错误。）</span><br><span class="line">  </span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        //如果传入的url是字符串类型，则转换成NSURL类型</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    //防止应用程序崩溃类型错误，如发送NSNull而不是NSURL，则url置为nil</span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    初始化一个SDWebImageCombinedOperation对象</span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    //设置它的SDWebImageManager 等于self</span><br><span class="line">    operation.manager = self;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    //如果url存在，判断该url是否失败过，并赋值给isFailedUrl；加锁是为了安全，防止在判断的过程中被其他线程修改</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    //判断条件：如果url不存在，或者options不是SDWebImageRetryFailed（失败重试）并且isFailedUrl 为 YES。就回调一个error的block （异常处理），并返回operation</span><br><span class="line">    //error为：[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil]</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url];</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建互斥锁，执行runningOperations添加operation操作</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations addObject:operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    //获取缓存所需要的key</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">     // 下面都是判断我们的cacheOptions里包含哪些SDWebImageOptions,然后给我们的cacheOptions相应的添加对应的SDImageCacheOptions. cacheOptions |= SDImageCacheQueryDataWhenInMemory这种表达式的意思等同于cacheOptions = cacheOptions | SDImageCacheQueryDataWhenInMemory</span><br><span class="line">     </span><br><span class="line">    SDImageCacheOptions cacheOptions = 0;</span><br><span class="line">    if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">    if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">    if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line">    </span><br><span class="line">    //弱引用</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line">    /*</span><br><span class="line">    *如果图片是从内存加载，则返回的cacheOperation是nil，</span><br><span class="line">    *如果是从磁盘加载，则返回的cacheOperation是`NSOperation`对象。</span><br><span class="line">    *如果是从网络加载，则返回的cacheOperation对象是`SDWebImageDownloaderOperation`对象。</span><br><span class="line">    */</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">        //强引用，防止被提前释放</span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        //operation不存在或者已经被取消，返回并移除该operation对象</span><br><span class="line">        if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Check whether we should download image from network</span><br><span class="line">        //检查是否应该从网络下载图像</span><br><span class="line">        BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</span><br><span class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</span><br><span class="line">            &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);</span><br><span class="line">          </span><br><span class="line">        //应该从网络下载图像  </span><br><span class="line">        if (shouldDownload) &#123;</span><br><span class="line">            //如果缓存图像存在，但options设置为SDWebImageRetryFailed。则先返回缓存图像</span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                //构建回调block</span><br><span class="line">                [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">             /*</span><br><span class="line">             把图片加载的`SDWebImageOptions`类型枚举转换为图片下载的`SDWebImageDownloaderOptions`类型的枚举</span><br><span class="line">             */</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            /*</span><br><span class="line">             如果设置了强制刷新缓存的选项。则`SDWebImageDownloaderProgressiveDownload`选项失效并且添加`SDWebImageDownloaderIgnoreCachedResponse`选项。</span><br><span class="line">             */</span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // force progressive off if image already cached but forced refreshing</span><br><span class="line">                //如果图像已缓存但强制刷新，则强制渐进关闭</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                //忽略从NSURLCache读取的图像，如果图像缓存但强制刷新</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</span><br><span class="line">            __weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            /*</span><br><span class="line">             新建一个网络下载的操作。</span><br><span class="line">             */</span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;</span><br><span class="line">                //如果操作被取消或者不存在，则不执行任何操作</span><br><span class="line">                if (!strongSubOperation || strongSubOperation.isCancelled) &#123;</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125; else if (error) &#123;</span><br><span class="line">                    //如果加载出错。则直接返回回调。并且添加到failedURLs中</span><br><span class="line">                    [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url];</span><br><span class="line">                    BOOL shouldBlockFailedURL;</span><br><span class="line">                    // Check whether we should block failed url</span><br><span class="line">                    //检查我们是否应该阻止失败的网址</span><br><span class="line">                    if ([self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)]) &#123;</span><br><span class="line">                        shouldBlockFailedURL = [self.delegate imageManager:self shouldBlockFailedURL:url withError:error];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotConnectToHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    //如果shouldBlockFailedURL为YES，即阻止失败的网址，添加到failedURLs中</span><br><span class="line">                    if (shouldBlockFailedURL) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs addObject:url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                //加载图片成功，</span><br><span class="line">                    //如果options选项设置为SDWebImageRetryFailed，则把url从failedURLS中移除</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs removeObject:url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //是否缓存在磁盘上</span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line">                    </span><br><span class="line">                    // We&apos;ve done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.（我们已经使用共享管理器在SDWebImageDownloader中完成了缩放过程，这用于自定义管理器并避免额外的扩展。）</span><br><span class="line">                    </span><br><span class="line">                    //如果self不为SDWebImageManager单例，并且cacheKeyFilter（缓存可以代码块存在，下载的图像存在），则缩放下载的图像</span><br><span class="line">                    if (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</span><br><span class="line">                        downloadedImage = [self scaledImageForKey:key image:downloadedImage];</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果options选项为SDWebImageRefreshCached，并且缓存图像存在，下载图像不存在。图像刷新命中NSURLCache缓存，不调用完成块</span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                        //图像刷新命中NSURLCache缓存，不调用完成块</span><br><span class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                     //如果成功下载图片。并且图片是动态图片。并且设置了SDWebImageTransformAnimatedImage属性。则处理图片</span><br><span class="line">                     </span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            //获取transform以后的图片</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line">                            //存储transform以后的的图片</span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                NSData *cacheData;</span><br><span class="line">                                // pass nil if the image was transformed, so we can recalculate the data from the image（如果图像被转换，则传递nil，因此我们可以重新计算图像中的数据）</span><br><span class="line">                                </span><br><span class="line">                                //cacheSerializer：将图像缓存到磁盘的解码算法，返回的是data。如果self.cacheSerializer存在，则重新计算图像中的数据。</span><br><span class="line">                                if (self.cacheSerializer) &#123;</span><br><span class="line">                                    cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">                                &#125;</span><br><span class="line">                               //存储transform以后的图片</span><br><span class="line">                                [self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                             //回调拼接</span><br><span class="line">                            [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; else &#123;//如果成功下载图片。并且图片不是图片。则直接缓存和回调</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            //cacheSerializer：将图像缓存到磁盘的解码算法，返回的是data。如果self.cacheSerializer存在，则重新计算图像中的数据。</span><br><span class="line">                            if (self.cacheSerializer) &#123;</span><br><span class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                                    NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);</span><br><span class="line">                                     //存储transform以后的图片</span><br><span class="line">                                    [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                //存储transform以后的图片</span><br><span class="line">                                [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                         //回调拼接</span><br><span class="line">                        [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //从正在加载的图片操作集合中移除当前操作</span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    [self safelyRemoveOperationFromRunning:strongSubOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; else if (cachedImage) &#123;</span><br><span class="line">            //如果缓存的图像存在，回调拼接，安全移除Operation对象</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Image not in cache and download disallowed by delegate（委托不允许图像不在缓存和下载中）</span><br><span class="line">             //如果缓存的图像不存在，回调拼接，安全移除Operation对象</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8、SDWebImageCompat的图像缩放操作"><a href="#2-8、SDWebImageCompat的图像缩放操作" class="headerlink" title="2.8、SDWebImageCompat的图像缩放操作"></a>2.8、<code>SDWebImageCompat</code>的图像缩放操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  放缩操作：根据图片中的图片组 或 scale 重新计算返回图片</span><br><span class="line">    *</span><br><span class="line"> *  @param key   键：就是图片的地址</span><br><span class="line"> *  @param image UIImage</span><br><span class="line">    *</span><br><span class="line"> *  @return UIImage</span><br><span class="line">    */</span><br><span class="line">inline UIImage *SDScaledImageForKey(NSString * _Nullable key, UIImage * _Nullable image) &#123;</span><br><span class="line">    //图片为空，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#if SD_MAC //如果是MAC，直接返回图片</span><br><span class="line">    return image;</span><br><span class="line">#elif SD_UIKIT || SD_WATCH //iOS或者watch</span><br><span class="line">    if ((image.images).count &gt; 0) &#123;//动态图</span><br><span class="line">        NSMutableArray&lt;UIImage *&gt; *scaledImages = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">        for (UIImage *tempImage in image.images) &#123;</span><br><span class="line">            //动态图还是执行该方法，处理单个图片</span><br><span class="line">            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //创建一个动态图片，动态图片持续的时间为duration</span><br><span class="line">        UIImage *animatedImage = [UIImage animatedImageWithImages:scaledImages duration:image.duration];</span><br><span class="line">        if (animatedImage) &#123;</span><br><span class="line">            animatedImage.sd_imageLoopCount = image.sd_imageLoopCount;</span><br><span class="line">            animatedImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">        &#125;</span><br><span class="line">        return animatedImage;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">#if SD_WATCH</span><br><span class="line">        if ([[WKInterfaceDevice currentDevice] respondsToSelector:@selector(screenScale)]) &#123;</span><br><span class="line">#elif SD_UIKIT</span><br><span class="line">        if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line">#endif</span><br><span class="line">           // 比如屏幕为320x480时，scale为1，屏幕为640x960时，scale为2</span><br><span class="line">            CGFloat scale = 1;</span><br><span class="line">            // “@2x.png”的长度为7，所以此处添加了这个判断，很巧妙</span><br><span class="line">            if (key.length &gt;= 8) &#123;</span><br><span class="line">                //根据后缀给scale赋值</span><br><span class="line">                NSRange range = [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = 2.0;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                range = [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = 3.0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用initWithCGImage来根据Core Graphics的图片构建UIImage。</span><br><span class="line">            // 这个函数可以使用scale和orientation</span><br><span class="line">            UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</span><br><span class="line">            scaledImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">            image = scaledImage;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSString *const SDWebImageErrorDomain = @&quot;SDWebImageErrorDomain&quot;;</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/29/Read-SDWebImage-note1/"><span>读 SDWebImage 一 使用分析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/29/Read-SDWebImage-note1/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-29T06:32:04.000Z">
          2018-09-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>SDWebImage整体的框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SDWebImage</span><br><span class="line">    -</span><br><span class="line">    |--SDWebImageCompat :一些兼容性相关的宏定义 </span><br><span class="line">    |--SDWebImageOperation :只有一个 cancel 方法的 protocal</span><br><span class="line">    |</span><br><span class="line">    |--Downloader :下载模块</span><br><span class="line">    |   |-- SDWebImageDownloader</span><br><span class="line">    |   |-- SDWebImageDownloaderOperation</span><br><span class="line">    |   </span><br><span class="line">    |--Cache :内存和硬盘缓存模块</span><br><span class="line">    |   |-- SDImageCache</span><br><span class="line">    |</span><br><span class="line">    |--Utils :</span><br><span class="line">    |   |-- SDWebImageManager 将缓存和下载模块结合起来使用</span><br><span class="line">    |   |-- SDWebImagePrefetcher 预下载图片</span><br><span class="line">    |   |-- SDWebImageDecoder</span><br><span class="line">    |</span><br><span class="line">    |--Categories : UIKit 相关的Category,方便使用,还支持 MKAnnotationView</span><br><span class="line">        |-- MKAnnotationView+WebCache</span><br><span class="line">        |-- UIButton+WebCache</span><br><span class="line">        |-- UIImageView+WebCache</span><br><span class="line">    -</span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure>
<h2 id="1、使用配置"><a href="#1、使用配置" class="headerlink" title="1、使用配置"></a>1、使用配置</h2><p>为项目添加一个通用的只读缓存的存储路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundlePath = [[NSBundle mainBundle].resourcePath stringByAppendingPathComponent:@&quot;CustomPathImages&quot;];</span><br><span class="line"> </span><br><span class="line">[[SDImageCache sharedImageCache] addReadOnlyCachePath:bundlePath];</span><br></pre></td></tr></table></figure>
<h2 id="2、-身份鉴定"><a href="#2、-身份鉴定" class="headerlink" title="2、 身份鉴定"></a>2、 身份鉴定</h2><p>如果请求的图片需要身份鉴定才可以获取，SDWebImage提供了两种方法：</p>
<p>一种是直接设置用户名和密码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SDWebImageManager sharedManager].imageDownloader.username = @&quot;httpwatch&quot;;</span><br><span class="line">[SDWebImageManager sharedManager].imageDownloader.password = @&quot;httpwatch01&quot;;</span><br></pre></td></tr></table></figure>
<p>另一种是通过 <code>NSURLCredential</code> 属性去配置用户名和密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLCredential *newCredential = [NSURLCredential credentialWithUser:@&quot;httpwatch&quot; password:@&quot;httpwatch01&quot; persistence:NSURLCredentialPersistenceNone];</span><br><span class="line">[SDWebImageManager sharedManager].imageDownloader.urlCredential = newCredential;</span><br></pre></td></tr></table></figure>
<p>这里做下测试：<br>图片地址（需要身份验证才可以查看）：<a href="http://www.httpwatch.com/httpgallery/authentication/authenticatedimage/default.aspx?0.35786508303135633" target="_blank" rel="noopener">http://www.httpwatch.com/httpgallery/authentication/authenticatedimage/default.aspx?0.35786508303135633</a></p>
<p>浏览器去打开会弹出提示框让输入验证信息，如下：<br><img src="http://obzx0h1re.bkt.clouddn.com/Authentication_Image_SDWebImage.jpg" alt="Authentication_Image_SDWebImage"></p>
<p>这种情况下，在项目中就需要配置身份验证信息，否则图片无法显示。</p>
<h2 id="3、设置要附加到每个下载HTTP请求的HTTP标头的值"><a href="#3、设置要附加到每个下载HTTP请求的HTTP标头的值" class="headerlink" title="3、设置要附加到每个下载HTTP请求的HTTP标头的值"></a>3、设置要附加到每个下载HTTP请求的HTTP标头的值</h2><p>如果想要自定义图片请求的Request Header时，可以使用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置要附加到每个下载HTTP请求的HTTP标头的值。</span><br><span class="line">  [SDWebImageManager.sharedManager.imageDownloader setValue:@&quot;&amp;&amp;Jason&amp;&amp;&quot; forHTTPHeaderField:@&quot;****SDWebImageM****&quot;];</span><br></pre></td></tr></table></figure>
<p>通过charles抓包可以看到设置的Request Header：</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/setValue_1_SDWebImageManager.jpg" alt="setValue_1_SDWebImageManager"></p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/setValue_2_SDWebImageManager.jpg" alt="setValue_2_SDWebImageManager"></p>
<h2 id="4、图片下载执行顺序"><a href="#4、图片下载执行顺序" class="headerlink" title="4、图片下载执行顺序"></a>4、图片下载执行顺序</h2><p>执行顺序分：LIFO（先入后出） 和 FIFO（先进先出）两种<br>默认值为 <code>FIFO</code> 。</p>
<p><code>SDWebImageDownloaderExecutionOrder</code> ：枚举类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager.sharedManager.imageDownloader.executionOrder = SDWebImageDownloaderLIFOExecutionOrder;</span><br></pre></td></tr></table></figure>
<h2 id="5、手动清理缓存"><a href="#5、手动清理缓存" class="headerlink" title="5、手动清理缓存"></a>5、手动清理缓存</h2><p>SDWebImage提供了手动清理缓存操作，从SDWebImage的工作原理可以想到清理缓存需清理两处：内存和磁盘。</p>
<p>注：这里清理的仅仅是SDWebImage的缓存，并没有清理整个app的缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SDWebImageManager.sharedManager.imageCache clearMemory];</span><br><span class="line">[SDWebImageManager.sharedManager.imageCache clearDiskOnCompletion:nil];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6、将图片显示到ImgaeView-Button上"><a href="#6、将图片显示到ImgaeView-Button上" class="headerlink" title="6、将图片显示到ImgaeView / Button上"></a>6、将图片显示到ImgaeView / Button上</h2><p>Button图片或者背景图的显示和ImageView同理，只是多了几个额外的参数,下面以ImageView为例。</p>
<h3 id="6-1、图片显示动画"><a href="#6-1、图片显示动画" class="headerlink" title="6.1、图片显示动画"></a>6.1、图片显示动画</h3><p>图片显示过渡类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.customImageView.sd_imageTransition = SDWebImageTransition.curlUpTransition;</span><br></pre></td></tr></table></figure></p>
<p>SDWebImage提供了七种动画过渡类型，分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/// Fade transition. 淡出过渡</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *fadeTransition;</span><br><span class="line">/// Flip from left transition. 从左过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromLeftTransition;</span><br><span class="line">/// Flip from right transition. 从右过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromRightTransition;</span><br><span class="line">/// Flip from top transition. 从顶部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromTopTransition;</span><br><span class="line">/// Flip from bottom transition. 从底部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromBottomTransition;</span><br><span class="line">/// Curl up transition. 向上卷起过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlUpTransition;</span><br><span class="line">/// Curl down transition. 向下卷起过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlDownTransition;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-、图片显示方法"><a href="#6-2-、图片显示方法" class="headerlink" title="6.2 、图片显示方法"></a>6.2 、图片显示方法</h3><p>SDWebImage提供7种方法去显示图片，我们只看第7个，因为其他6种方法最后都是通过该方法图显示图片的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p><strong>通过给定的URL加载图片并将其加载到此imageView中。它适用于静态和动态图像。<br>先从缓存和磁盘中寻找该图片，有则直接显示，无就下载显示并缓存。<br>下载是异步和缓存的，SDWebImage会先显示传入的占位符，直到请求完成</strong></p>
<h4 id="6-2-1分析参数"><a href="#6-2-1分析参数" class="headerlink" title="6.2.1分析参数"></a>6.2.1分析参数</h4><ol>
<li>@param url  ：图片URL</li>
<li>@param placeholder ：占位符（最初要设置的图像，直到图像请求完成。）</li>
<li>@param options ：下载图像时使用的选项。</li>
<li>@param progressBlock ：下载图像时调用的block代码块（稍后分析）</li>
<li>@param completedBlock ： 操作完成时调用的代码块。 该代码块没有返回值（稍后分析）</li>
</ol>
<p><strong>解析 options 选项（枚举类型）</strong></p>
<blockquote>
<p><code>SDWebImageRetryFailed = 1 &lt;&lt; 0,</code><br>  默认情况下当通过URL下载图片失败后，该URL就被加入黑名单，之后SDWebImage不会再去尝试下载。此标志作用就是禁用该黑名单，也就是说使用SDWebImageRetryFailed后，图片下载失败仍会尝试下载</p>
<p> <code>SDWebImageLowPriority = 1 &lt;&lt; 1,</code><br>  默认情况下图片在UI交互期间下载，此标志的作用就是禁用该功能。例如：在UIScrollView减速时导致延迟下载。</p>
<p><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</code><br>  此标志作用是：图片下载完成后仅缓存到内存，不缓存在磁盘上</p>
<p><code>SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</code><br>  此标志启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。<br>  默认情况下，图像仅在完全下载后显示。</p>
<p><code>SDWebImageRefreshCached = 1 &lt;&lt; 4,</code><br>  即使缓存中存在该图片，也尊重HTTP响应缓存控制，在需要时从远程刷新图片。<br>  磁盘缓存将由 <code>NSURLCache</code> 替代 <code>SDWebImage</code> 去处理，这样也将导致性能略有下降。<br>  该选项有助于处理同一个URL请求但更换图片的情况，例如Facebook图形api配置文件的图片。<br>  如果刷新了缓存图片，则使用缓存图片调用一次完成block代码块，再使用最终的图片调用完成block代码块。<br>  仅当你无法使用嵌入式缓存清除参数使URL保持静态时，才使用该标志。</p>
<p><code>SDWebImageContinueInBackground = 1 &lt;&lt; 5,</code><br>  在<code>iOS 4+</code>中，如果app进入后台也继续下载图片，这是通过询问系统实现的。<br>  在后台有额外的时间让请求完成，如果后台任务到期，则操作被取消。</p>
<p><code>SDWebImageHandleCookies = 1 &lt;&lt; 6,</code><br>  通过<code>NSMutableURLRequest.HTTPShouldHandleCookies = YES</code>设置处理在 <code>NSHTTPCookieStore</code>中的cookies。</p>
<p>  <code>SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</code><br>  启用允许不受信任的SSL证书（用于测试目的，在生产中谨慎使用）</p>
<p><code>SDWebImageHighPriority = 1 &lt;&lt; 8,</code><br>  默认情况下，图像按其排队顺序加载，此标志将它们移动到队列的前面</p>
<p><code>SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</code><br>  默认情况下，加载图像时会加载占位符。 此标志将延迟加载占位符图像，直到图像加载完毕。</p>
<p><code>SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</code><br>  我们通常不会在动画图像上调用transformDownloadedImage委托方法，因为大多数转换代码会破坏它。如果使用必须使用此标志来转换它们。  </p>
<p><code>SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</code><br>  默认情况下，下载后会将图像添加到imageView。 但在某些情况下，我们想要<br>  在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志</p>
<p><code>SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</code><br>  默认情况下，图像会根据其原始大小进行解码。 在iOS上，此标志将缩小<br>  图像尺寸与设备的受限内存兼容。（如果设置了“SDWebImageProgressiveDownload”标志，则停用缩小比例。）</p>
<p><code>SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</code><br>  默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此掩码可以强制同时查询磁盘数据。<br>  建议将此标志与<code>SDWebImageQueryDiskSync</code>一起使用，以确保图像在同一个runloop中加载。 </p>
<p><code>SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</code><br>  默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此掩码可以强制同步查询磁盘缓存，以确保在同一个runloop中加载映像。<br>  如果禁用内存缓存或在某些其他情况下，此标志可以避免在单元重用期间闪烁。</p>
<p><code>SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</code><br>  默认情况下，当缓存丢失时，将从网络下载映像。此标志可以阻止网络仅从缓存加载。</p>
<p><code>SDWebImageForceTransition = 1 &lt;&lt; 16</code><br>  默认情况下，当您使用 <code>SDWebImageTransition</code> 在图像加载完成后进行某些视图转换时，此转换仅适用于从网络下载图像。 此掩码也可以强制为内存和磁盘缓存应用视图转换。</p>
</blockquote>
<p><strong>解析progressBlock代码块</strong><br>下载图像时重复调用的代码块,在后台队列上执行,包含三个参数，分别是：<br>NSInteger receivedSize：接收到的图片大小<br>NSInteger expectedSize：预期的图片大小<br>NSURL * _Nullable targetURL：目标图片的URL</p>
<p><strong>completedBlock代码块</strong><br>包含四个参数：<br>(UIImage <em> _Nullable image, NSError </em> _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL)</p>
<ol>
<li>第一个参数是：请求得到的UIImage，如果请求失败，该图像参数是为nil</li>
<li>第二个参数： 请求结果中可能包含的NSError</li>
<li>第三个参数： 是枚举，缓存类型，通过类型判断图片从哪里获取。分三种： SDImageCacheTypeNone 、SDImageCacheTypeDisk、SDImageCacheTypeMemory 。</li>
<li>第四个参数：图片的URL。</li>
</ol>
<p>以下是其他6种显示图片的方法，只做简单的分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *通过给定的URL加载图片并将其加载到此imageView中。它适用于静态和动态图像</span><br><span class="line"> * 先从缓存和磁盘中寻找，有则显示，无就下载显示并缓存</span><br><span class="line"> */</span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder ;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options ;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock ;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="7、图像显示的最终调用方法解析"><a href="#7、图像显示的最终调用方法解析" class="headerlink" title="7、图像显示的最终调用方法解析"></a>7、图像显示的最终调用方法解析</h2><p>通过上面的七种方法来加载图像，其实前6种都是调用第7种完善的方法。而这7种方法都是调用的另一种方法。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(nullable NSString *)operationKey</span><br><span class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(nullable NSDictionary&lt;NSString *, id&gt; *)context;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ol>
<li>@param url  ：图像URL</li>
<li>@param placeholder ：初始化image，知道图像请求完成</li>
<li>@param options ：图像下载时的选项</li>
<li>@param operationKey ：用作操作key的字符串。 如果为nil，将使用类名（ImageView加载图像时直接传的nil，Button加载图像时传【字符串和UIControlState状态的拼接】）</li>
<li>@param setImageBlock ： 用于自定义设置图像的代码块</li>
<li>@param progressBlock ： 下载图像时调用的代码块</li>
<li>@param completedBlock ： 操作完成时调用的代码块。 该块没有返回值</li>
<li>@param context ： 具有执行特定更改或过程的额外信息的上下文。</li>
</ol>
<p>其实可以看出：除了参数4、5、8之外，剩下的都是和ImageView加载图像时参数一样，因为这本就是ImageView加载图像最终调用的方法。而参数4、5、8则是Button加载图像传入的参数，这也证明了代码的高内聚力。</p>
<p><strong>SDSetImageBlock：</strong><br>包含两个参数：<br>(UIImage <em>image, NSData </em>imageData)<br>我们通常在该回调中自定义图像（比如说压缩、剪切、加滤镜、加蒙层等）<br>或者直接简单的显示图像：<code>[weakSelf setImage:image forState:state];</code></p>
<p>看下整体的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[self sd_internalSetImageWithURL:url</span><br><span class="line">                    placeholderImage:placeholder</span><br><span class="line">                             options:options</span><br><span class="line">                        operationKey:imageOperationKeyForState(state)</span><br><span class="line">                       setImageBlock:^(UIImage *image, NSData *imageData) &#123;</span><br><span class="line">                           [weakSelf setImage:image forState:state]; //自定义图像</span><br><span class="line">                       &#125;</span><br><span class="line">                            progress:nil</span><br><span class="line">                           completed:completedBlock];</span><br></pre></td></tr></table></figure></p>
<p> <strong>context ： 上下文信息</strong></p>
<p>这个是最后才加上的，为的是获取额外的信息（加载的过程信息、更改信息等）</p>
<h3 id="7-1、分析最终的加载图像的方法"><a href="#7-1、分析最终的加载图像的方法" class="headerlink" title="7.1、分析最终的加载图像的方法"></a>7.1、分析最终的加载图像的方法</h3><p>该方法是针对UIView的子类进行图像加载的（例如：UIImageView、UIButton）<br>下面会拆成代码片段一步一步看</p>
<h4 id="7-1-1、第一步"><a href="#7-1-1、第一步" class="headerlink" title="7.1.1、第一步"></a>7.1.1、第一步</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static char imageURLKey;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]);</span><br><span class="line">[self sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化一个有效的操作key，如果传入的 <code>operationKey</code> 为nil，则赋值为类名 <code>NSStringFromClass([self class])</code> </li>
<li>通过 <code>operationKey</code> 从队列中取消正在进行的下载操作。</li>
<li>最后将该类与图像的URL关联起来，关联类型是 ：<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> (指定对关联对象的强引用。)</li>
</ol>
<p>以下列出所有的关联类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">关联策略</th>
<th style="text-align:left">等价属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">OBJC_ASSOCIATION_ASSIGN</td>
<td style="text-align:left">@property (assign) or @property (unsafe_unretained)</td>
<td style="text-align:left">弱引用关联对象</td>
</tr>
<tr>
<td style="text-align:left">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td style="text-align:left">@property (strong, nonatomic)</td>
<td style="text-align:left">强引用关联对象，且为非原子操作</td>
</tr>
<tr>
<td style="text-align:left">OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td style="text-align:left">@property (copy, nonatomic)</td>
<td style="text-align:left">复制关联对象，且为非原子操作</td>
</tr>
<tr>
<td style="text-align:left">OBJC_ASSOCIATION_RETAIN</td>
<td style="text-align:left">@property (strong, atomic)</td>
<td style="text-align:left">强引用关联对象，且为原子操作</td>
</tr>
<tr>
<td style="text-align:left">OBJC_ASSOCIATION_COPY</td>
<td style="text-align:left">@property (copy, atomic)</td>
<td style="text-align:left">复制关联对象，且为原子操作</td>
</tr>
</tbody>
</table>
<p>再回到第2条看下怎么通过 <code>operationKey</code> 取消对应正在进行下载的操作（顺便附上加载图像的操作，因为两者正好始和末）：<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//设置加载图像的操作</span><br><span class="line">- (void)sd_setImageLoadOperation:(nullable id&lt;SDWebImageOperation&gt;)operation forKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">        if (operation) &#123;</span><br><span class="line">            SDOperationsDictionary *operationDictionary = [self sd_operationDictionary];</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [operationDictionary setObject:operation forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//设置取消加载图像的操作</span><br><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        // Cancel in progress downloader from queue</span><br><span class="line">        SDOperationsDictionary *operationDictionary = [self sd_operationDictionary];</span><br><span class="line">        id&lt;SDWebImageOperation&gt; operation;</span><br><span class="line">        </span><br><span class="line">        @synchronized (self) &#123;</span><br><span class="line">            operation = [operationDictionary objectForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        if (operation) &#123;</span><br><span class="line">            if ([operation conformsToProtocol:@protocol(SDWebImageOperation)]) &#123;</span><br><span class="line">                [operation cancel];</span><br><span class="line">            &#125;</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [operationDictionary removeObjectForKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析：<br><strong>首先</strong>，获取当前的一个 <code>NSMapTable</code> ，可以说是一个广义的字典，官方文档是这样解释 <code>NSMapTable</code> 的：</p>
<blockquote>
<p>An NSMapTable is modeled after a dictionary, although, because of its options, is not a dictionary because it will behave differently.  The major option is to have keys and/or values held “weakly” in a manner that entries will be removed at some indefinite point after one of the objects is reclaimed.  In addition to being held weakly, keys or values may be copied on input or may use pointer identity for equality and hashing.<br> An NSMapTable can also be configured to operate on arbitrary pointers and not just objects.We recommend the C function API for “void *” access</p>
</blockquote>
<p>大体可以理解为：<br> <code>NSMapTable</code> 是在字典之后的一个可变集合模型化的类，但由于它的选项是使 <code>key</code> 和/或 <code>valus</code> 保持“弱有化”，以便在回收其中一个对象之后在某个不确定点删除条目，所以它不是字典，因为它的行为会有所不同。 除了被弱化之外，可以在输入上复制 <code>key</code> 或 <code>valus</code>，或者可以使用指针标识来进行相等和 <code>hash</code>（散列or哈希）操作。<br> <code>NSMapTable</code> 也可以配置为对任意指针进行操作，而不仅仅是对象。 Apple建议使用C函数API进行 <code>void *</code> 访问。</p>
<p> SDWebImage是这样定义 <code>NSMapTable</code> 的：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// key is copy, value is weak because operation instance is retained by SDWebImageManager&apos;s runningOperations property</span><br><span class="line">typedef NSMapTable&lt;NSString *, id&lt;SDWebImageOperation&gt;&gt; SDOperationsDictionary;</span><br></pre></td></tr></table></figure></p>
<p> key使用的是copy，value则使用的是weak，并给出了解释：操作实例由SDWebImageManager的runningOperations属性保留</p>
<p><strong>注：</strong>获取当前的 <code>NSMapTable</code> ，以下用 <code>operationDictionary</code> 叙述。</p>
<p> <strong>其次</strong>，将该图像的加载操作存放入 <code>operationDictionary</code> 中，而key正是我们上面分析的 <code>operationKey</code> 。这里为了防止在操作是被篡改，使用 <code>@synchronized</code> 做了互斥锁处理。</p>
<p> <strong>最后</strong>，现在再看取消加载图像的操作流程就显得清晰了，大体如下：</p>
<ol>
<li>获取当前的一个 <code>operationDictionary</code> 通过key取得操作。</li>
<li>如果该操作存在，就通过 <code>conformsToProtocol:@protocol()</code> 检查对象是否实现了指定协议类的方法。</li>
<li>如果存在就直接取消，最后从移除 <code>operationDictionary</code> 该操作</li>
</ol>
<p><strong>扩展：<code>objc_setAssociatedObject</code></strong></p>
<ul>
<li>在 Objective-C 中可以通过 Category 给一个现有的类添加属性，却不能添加实例变量，这成了 Objective-C 的一个明显短板。但可以通过 Associated Objects 来弥补这一不足。</li>
<li>相关函数：<br>与 Associated Objects 相关的函数主要有三个:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);</span><br><span class="line">id objc_getAssociatedObject(id object, const void *key);</span><br><span class="line">void objc_removeAssociatedObjects(id object);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在使用是需要引入 <code>objc/runtime.h</code> 头文件</p>
<ul>
<li>函数的作用：<br>objc_setAssociatedObject 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象；<br>objc_getAssociatedObject 用于获取关联对象；<br>objc_removeAssociatedObjects 用于移除一个对象的所有关联对象。</li>
<li>key值使用：<br>推荐的方法大体有三种：<br>（1）声明 static char kAssociatedObjectKey; 使用 &amp;kAssociatedObjectKey 作为 key 值;<br>（2）声明 static void *kAssociatedObjectKey = &kAssociatedObjectKey; 使用 kAssociatedObjectKey 作为 key 值；<br>（3）用 selector ，使用 getter 方法的名称作为 key 值。</li>
</ul>
<p>我们看到的SDWebInage是使用的 <code>static char kAssociatedObjectKey</code> 这种方法。而 <code>static char</code> 这种声明是C语言的写法，意思是：声明一个局部静态变量。</p>
<p>附上一个讲的很不错的文章：<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">Objective-C Associated Objects 的实现原理</a></p>
<h4 id="7-1-2、第二步"><a href="#7-1-2、第二步" class="headerlink" title="7.1.2、第二步"></a>7.1.2、第二步</h4><p>代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>解析：<br>条件语句判断options选项是否为 <code>SDWebImageDelayPlaceholder</code> 若不是则执行条件语句里的内容。（条件语句中执行的是设置占位符图像，但该选项是延迟占位符加载，所以需要加以判断。）</p>
<p><code>dispatch_main_async_safe(^{})</code> 宏定义主线程异步安全加载，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block) dispatch_queue_async_safe(dispatch_get_main_queue(), block)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef dispatch_queue_async_safe</span><br><span class="line">#define dispatch_queue_async_safe(queue, block)\</span><br><span class="line">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(queue)) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(queue, block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><code>dispatch_main_async_safe</code> 安全的分发任务到主线程里面运行<br><code>dispatch_queue_get_label</code> 用来取队列的名字，进而判断如果当前已经是主队列，那么直接执行，否则回调到主队列之后再执行。</p>
<p>原因是：如果当前队列已经是主队列，那么再调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code>有可能会出现<code>crash</code>。而该方法则很好的做了预防工作。</p>
<p>下面看条件语句中的执行方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock &#123;</span><br><span class="line">#if SD_UIKIT || SD_MAC</span><br><span class="line">    [self sd_setImage:image imageData:imageData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:nil cacheType:0 imageURL:nil];</span><br><span class="line">#else</span><br><span class="line">    // watchOS does not support view transition. Simplify the logic</span><br><span class="line">    if (setImageBlock) &#123;</span><br><span class="line">        setImageBlock(image, imageData);</span><br><span class="line">    &#125; else if ([self isKindOfClass:[UIImageView class]]) &#123;</span><br><span class="line">        UIImageView *imageView = (UIImageView *)self;</span><br><span class="line">        [imageView setImage:image];</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法目的为了执行加载占位符图像。分了两种情况 <code>iOS和VTOS 、masOS系统</code> 和 其他。分类型的原因 <code>SDWebImage</code> 给了简单说明： <code>watchOS</code> 不支持 <code>view</code> 的翻转动画，所以 <code>SDWebImage</code> 做了一个简单的加载显示处理。而其他类型则和图像URL的加载显示共用了一套方法（具体实现在加载URL图像时细看）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(NSURL *)imageURL</span><br></pre></td></tr></table></figure></p>
<h4 id="7-1-3、第三步-正式准备加载URL图像"><a href="#7-1-3、第三步-正式准备加载URL图像" class="headerlink" title="7.1.3、第三步 正式准备加载URL图像"></a>7.1.3、第三步 正式准备加载URL图像</h4><p>同样分两种情况，根据所传的 <code>url</code> 是否存在做区分</p>
<ol>
<li><strong><code>url</code> 不存在情况</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">            [self sd_removeActivityIndicator];</span><br><span class="line">#endif</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>分析：<br>首先确保在线程安全的情况下，如果<code>iOS和VTOS系统</code>就做下移除<strong>加载指示器</strong>操作。<br>如果<code>completedBlock</code>代码块存在，就获取错误信息，执行回调内的操作。<br><code>SDExternalCompletionBlock</code> 的声明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^SDExternalCompletionBlock)(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL);</span><br></pre></td></tr></table></figure></p>
<p>下面是url传nil时的情况：<br><img src="http://obzx0h1re.bkt.clouddn.com/SDWebImage_Error.jpg" alt="SDWebImage_Error"></p>
<ol start="2">
<li><strong><code>url</code> 存在情况</strong></li>
</ol>
<ul>
<li>1、如果是<code>iOS和VTOS</code>的系统，则判断使用显示加载指示器，如果显示则创建并添加到View上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT</span><br><span class="line">        // check if activityView is enabled or not</span><br><span class="line">        if ([self sd_showActivityIndicatorView]) &#123;</span><br><span class="line">            [self sd_addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>配置加载指示器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.customImageView sd_setShowActivityIndicatorView:YES];</span><br><span class="line">[self.customImageView sd_setIndicatorStyle:UIActivityIndicatorViewStyleGray];</span><br></pre></td></tr></table></figure></p>
<ul>
<li>2、根据上下文获取 <code>SDWebImageManager</code></li>
</ul>
<p>根据上下文（<code>context</code>）获取 <code>SDWebImageManager</code>，没有则创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager *manager;</span><br><span class="line">if ([context valueForKey:SDWebImageExternalCustomManagerKey]) &#123;</span><br><span class="line">    manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    manager = [SDWebImageManager sharedManager];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>SDWebImageManager</code>是 <code>SDWebImage</code> 管理以及操作的类。该类是<code>SDWebImage</code>的核心类，拥有一个SDWebImageCache 和 SDWebImageDownloader 属性，分别用于图片缓存和下载处理。</p>
<p>关于 <code>SDWebImageManager</code> 这里不细说，分出去单独研究。</p>
<ul>
<li>3 加载进度回调（或者说加载进度回调中…）</li>
</ul>
<p>下载图像时重复调用该代码块，在后台队列上执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// reset the progress</span><br><span class="line">self.sd_imageProgress.totalUnitCount = 0;</span><br><span class="line">self.sd_imageProgress.completedUnitCount = 0;</span><br><span class="line"></span><br><span class="line">__weak __typeof(self)wself = self;</span><br><span class="line">SDWebImageDownloaderProgressBlock combinedProgressBlock = ^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123;</span><br><span class="line">    wself.sd_imageProgress.totalUnitCount = expectedSize;</span><br><span class="line">    wself.sd_imageProgress.completedUnitCount = receivedSize;</span><br><span class="line">    if (progressBlock) &#123;</span><br><span class="line">        progressBlock(receivedSize, expectedSize, targetURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>代码块中会判断传入的 <code>progressBlock</code> 是否为空，不为空的话执行回调操作，回调方法中开发者可以处理一些其他操作。看下图：</p>
<p><img src="http://obzx0h1re.bkt.clouddn.com/SDWebImage_progressBlock.jpg" alt="SDWebImage_progressBlock"></p>
<h4 id="7-1-4、第四步-加载URL图像"><a href="#7-1-4、第四步-加载URL图像" class="headerlink" title="7.1.4、第四步 加载URL图像"></a>7.1.4、第四步 加载URL图像</h4><p>加载图像的代码比较多，接下来就在代码中加注释分析。<br>加载图像的方法是在 <code>SDWebImageManager</code>类中完成的，这里只是执行加载完成后的代码块中的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock</span><br></pre></td></tr></table></figure></p>
<p>加载图像的过程先不去考虑，先看加载完成后的代码块中执行的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">        </span><br><span class="line">    __strong __typeof (wself) sself = wself; //代码块中创建强引用</span><br><span class="line">    if (!sself) &#123; return; &#125; //如果强引用的self不存在，退出block</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    [sself sd_removeActivityIndicator]; //不是iOS and tvOS系统的话，移除加载指示器</span><br><span class="line">#endif</span><br><span class="line">    // if the progress not been updated, mark it to complete state （如果进度未更新，请将其标记为完成状态）</span><br><span class="line">    if (finished &amp;&amp; !error &amp;&amp; sself.sd_imageProgress.totalUnitCount == 0 &amp;&amp; sself.sd_imageProgress.completedUnitCount == 0) &#123;</span><br><span class="line">    //如果加载结束、没错误、sd_imageProgress.totalUnitCount 和 sd_imageProgress.completedUnitCount 都为0，则设置两者的值为未知值</span><br><span class="line">        sself.sd_imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">        sself.sd_imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   是否应该回调CompletedBlock （ 加载完成 或者 传入的 options 选项 为 SDWebImageAvoidAutoSetImage）</span><br><span class="line">    BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">    </span><br><span class="line">    //判断是否应该不设置Image （如果有图片但设置了SDWebImageAvoidAutoSetImage 或者没有图片并且没有设置SDWebImageDelayPlaceholder）</span><br><span class="line">    BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                              (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br><span class="line">                              </span><br><span class="line">    SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">        //如果view不存在，终止执行</span><br><span class="line">        if (!sself) &#123; return; &#125;</span><br><span class="line">        </span><br><span class="line">        需要设置Image，就刷新视图</span><br><span class="line">        if (!shouldNotSetImage) &#123;</span><br><span class="line">            [sself sd_setNeedsLayout];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果传入了completedBlock并且应该回调，则执行回调</span><br><span class="line">        if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">        //回调</span><br><span class="line">            completedBlock(image, error, cacheType, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set （我们得到了一个图像，但设置了SDWebImageAvoidAutoSetImage标志）</span><br><span class="line">    // OR</span><br><span class="line">    // case 1b: we got no image and the SDWebImageDelayPlaceholder is not set（我们没有图像，并且没有设置SDWebImageDelayPlaceholder标志）</span><br><span class="line">   </span><br><span class="line">   //如果不需要设置图片就在主线程队列种调用上面生成的完成回调代码块，然后停止执行</span><br><span class="line">    if (shouldNotSetImage) &#123;</span><br><span class="line">        dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //初始化变量</span><br><span class="line">    UIImage *targetImage = nil;</span><br><span class="line">    NSData *targetData = nil;</span><br><span class="line">    </span><br><span class="line">    if (image) &#123;</span><br><span class="line">        // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set （我们得到了一个图像，并且没有设置SDWebImageAvoidAutoSetImage）</span><br><span class="line">        //如果图片下载成功就将其保存到变量中</span><br><span class="line">        targetImage = image;</span><br><span class="line">        targetData = data;</span><br><span class="line">    &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">        // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set（我们没有图像，并且设置了SDWebImage Delay Placeholder标志）</span><br><span class="line">        如果图片下载失败并且设置了延迟加载占位符图像，就保存占位符图像</span><br><span class="line">        targetImage = placeholder;</span><br><span class="line">        targetData = nil;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">#if SD_UIKIT || SD_MAC （iOS and tvOS macOS）</span><br><span class="line">    // check whether we should use the image transition（检查我们是否应该使用图像过渡转换）</span><br><span class="line">    SDWebImageTransition *transition = nil;</span><br><span class="line">    //如果加载结束并且options选项为：SDWebImageForceTransition 或者 缓存类型为：SDImageCacheTypeNone</span><br><span class="line">    if (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">    //保存图像过渡转换</span><br><span class="line">        transition = sself.sd_imageTransition;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">    //主线程队列种设置图像</span><br><span class="line">#if SD_UIKIT || SD_MAC （iOS and tvOS macOS）</span><br><span class="line">            设置图像</span><br><span class="line">            [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line">#else</span><br><span class="line">            //iWatchOS系统设置图像</span><br><span class="line">            [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">#endif</span><br><span class="line">            //设置完成后调用完成回调代码块</span><br><span class="line">            callCompletedBlockClojure();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    //SDOperationsDictionary存储当前的操作。</span><br><span class="line">    [self sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面再使用纯描述的方式，过一遍流程：（为了简便，以下：<code>SD_UIKIT || SD_MAC</code> 简称：<code>iOS_tvOS_MAC</code>; <code>SD_MAC</code>简称：<code>MAC</code>  <code>SD_UIKIT</code> 简称 ：<code>iOS_tvOS</code>）</p>
<p><code>__strong</code>在<code>Block</code>内部修饰的对象,会保证,在使用这个对象在block内,这个对象都不会被释放。</p>
<p>之前分析过，加载指示器只能在<code>iOS_tvOS</code>的情况下添加，所以加载完成后需要移除。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT</span><br><span class="line">            [sself sd_removeActivityIndicator];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>如果加载已经完成并且没有错误；iamge进度的总单元和完成单元都是0，就设置<code>imageProgress</code> 的总单元和完成单元值为未知。</p>
<p>创建 “应该执行完成加载的回调” 和 “不应该设置Image” 两个布尔值。<br><code>SDWebImageAvoidAutoSetImage</code>: 在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志<br><code>SDWebImageDelayPlaceholder</code> : 延迟显示占位符图像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//加载完成 或者 传入的 options 选项为 SDWebImageAvoidAutoSetImage</span><br><span class="line">BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">//图片存在并且选项为 SDWebImageAvoidAutoSetImage 或者 图片不存在并且选项不为SDWebImageDelayPlaceholder</span><br><span class="line">BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                                    (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br></pre></td></tr></table></figure>
<p><code>SDWebImageNoParamsBlock</code> 回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                if (!sself) &#123; return; &#125;</span><br><span class="line">                if (!shouldNotSetImage) &#123;</span><br><span class="line">                    //需要设置Image</span><br><span class="line">                    [sself sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                //completedBlock存在并且需要回调</span><br><span class="line">                if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure></p>
<p>不需要设置Image，执行callCompletedBlockClojure回调代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (shouldNotSetImage) &#123;</span><br><span class="line">     dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">     return;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>图像和图像Data赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UIImage *targetImage = nil;</span><br><span class="line">NSData *targetData = nil;</span><br><span class="line">if (image) &#123;</span><br><span class="line">    // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set</span><br><span class="line">    targetImage = image;</span><br><span class="line">    targetData = data;</span><br><span class="line">&#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">    // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set</span><br><span class="line">    targetImage = placeholder;</span><br><span class="line">    targetData = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果系统类型为：<code>iOS_tvOS_MAC</code>，图像过渡动画赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_MAC</span><br><span class="line">    // check whether we should use the image transition</span><br><span class="line">    SDWebImageTransition *transition = nil;</span><br><span class="line">    if (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">        transition = sself.sd_imageTransition;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>执行异步安全加载，根据不同的系统执行不同的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_main_async_safe(^&#123;</span><br><span class="line">#if SD_UIKIT || SD_MAC</span><br><span class="line">                [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line">#else</span><br><span class="line">                [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">#endif</span><br><span class="line">                callCompletedBlockClojure();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure></p>
<p>以上就是大体加载图像所展示的流程</p>
<p>接下来看一下需要动画翻转过渡的代码（可以使用动画过渡的是<code>iOS_tvOS_MAC</code>）<br>其实就是多加了一个转换动画的执行代码。其他的就是UIImageView和UIButton 的图像设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_MAC</span><br><span class="line">- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(NSURL *)imageURL &#123;</span><br><span class="line">    UIView *view = self;</span><br><span class="line">    //最终的图像设置block</span><br><span class="line">    SDSetImageBlock finalSetImageBlock;</span><br><span class="line">    //若setImageBlock，说明是Button需要自定义图像。</span><br><span class="line">    if (setImageBlock) &#123;</span><br><span class="line">        finalSetImageBlock = setImageBlock;</span><br><span class="line">    &#125; else if ([view isKindOfClass:[UIImageView class]]) &#123;</span><br><span class="line">    //若View为ImageView，执行block回调，为imageView赋值</span><br><span class="line">        UIImageView *imageView = (UIImageView *)view;</span><br><span class="line">        finalSetImageBlock = ^(UIImage *setImage, NSData *setImageData) &#123;</span><br><span class="line">            imageView.image = setImage;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    else if ([view isKindOfClass:[UIButton class]]) &#123;</span><br><span class="line">     //若View为button，执行block回调，为button赋值</span><br><span class="line">        UIButton *button = (UIButton *)view;</span><br><span class="line">        finalSetImageBlock = ^(UIImage *setImage, NSData *setImageData)&#123;</span><br><span class="line">            [button setImage:setImage forState:UIControlStateNormal];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    //动画过渡执行代码</span><br><span class="line">    if (transition) &#123;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        [UIView transitionWithView:view duration:0 options:0 animations:^&#123;</span><br><span class="line">            // 0 duration to let UIKit render placeholder and prepares block</span><br><span class="line">            if (transition.prepares) &#123;</span><br><span class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">            [UIView transitionWithView:view duration:transition.duration options:transition.animationOptions animations:^&#123;</span><br><span class="line">                if (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</span><br><span class="line">                    finalSetImageBlock(image, imageData);</span><br><span class="line">                &#125;</span><br><span class="line">                if (transition.animations) &#123;</span><br><span class="line">                    transition.animations(view, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; completion:transition.completion];</span><br><span class="line">        &#125;];</span><br><span class="line">#elif SD_MAC</span><br><span class="line">        [NSAnimationContext runAnimationGroup:^(NSAnimationContext * _Nonnull prepareContext) &#123;</span><br><span class="line">            // 0 duration to let AppKit render placeholder and prepares block</span><br><span class="line">            prepareContext.duration = 0;</span><br><span class="line">            if (transition.prepares) &#123;</span><br><span class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completionHandler:^&#123;</span><br><span class="line">            [NSAnimationContext runAnimationGroup:^(NSAnimationContext * _Nonnull context) &#123;</span><br><span class="line">                context.duration = transition.duration;</span><br><span class="line">                context.timingFunction = transition.timingFunction;</span><br><span class="line">                context.allowsImplicitAnimation = (transition.animationOptions &amp; SDWebImageAnimationOptionAllowsImplicitAnimation);</span><br><span class="line">                if (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</span><br><span class="line">                    finalSetImageBlock(image, imageData);</span><br><span class="line">                &#125;</span><br><span class="line">                if (transition.animations) &#123;</span><br><span class="line">                    transition.animations(view, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; completionHandler:^&#123;</span><br><span class="line">                if (transition.completion) &#123;</span><br><span class="line">                    transition.completion(YES);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">#endif</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (finalSetImageBlock) &#123;</span><br><span class="line">            finalSetImageBlock(image, imageData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>以上就是 <code>SDWebImage</code> 设置图片的整个流程，但只是过了一遍代码而已，内部的实现并没有深入，例如：<code>SDWebImage</code> 的下载、缓存机制。这些都没有深入去了解。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/2/" class="pagination-prev">上一页</a>
  
  
  <a href="/page/4/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Wheat
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'GTM-NHB73SK', 'auto');
    ga('send', 'pageview');

</script>

    
<script>
    var _hmt = _hmt || [];
    ( function () {
        var hm = document.createElement( "script" );
        hm.src = "https://hm.baidu.com/hm.js?ae05530a6a007cdb8063cf611691cc3e";
        var s = document.getElementsByTagName( "script" )[ 0 ];
        s.parentNode.insertBefore( hm, s );
    } )();
</script>

  </div>
</div>
</body>
</html>