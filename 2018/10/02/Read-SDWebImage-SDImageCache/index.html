<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>读 SDWebImage 三 (SDImageCache) | 所念皆星辰 | 踏实、低调、前行。</title>

  
  <meta name="author" content="Wheat">
  

  
  <meta name="description" content="简单的一个技术博客，用来作为学习笔记和日常记录使用。">
  

  
  
  <meta name="keywords" content="SDWebImage">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="读 SDWebImage 三 (SDImageCache)"/>

  <meta property="og:site_name" content="所念皆星辰"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="所念皆星辰" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">所念皆星辰</a>
    </h1>
    <p class="site-description">踏实、低调、前行。</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>读 SDWebImage 三 (SDImageCache)</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/02/Read-SDWebImage-SDImageCache/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-02T02:38:36.000Z">
          2018-10-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p><code>SDImageCache</code> 是 <code>SDWebImage</code> 处理图片缓存的类。图片的存储是针对内存和磁盘有一点区别：内存中直接存储图片，磁盘中存中 <code>imagedata</code><br>在 <code>SDWebImageManager</code> 中使用的存储图片、判断图片是否已存储在磁盘/内存等方法均是调用该类中的方法。<code>SDWebImage</code> 设计时做了很好的分工，以至于去分析代码都带有一种享受感。</p>
<blockquote>
<p>简单做个思考，如果自己实现一个缓存类，需要做哪些东西：<br>1、初始化、缓存地址。<br>3、查询、删除、存储方法（增删改查功能）<br>4、计算缓存大小<br>5、计算缓存数量…</p>
</blockquote>
<p>然后在接下来的分析中看看跟自己的思路的偏差：</p>
<p>在 <code>SDImageCache</code> 的 <code>.h</code> 文件中引用了 <code>SDWebImageCompat</code> 和 <code>SDImageCacheConfig</code> 头文件。<code>SDWebImageCompat</code> 类在 <code>SDWebImageManager</code> 结尾已经分析过，该类只包含一个方法，用来实现图片缩放的操作。</p>
<p><code>SDImageCacheConfig</code> 类则是管理缓存配置信息的，这里先单独拉出来看下</p>
<h3 id="2、SDImageCacheConfig-类"><a href="#2、SDImageCacheConfig-类" class="headerlink" title="2、SDImageCacheConfig 类"></a>2、<code>SDImageCacheConfig</code> 类</h3><p><code>SDImageCacheConfig</code> 类是用于配置缓存信息的，继承自 <code>NSObject</code>。</p>
<h4 id="2-1、-h文件"><a href="#2-1、-h文件" class="headerlink" title="2.1、.h文件"></a>2.1、.h文件</h4><p>缓存配置过期类型，枚举<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, SDImageCacheConfigExpireType) &#123;</span><br><span class="line">    //访问图片时，它将更新此值 （访问日期）</span><br><span class="line">    SDImageCacheConfigExpireTypeAccessDate,</span><br><span class="line">    //图片从磁盘缓存中获取 （修改日期）</span><br><span class="line">    SDImageCacheConfigExpireTypeModificationDate</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义配置属性如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解压缩下载和缓存的图片可以提高性能，但会占用大量内存。</span><br><span class="line"> * 默认为YES。 如果由于过多的内存消耗而遇到崩溃，请将此项设置为NO。</span><br><span class="line"> */</span><br><span class="line">//是否解压图片，默认YES</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否禁用iCloud备份，默认YES</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDisableiCloud;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否使用内存缓存，默认YES</span><br><span class="line"> * 禁用内存缓存时，也会禁用弱内存缓存。</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 控制图片的弱内存缓存的选项.启用时, SDImageCache 的内存缓存将使用弱映射表在存储到内存的同时存储图像，并同时删除.</span><br><span class="line"> * 但是当触发内存警告时，由于弱映射表没有强烈的图像实例引用，即使内存缓存本身被清除，UIImageViews或其他实时实例强烈保留的一些图像也可以再次恢复，以避免 稍后从磁盘缓存或网络重新查询。 这可能对这种情况有所帮助，例如，当app进入后台并清除内存时，会在重新输入前景后导致单元格闪烁。</span><br><span class="line"> * 默认为YES。 您可以动态更改此选项。</span><br><span class="line"> */</span><br><span class="line">//是否使用弱内存缓存，默认为YES</span><br><span class="line">@property (assign, nonatomic) BOOL shouldUseWeakMemoryCache;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从磁盘读取缓存时的读取选项</span><br><span class="line"> * 默认为 0. 可以设置为 `NSDataReadingMappedIfSafe` 以提高性能.</span><br><span class="line"> */</span><br><span class="line">//磁盘缓存读取选项，枚举</span><br><span class="line">@property (assign, nonatomic) NSDataReadingOptions diskCacheReadingOptions;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将缓存写入磁盘时的写入选项</span><br><span class="line"> * 默认为 NSDataWritingAtomic. 可以将其设置为 `NSDataWritingWithoutOverwriting` 以防止覆盖现有文件</span><br><span class="line"> */</span><br><span class="line">//磁盘缓存写入选项，枚举</span><br><span class="line">@property (assign, nonatomic) NSDataWritingOptions diskCacheWritingOptions;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在缓存中保留图片的最长时间，秒为单位</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSInteger maxCacheAge;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 缓存的最大值，字节为单位，默认为0，表示不做限制</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxCacheSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 清理磁盘缓存时将检查清理缓存的属性</span><br><span class="line"> * 默认修改日期</span><br><span class="line"> */</span><br><span class="line">//缓存配置过期类型，枚举 ，默认修改日期</span><br><span class="line">@property (assign, nonatomic) SDImageCacheConfigExpireType diskCacheExpireType;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2、-m文件"><a href="#2-2、-m文件" class="headerlink" title="2.2、.m文件"></a>2.2、.m文件</h4><p>静态不可变 <code>NSInteger</code> 类型的 <code>kDefaultCacheMaxCacheAge</code> 表示在缓存中图像保存时间的最大长度，以秒为单位 默认是一周时间（60 ＊ 60 ＊ 24 ＊ 7）。<br><code>_maxCacheAge</code> 属性在 <code>.h</code> 中声明，可以外部修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</span><br><span class="line"></span><br><span class="line">//属性初始化赋值</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _shouldDisableiCloud = YES;</span><br><span class="line">        _shouldCacheImagesInMemory = YES;</span><br><span class="line">        _shouldUseWeakMemoryCache = YES;</span><br><span class="line">        _diskCacheReadingOptions = 0;</span><br><span class="line">        _diskCacheWritingOptions = NSDataWritingAtomic;</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line">        _maxCacheSize = 0;</span><br><span class="line">        _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、SDImageCache类"><a href="#3、SDImageCache类" class="headerlink" title="3、SDImageCache类"></a>3、<code>SDImageCache</code>类</h3><p><code>SDImageCache</code> 维护内存缓存和可选的磁盘缓存。磁盘缓存写入操作是异步执行的，因此不会给UI增加不必要的延迟。</p>
<h4 id="3-1、-h文件"><a href="#3-1、-h文件" class="headerlink" title="3.1、.h文件"></a>3.1、.h文件</h4><p><strong>缓存类型，枚举</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 图像不能用 SDWebImage 缓存，但能从网上下载 （不缓存）。</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line">    /**</span><br><span class="line">     * 图片从磁盘中获取（缓存到磁盘中）</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line">    /**</span><br><span class="line">     *图片从内存中获取（缓存到内存中）</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheTypeMemory</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>缓存选项，枚举</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDImageCacheOptions) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此选项可以强制同时查询磁盘数据。</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheQueryDataWhenInMemory = 1 &lt;&lt; 0,</span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此选项可以强制同步查询磁盘缓存。</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheQueryDiskSync = 1 &lt;&lt; 1,</span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，图像会根据其原始大小进行解码。在iOS上，此选项会将图像缩小到与设备的受限内存兼容的大小。</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheScaleDownLargeImages = 1 &lt;&lt; 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>三个回调代码块</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询完成的block</span><br><span class="line">typedef void(^SDCacheQueryCompletedBlock)(UIImage * _Nullable image, NSData * _Nullable data, SDImageCacheType cacheType);</span><br><span class="line"></span><br><span class="line">//检查完成的block</span><br><span class="line">typedef void(^SDWebImageCheckCacheCompletionBlock)(BOOL isInCache);</span><br><span class="line"></span><br><span class="line">//计算缓存大小的block</span><br><span class="line">typedef void(^SDWebImageCalculateSizeBlock)(NSUInteger fileCount, NSUInteger totalSize);</span><br></pre></td></tr></table></figure>
<p><strong>SDImageCache的属性 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  缓存配置对象，存储所有类型的设置</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCost;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 缓存应持有的对象的的最大数量。</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;</span><br></pre></td></tr></table></figure>
<p><strong>SDImageCache的单例和初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回全局共享缓存实例</span><br><span class="line"> *</span><br><span class="line"> * @return SDImageCache全局实例</span><br><span class="line"> */</span><br><span class="line">+ (nonnull instancetype)sharedImageCache;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用特定命名空间初始化一个新的缓存存储，里面就是去获取磁盘缓存路径，然后在进行一系列的初始化操作</span><br><span class="line"> *</span><br><span class="line"> * @param ns 用于此缓存存储的命名空间</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用特定的命名空间和目录初始化一个新的缓存存储</span><br><span class="line"> * @param ns 用于此缓存存储的命名空间</span><br><span class="line"> * @param directory 用于缓存磁盘映像的目录</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p><strong>缓存路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//初始化磁盘缓存路径</span><br><span class="line">- (nullable NSString *)makeDiskCachePath:(nonnull NSString*)fullNamespace;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 添加只读缓存路径用来搜索由SDImageCache预先缓存的图片</span><br><span class="line"> * 如果想要预先加载的图片和应用程序捆绑在一起，则非常有用。去找图片也可以在这个路径中添加</span><br><span class="line"> *</span><br><span class="line"> * @param path 此只读缓存路径使用的路径</span><br><span class="line"> */</span><br><span class="line">- (void)addReadOnlyCachePath:(nonnull NSString *)path;</span><br></pre></td></tr></table></figure>
<p><strong>存储操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> *</span><br><span class="line"> * @param image           需要缓存的图片</span><br><span class="line"> * @param key             唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param completionBlock 操作完成后执行的块</span><br><span class="line"> */</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> * （根据toDisk来判断是否要存储到磁盘中，这里的磁盘缓存是可选的）</span><br><span class="line"> * @param image           需要缓存的图片</span><br><span class="line"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param toDisk          是否缓存到磁盘中</span><br><span class="line"> * @param completionBlock 操作完成后执行的块</span><br><span class="line"> */</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> * （这里面的方法会根据imageData如果没有，但是image有的话，就会考虑到图片格式的问题）</span><br><span class="line"> * @param image         需要缓存的图片</span><br><span class="line"> * @param imageData     服务器返回的图像数据，此表示将用于磁盘存储，而不是将给定的图像对象转换为可存储/压缩的图像格式，以节省质量和CPU</span><br><span class="line"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param toDisk          是否缓存到磁盘中</span><br><span class="line"> * @param completionBlock 操作完成后执行的块</span><br><span class="line"> */</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据key将图片data同步缓存到内存和磁盘中</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * @param imageData  需要缓存的图片data</span><br><span class="line"> * @param key       唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> */</span><br><span class="line">- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key;</span><br></pre></td></tr></table></figure>
<p><strong>查询和检索操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  异步检查磁盘缓存中是否存在图片（不加载图片），回调返回结果</span><br><span class="line"> *</span><br><span class="line"> *  @param key             描述url的key</span><br><span class="line"> *  @param completionBlock 检查完成时要执行的块。</span><br><span class="line"> *  @note  将在主队列上始终执行完成块</span><br><span class="line"> */</span><br><span class="line">- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果</span><br><span class="line"> *</span><br><span class="line"> *  @param key             描述url的key</span><br><span class="line"> */</span><br><span class="line">- (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  根据key同步查询图片数据data</span><br><span class="line"> *</span><br><span class="line"> *  @param key 用来存储所需图片唯一的key</span><br><span class="line"> *  @return  根据key返回查找的图片，如果未找到，返回nil</span><br><span class="line"> */</span><br><span class="line">- (nullable NSData *)diskImageDataForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步查询缓存并在完成后调用完成的操作。</span><br><span class="line"> *</span><br><span class="line"> * @param key      用来存储所需图片唯一的key</span><br><span class="line"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span><br><span class="line"> *</span><br><span class="line"> * @return       包含缓存操作的NSOperation实例</span><br><span class="line"> */</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步查询缓存并在完成后调用完成的操作。</span><br><span class="line"> *</span><br><span class="line"> * @param key      用来存储所需图片唯一的key</span><br><span class="line"> * @param options  用于指定用于此高速缓存查询的选项</span><br><span class="line"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span><br><span class="line"> *</span><br><span class="line"> * @return     包含缓存操作的NSOperation实例</span><br><span class="line"> */</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 同步查询内存缓存</span><br><span class="line"> *</span><br><span class="line"> * @param key     用来存储所需图片唯一的key</span><br><span class="line"> * @return 根据key返回查找的图片，如果未找到，返回nil</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 同步查询磁盘缓存</span><br><span class="line"> *</span><br><span class="line"> * @param key 用来存储所需图片唯一的key</span><br><span class="line"> * @return 根据key返回查找的图片，如果未找到，返回nil</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 检查缓存后，同步查询缓存（磁盘或内存）</span><br><span class="line"> *</span><br><span class="line"> * @param key 用来存储所需图片唯一的key</span><br><span class="line"> * @return 根据key返回查找的图片，如果未找到，返回nil</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key;</span><br></pre></td></tr></table></figure>
<p><strong>移除操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从内存或者磁盘缓存中异步移除图片</span><br><span class="line"> *</span><br><span class="line"> * @param key            唯一的图片缓存key</span><br><span class="line"> * @param completion      删除图像后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从内存和可选磁盘缓存中异步移除图片</span><br><span class="line"> *</span><br><span class="line"> * @param key            唯一的图片缓存key</span><br><span class="line"> * @param fromDisk        是否也从磁盘中移除</span><br><span class="line"> * @param completion      删除图像后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br></pre></td></tr></table></figure>
<p><strong>缓存清理操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 清理所有的内存缓存图片</span><br><span class="line"> */</span><br><span class="line">- (void)clearMemory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步清除所有磁盘缓存的图片。 非阻塞方法 - 立即返回。</span><br><span class="line"> * @param completion   缓存过期完成后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line">- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步从磁盘中删除所有过期的缓存图片。 非阻塞方法 - 立即返回。</span><br><span class="line"> * @param completionBlock 缓存过期完成后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br></pre></td></tr></table></figure>
<p><strong>缓存信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取磁盘缓存使用的大小</span><br><span class="line"> */</span><br><span class="line">- (NSUInteger)getSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取磁盘缓存中的图片数量</span><br><span class="line"> */</span><br><span class="line">- (NSUInteger)getDiskCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步计算磁盘缓存的大小。</span><br><span class="line"> */</span><br><span class="line">- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock;</span><br></pre></td></tr></table></figure>
<p><strong>缓存路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  需要根路径和key来查询文件所在的位置 (需要缓存路径根文件夹）</span><br><span class="line"> *</span><br><span class="line"> *  @param key  the key (可以使用cacheKeyForURL从url获取)</span><br><span class="line"> *  @param path 缓存路径根文件夹</span><br><span class="line"> *</span><br><span class="line"> *  @return 缓存路径</span><br><span class="line"> */</span><br><span class="line">- (nullable NSString *)cachePathForKey:(nullable NSString *)key inPath:(nonnull NSString *)path;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  根据key获取相应文件的默认的缓存路径</span><br><span class="line"> *</span><br><span class="line"> *  @param key the key (可以使用cacheKeyForURL从url获取)</span><br><span class="line"> *</span><br><span class="line"> *  @return 默认的缓存路径</span><br><span class="line"> */</span><br><span class="line">- (nullable NSString *)defaultCachePathForKey:(nullable NSString *)key;</span><br></pre></td></tr></table></figure>
<h4 id="3-2、-m文件"><a href="#3-2、-m文件" class="headerlink" title="3.2、.m文件"></a>3.2、.m文件</h4><p>C语言函数，本质是计算diskImage所要占用的字节数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;</span><br><span class="line">#if SD_MAC</span><br><span class="line">    return image.size.height * image.size.width;</span><br><span class="line">#elif SD_UIKIT || SD_WATCH</span><br><span class="line">    return image.size.height * image.size.width * image.scale * image.scale;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>私有</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">// Private</span><br><span class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, nonnull) SDImageCacheConfig *config;</span><br><span class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; // strong-weak cache</span><br><span class="line">@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; // a lock to keep the access to `weakCache` thread-safe</span><br><span class="line"></span><br><span class="line">- (instancetype)init NS_UNAVAILABLE;</span><br><span class="line">- (instancetype)initWithConfig:(nonnull SDImageCacheConfig *)config;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SDMemoryCache</span><br><span class="line"></span><br><span class="line">目前这似乎没有用在macOS上（macOS使用虚拟内存，并且在内存警告时不清除缓存）。 所以我们只在iOS / tvOS平台上覆盖。</span><br><span class="line">//但是将来可能会有更多的子类选项和功能。</span><br><span class="line">#if SD_UIKIT</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    //移除内存警告通知</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // 使用存储二级缓存的强弱映射表。 按照NSCache不复制密钥的文档</span><br><span class="line">        // 当内存警告，缓存被清除时，这很有用。 但是，图像实例可以由其他实例保留，例如imageViews和alive。</span><br><span class="line">        // 在这种情况下，我们可以同步弱缓存，而不需要从磁盘缓存加载</span><br><span class="line">        self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class="line">        self.weakCacheLock = dispatch_semaphore_create(1);</span><br><span class="line">        self.config = config;</span><br><span class="line">        //添加内粗警告的通知</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(didReceiveMemoryWarning:)</span><br><span class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning:(NSNotification *)notification &#123;</span><br><span class="line">    //只删除缓存，但保持弱缓存</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// `setObject:forKey:` 只需调用0即可，覆盖这就足够了</span><br><span class="line">- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g &#123;</span><br><span class="line">    //调用系统的NSCache方法</span><br><span class="line">    [super setObject:obj forKey:key cost:g];</span><br><span class="line">    //如果缓存配置不使用弱内存缓存，返回</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &amp;&amp; obj) &#123;</span><br><span class="line">        //若果key和obj存在，存储弱缓存</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        [self.weakCache setObject:obj forKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过key获取object</span><br><span class="line">- (id)objectForKey:(id)key &#123;</span><br><span class="line">    id obj = [super objectForKey:key];</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &amp;&amp; !obj) &#123;</span><br><span class="line">        // 若果key存在，obj不存在，存储弱缓存</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        obj = [self.weakCache objectForKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">        if (obj) &#123;</span><br><span class="line">            //同步缓存</span><br><span class="line">            NSUInteger cost = 0;</span><br><span class="line">            if ([obj isKindOfClass:[UIImage class]]) &#123;</span><br><span class="line">                //diskImage所要占用的字节数</span><br><span class="line">                cost = SDCacheCostForImage(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            [super setObject:obj forKey:key cost:cost];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据key移除对象</span><br><span class="line">- (void)removeObjectForKey:(id)key &#123;</span><br><span class="line">    [super removeObjectForKey:key];</span><br><span class="line">    //如果缓存配置不使用弱内存缓存，返回</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        // 如果key存在，移除缓存</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        [self.weakCache removeObjectForKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//移除所有对象</span><br><span class="line">- (void)removeAllObjects &#123;</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">    //如果缓存配置不使用弱内存缓存，返回</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 手动删除也应该删除弱缓存</span><br><span class="line">    LOCK(self.weakCacheLock);</span><br><span class="line">    [self.weakCache removeAllObjects];</span><br><span class="line">    UNLOCK(self.weakCacheLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">//如果是macos，直接初始化</span><br><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><strong>属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCache ()</span><br><span class="line"></span><br><span class="line">#pragma mark - 属性</span><br><span class="line">//内存缓存</span><br><span class="line">@property (strong, nonatomic, nonnull) SDMemoryCache *memCache;</span><br><span class="line">//磁盘缓存路径</span><br><span class="line">@property (strong, nonatomic, nonnull) NSString *diskCachePath;</span><br><span class="line">//自定义路径</span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableArray&lt;NSString *&gt; *customPaths;</span><br><span class="line">@property (strong, nonatomic, nullable) dispatch_queue_t ioQueue;</span><br><span class="line">//文件管理器</span><br><span class="line">@property (strong, nonatomic, nonnull) NSFileManager *fileManager;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><strong>初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 单例, 初始化, dealloc</span><br><span class="line"></span><br><span class="line">+ (nonnull instancetype)sharedImageCache &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    //初始化，namespace 默认为：default</span><br><span class="line">    return [self initWithNamespace:@&quot;default&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns &#123;</span><br><span class="line">    //获取磁盘缓存路径，默认的是：~/default （ns为default，拼接到缓存路径的最后面）</span><br><span class="line">    NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">    return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line">        </span><br><span class="line">        // 创建IO串行队列</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        </span><br><span class="line">        //初始化缓存配置</span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        </span><br><span class="line">        // 初始化内存缓存</span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        // 初始化磁盘缓存</span><br><span class="line">        if (directory != nil) &#123;</span><br><span class="line">        //如果路径不为nil，在路径的结尾拼接fullNamespace</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           //如果路径为nil，获取路径</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            //初始化文件管理器</span><br><span class="line">            self.fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        //添加删除通知</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(deleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line"></span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缓存路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//添加只读缓存路径用来搜索由SDImageCache预先缓存的图片</span><br><span class="line">- (void)addReadOnlyCachePath:(nonnull NSString *)path &#123;</span><br><span class="line">    if (!self.customPaths) &#123;</span><br><span class="line">        self.customPaths = [NSMutableArray new];</span><br><span class="line">    &#125;</span><br><span class="line">    //不包含就添加</span><br><span class="line">    if (![self.customPaths containsObject:path]) &#123;</span><br><span class="line">        [self.customPaths addObject:path];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//需要根路径和key来查询文件所在的位置 (需要缓存路径根文件夹）</span><br><span class="line">- (nullable NSString *)cachePathForKey:(nullable NSString *)key inPath:(nonnull NSString *)path &#123;</span><br><span class="line">    //根据key获取缓存文件名</span><br><span class="line">    NSString *filename = [self cachedFileNameForKey:key];</span><br><span class="line">    return [path stringByAppendingPathComponent:filename];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据key获取默认缓存路径</span><br><span class="line">- (nullable NSString *)defaultCachePathForKey:(nullable NSString *)key &#123;</span><br><span class="line">    return [self cachePathForKey:key inPath:self.diskCachePath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据key获取缓存文件名</span><br><span class="line">- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key &#123;</span><br><span class="line">    const char *str = key.UTF8String;</span><br><span class="line">    if (str == NULL) &#123;</span><br><span class="line">        str = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</span><br><span class="line">                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]];</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据fullNamespace获取磁盘缓存路径</span><br><span class="line">- (nullable NSString *)makeDiskCachePath:(nonnull NSString*)fullNamespace &#123;</span><br><span class="line">    NSArray&lt;NSString *&gt; *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);</span><br><span class="line">    return [paths[0] stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>存储操作</strong></p>
<p>根据key将图片异步缓存到内存和磁盘中（默认存到内存和磁盘）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> *</span><br><span class="line"> * @param image           需要缓存的图片</span><br><span class="line"> * @param key             唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param completionBlock 操作完成后执行的块</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    [self storeImage:image imageData:nil forKey:key toDisk:YES completion:completionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key将图片异步缓存到内存和磁盘中 （默认存储到内存，根据判断是否存储到磁盘中）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> * （根据toDisk来判断是否要存储到磁盘中，这里的磁盘缓存是可选的）</span><br><span class="line"> * @param image           需要缓存的图片</span><br><span class="line"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param toDisk          是否缓存到磁盘中</span><br><span class="line"> * @param completionBlock 操作完成后执行的块</span><br><span class="line"> */</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    [self storeImage:image imageData:nil forKey:key toDisk:toDisk completion:completionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key将图片异步缓存到内存和磁盘中 （默认存储到内存，根据判断是否存储到磁盘）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key将图片异步缓存到内存和磁盘中</span><br><span class="line"> * （这里面的方法会根据imageData如果没有，但是image有的话，就会考虑到图片格式的问题）</span><br><span class="line"> * @param image         需要缓存的图片</span><br><span class="line"> * @param imageData     服务器返回的图像数据，此表示将用于磁盘存储，而不是将给定的图像对象转换为可存储/压缩的图像格式，以节省质量和CPU</span><br><span class="line"> * @param key            唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> * @param toDisk          是否缓存到磁盘中</span><br><span class="line"> * @param completionBlock 操作完成后执行的块  typedef void(^SDWebImageNoParamsBlock)(void); 不需要传任何参数</span><br><span class="line"> */ </span><br><span class="line"></span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    //若图片或者key不存在，则不存储，执行回调，返回</span><br><span class="line">    if (!image || !key) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果启用了内存缓存</span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        //根据key缓存image，</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //若需要缓存到磁盘</span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        //异步执行缓存操作</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            @autoreleasepool &#123; //自动释放池（里面创建了很多临时变量，当@autoreleasepool结束时，里面的内存就会回收）</span><br><span class="line">                NSData *data = imageData;</span><br><span class="line">                if (!data &amp;&amp; image) &#123;</span><br><span class="line">                    // 如果我们没有任何数据来检测图像格式，请检查它是否包含使用PNG或JPEG格式的Alpha通道</span><br><span class="line">                    SDImageFormat format;</span><br><span class="line">                    if (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</span><br><span class="line">                        format = SDImageFormatPNG;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        format = SDImageFormatJPEG;</span><br><span class="line">                    &#125;</span><br><span class="line">                    将图片编码为图片数据，该方法在SDWebImageCoder类中</span><br><span class="line">                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</span><br><span class="line">                &#125;</span><br><span class="line">                //根据key存储imageData</span><br><span class="line">                [self _storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //如果需要回调，在主线程执行回调</span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       //如果不存储磁盘，执行完成回调</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key将图片data同步缓存到磁盘中<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key将图片data同步缓存到内存和磁盘中</span><br><span class="line"> *</span><br><span class="line"> * @param imageData  需要缓存的图片data</span><br><span class="line"> * @param key       唯一的缓存图片的key,通常是图像的绝对URL</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</span><br><span class="line">     //若图片或者key不存在，则不能存储</span><br><span class="line">    if (!imageData || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        [self _storeImageDataToDisk:imageData forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key将图片data同步缓存到内存和磁盘中（确保通过调用者调用表单io队列）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</span><br><span class="line">    //若图片或者key不存在，则不能存储</span><br><span class="line">    if (!imageData || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果文件管理器中不存在磁盘缓存的路径，则创建</span><br><span class="line">    if (![self.fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [self.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //通过key获取缓存路径</span><br><span class="line">    NSString *cachePathForKey = [self defaultCachePathForKey:key];</span><br><span class="line">    // 转换成 NSUrl</span><br><span class="line">    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line">    </span><br><span class="line">    //将图片写入fileURL中（options写入的选项，默认的配置为：NSDataWritingAtomic）</span><br><span class="line">    [imageData writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</span><br><span class="line">    </span><br><span class="line">    // 禁用iCloud备份</span><br><span class="line">    if (self.config.shouldDisableiCloud) &#123;</span><br><span class="line">        //NSURLIsExcludedFromBackupKey：如果应从备份中排除资源，则为true，否则为false（读写，值类型为boolean NSNumber）。 此属性仅用于排除备份中不需要的缓存和其他应用程序支持文件。 通常对用户文档执行的某些操作将导致此属性重置为false，因此不应在用户文档上使用此属性。</span><br><span class="line">        [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>查询和检索操作</strong></p>
<p>异步检查磁盘缓存中是否存在图片（不加载图片），回调返回结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  异步检查串行队列的磁盘缓存中是否存在图片（不加载图片），回调返回结果</span><br><span class="line"> *</span><br><span class="line"> *  @param key             描述url的key</span><br><span class="line"> *  @param completionBlock 检查完成时要执行的块。</span><br><span class="line"> *  @note  将在主队列上始终执行完成块</span><br><span class="line"> */</span><br><span class="line">- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        // 根据key判断磁盘中是否图片数据</span><br><span class="line">        BOOL exists = [self _diskImageDataExistsWithKey:key];</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            //如果回调代码存在，主线程执行完成查询的回调</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(exists);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  同步检查磁盘缓存中是否存在图片（不加载图片），直接返回结果</span><br><span class="line"> *</span><br><span class="line"> *  @param key             描述url的key</span><br><span class="line"> */</span><br><span class="line">- (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    //如果key不存在，返回查询结果为NO ，否则同步根据key同步查询是否存在图片，返回结果</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    __block BOOL exists = NO;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        exists = [self _diskImageDataExistsWithKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key判断磁盘中是否存在图片数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)_diskImageDataExistsWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    //如果key不存在，返回查询结果为NO </span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    //key存在，则判断文件管理器中是否存在该key的缓存路径，如果存在返回，</span><br><span class="line">    BOOL exists = [self.fileManager fileExistsAtPath:[self defaultCachePathForKey:key]];</span><br><span class="line">    </span><br><span class="line">    // 如果不存在，进一步判断是否存在该key删除扩展名的缓存路径，返回判断结果</span><br><span class="line">    if (!exists) &#123;</span><br><span class="line">        //stringByDeletingPathExtension：从文件的最后一部分删除扩展名</span><br><span class="line">        exists = [self.fileManager fileExistsAtPath:[self defaultCachePathForKey:key].stringByDeletingPathExtension];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key同步查询图片数据data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSData *)diskImageDataForKey:(nullable NSString *)key &#123;</span><br><span class="line">     //如果key不存在，返回nil</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //根据key搜索所有的路径获取磁盘图片data</span><br><span class="line">    __block NSData *imageData = nil;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        imageData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key同步查询内存缓存图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    return [self.memCache objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key同步查询磁盘缓存图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    //根据key查询磁盘缓存图片，最终调用的是：- (UIImage *)diskImageForKey: data: options:这个方法</span><br><span class="line">    UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">    </span><br><span class="line">    //如果图片存在，并且需要缓存到内存中，则计算所占用字节数，并缓存到内存中</span><br><span class="line">    if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return diskImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>检查缓存后，同步查询缓存（磁盘或内存）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    // 先从内存中查询缓存图片，如果存在，结束查询并返回图片</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果内存中未查到该key的图片，则从磁盘中查询，返回最后查询的结果</span><br><span class="line">    image = [self imageFromDiskCacheForKey:key];</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key搜索所有的路径获取磁盘图片data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123;</span><br><span class="line">    //根据key获取默认的缓存路径</span><br><span class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</span><br><span class="line">    //self.config.diskCacheReadingOptions ：默认是0，即：NSDataReadingMappedIfSafe</span><br><span class="line">    //根据缓存路径和磁盘缓存读取选项，获取图片data，若存在则返回data，不存在则继续读取该key删除扩展名的缓存路径</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //读取该key删除扩展名的缓存路径，获取图片data，若存在则返回data</span><br><span class="line">    data = [NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    如果上面均未读取tupiandata，则依据上面的方法查找自定义路径，若存在返回data，如果仍未找到则返回nil</span><br><span class="line">    NSArray&lt;NSString *&gt; *customPaths = [self.customPaths copy];</span><br><span class="line">    for (NSString *path in customPaths) &#123;</span><br><span class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imageData = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key获取磁盘图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">缓存图片到磁盘是存储的imageData；到内存是存储的image。</span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key &#123;</span><br><span class="line">    //现获取imagedata，再转换成image</span><br><span class="line">    NSData *data = [self diskImageDataForKey:key];</span><br><span class="line">    return [self diskImageForKey:key data:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据key和data得到磁盘图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data &#123;</span><br><span class="line">    return [self diskImageForKey:key data:data options:0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//最终调用的方法，根据key和data、选项获取磁盘图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data options:(SDImageCacheOptions)options &#123;</span><br><span class="line">    //如果图片的data存在，进行进一步的转换，否则返回nil</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        //将data转换成image</span><br><span class="line">        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];</span><br><span class="line">        //对图片进行缩放操作</span><br><span class="line">        image = [self scaledImageForKey:key image:image];</span><br><span class="line">        //如果需要解压缩操作，就进行其操作，否则直接返回图片</span><br><span class="line">        if (self.config.shouldDecompressImages) &#123;</span><br><span class="line">            //默认情况下，图像会根据其原始大小进行解码。在iOS上，此选项会将图像缩小到与设备的受限内存兼容的大小。</span><br><span class="line">            BOOL shouldScaleDown = options &amp; SDImageCacheScaleDownLargeImages;</span><br><span class="line">            /**</span><br><span class="line">              *- (nullable UIImage *)decompressedImageWithImage:(nullable UIImage *)image</span><br><span class="line">                                            data:(NSData * _Nullable * _Nonnull)data</span><br><span class="line">                                         options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict;</span><br><span class="line">              * 使用原始图像和图像数据解压缩图像。</span><br><span class="line">              *</span><br><span class="line">              * @param image要解压缩的原始图像</span><br><span class="line">              * @param data指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span><br><span class="line">              * @param optionsDict包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span><br><span class="line">              * @return解压缩的图像</span><br><span class="line">              */</span><br><span class="line">            </span><br><span class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//图片缩放操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)scaledImageForKey:(nullable NSString *)key image:(nullable UIImage *)image &#123;</span><br><span class="line">    return SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异步查询缓存并在完成后调用完成的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步查询缓存并在完成后调用完成的操作。</span><br><span class="line"> *</span><br><span class="line"> * @param key      用来存储所需图片唯一的key</span><br><span class="line"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span><br><span class="line"> *</span><br><span class="line"> * @return       包含缓存操作的NSOperation实例</span><br><span class="line"> */</span><br><span class="line">- (NSOperation *)queryCacheOperationForKey:(NSString *)key done:(SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    return [self queryCacheOperationForKey:key options:0 done:doneBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异步查询缓存并在完成后调用完成的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步查询缓存并在完成后调用完成的操作。</span><br><span class="line"> *</span><br><span class="line"> * @param key      用来存储所需图片唯一的key</span><br><span class="line"> * @param options  用于指定用于此高速缓存查询的选项</span><br><span class="line"> * @param doneBlock The completion block. 如果操作被取消，则不会被调用</span><br><span class="line"> *</span><br><span class="line"> * @return     包含缓存操作的NSOperation实例</span><br><span class="line"> */</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    //如果key不存在，返回查询操作为nil，如果执行回调，则image，data传nil，类型传SDImageCacheTypeNone</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(nil, nil, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 先从内存中查找图片，</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</span><br><span class="line">    如果image存在，并且只从内存中查找，返回NSOperation为nil，，如果执行回调，则传image为查找的image，data传nil，类型传SDImageCacheTypeMemory</span><br><span class="line">    if (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, nil, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //创建一个NSOperation来获取磁盘图片</span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    void(^queryDiskBlock)(void) =  ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            // 如果操作被取消，则不执行回调</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //在自动释放池中执行，当@autoreleasepool结束时，里面的内存就会回收</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            //获取缓存data</span><br><span class="line">            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            UIImage *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                // 如果从内存中查找的image存在，赋值给diskImage，缓存类型为SDImageCacheTypeMemory</span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">            &#125; else if (diskData) &#123;</span><br><span class="line">                // 如果内存缓存未找到image，并且缓存data存在，通过diskData转换为image</span><br><span class="line">                diskImage = [self diskImageForKey:key data:diskData options:options];</span><br><span class="line">                if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                    //磁盘图片存在，并且需要缓存到内存，则做内存存储图片操作</span><br><span class="line">                    NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                    [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //完成回调存在，如果选项为：SDImageCacheQueryDiskSync（此选项可以强制同步查询磁盘缓存），则执行同步回调，否则在主线程执行回调</span><br><span class="line">            if (doneBlock) &#123;</span><br><span class="line">                if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    //如果选项为：SDImageCacheQueryDiskSync（此选项可以强制同步查询磁盘缓存），则执行同步执行上面的queryDiskBlock代码块，否则异步执行</span><br><span class="line">    if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">        queryDiskBlock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>移除操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从内存或者磁盘缓存中异步移除图片</span><br><span class="line"> *</span><br><span class="line"> * @param key            唯一的图片缓存key</span><br><span class="line"> * @param completion      删除图像后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    [self removeImageForKey:key fromDisk:YES withCompletion:completion];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line"> * 从内存和可选磁盘缓存中异步移除图片</span><br><span class="line"> *</span><br><span class="line"> * @param key            唯一的图片缓存key</span><br><span class="line"> * @param fromDisk        是否也从磁盘中移除</span><br><span class="line"> * @param completion      删除图像后应执行的块（可选）</span><br><span class="line"> */</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    //key为空，返回</span><br><span class="line">    if (key == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果缓存配置允许缓存到内存上，则需要在内存上也删除该key的缓存</span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        [self.memCache removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    //如果需要从磁盘上移除缓存，则执行磁盘移除缓存操作</span><br><span class="line">    if (fromDisk) &#123;</span><br><span class="line">        //异步执行移除磁盘缓存操作</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            [self.fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil];</span><br><span class="line">            </span><br><span class="line">            //主线程执行完成回调</span><br><span class="line">            if (completion) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completion();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (completion)&#123;</span><br><span class="line">        //执行完成回调</span><br><span class="line">        completion();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缓存清理操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">//清理缓存</span><br><span class="line">- (void)clearMemory &#123;</span><br><span class="line">    //清理所有内存缓存</span><br><span class="line">    [self.memCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异步清理磁盘缓存，回调结果</span><br><span class="line">- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        //删除该磁盘缓存路径，之后再重新创建一个作为新的缓存路径（其实就是同一个路径，目的就是删除缓存数据）</span><br><span class="line">        [self.fileManager removeItemAtPath:self.diskCachePath error:nil];</span><br><span class="line">        [self.fileManager createDirectoryAtPath:self.diskCachePath</span><br><span class="line">                withIntermediateDirectories:YES</span><br><span class="line">                                 attributes:nil</span><br><span class="line">                                      error:NULL];</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            //主线程执行完成回调</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completion();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除过期的文件</span><br><span class="line">- (void)deleteOldFiles &#123;</span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异步从磁盘中删除所有过期的缓存图片</span><br><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        //获取磁盘缓存的默认根目录</span><br><span class="line">        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">        // 计算用于测试的内容日期key</span><br><span class="line">        NSURLResourceKey cacheContentDateKey = NSURLContentModificationDateKey;</span><br><span class="line">        switch (self.config.diskCacheExpireType) &#123;</span><br><span class="line">            case SDImageCacheConfigExpireTypeAccessDate:</span><br><span class="line">                cacheContentDateKey = NSURLContentAccessDateKey;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case SDImageCacheConfigExpireTypeModificationDate:</span><br><span class="line">                cacheContentDateKey = NSURLContentModificationDateKey;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //记录遍历需要预先获取文件的哪些属性</span><br><span class="line">        NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, cacheContentDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">        // diskCacheURL 和 resourceKeys 这两个变量主要是为了下面生成NSDirectoryEnumerator准备的</span><br><span class="line">        //此枚举器为我们的缓存文件预取有用的属性。</span><br><span class="line">        /**</span><br><span class="line">          * 递归地遍历diskCachePath这个文件夹中的所有目录，此处不是直接使用diskCachePath，而是使用其生成的NSURL</span><br><span class="line">          * 此处使用includingPropertiesForKeys:resourceKeys，这样每个file的resourceKeys对应的属性也会在遍历时预先获取到</span><br><span class="line">          * NSDirectoryEnumerationSkipsHiddenFiles表示不遍历隐藏文件</span><br><span class="line">          */</span><br><span class="line"></span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">          * 获取文件的过期时间，SDWebImage中默认是一个星期</span><br><span class="line">          * expirationDate为过期时间，例如：现在时间是2018/10/16/00:00:00，当前时间减去1个星期，得到</span><br><span class="line">          * 2018/10/09/00:00:00，这个时间为函数中的expirationDate</span><br><span class="line">          * 用这个expirationDate和最后一次修改时间modificationDate比较看谁更晚就行</span><br><span class="line">          */</span><br><span class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge];</span><br><span class="line">        //用来存储对应文件的一些属性，比如文件所需磁盘空间</span><br><span class="line">        NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">        //记录党建已经使用的磁盘缓存大小</span><br><span class="line">        NSUInteger currentCacheSize = 0;</span><br><span class="line"></span><br><span class="line">        // 在缓存的目录开始遍历文件.  此次遍历有两个目的:</span><br><span class="line">        //  1. 移除过期的文件</span><br><span class="line">        //  2. 同时存储每个文件的属性（比如该file是否是文件夹、该file所需磁盘大小，修改时间）</span><br><span class="line">        NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSError *error;</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</span><br><span class="line"></span><br><span class="line">            // 当前扫描的是目录，就跳过</span><br><span class="line">            if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 移除过期文件(这里判断过期的方式：对比文件的最后一次修改日期和expirationDate谁更晚，如果expirationDate更晚，就认为该文件已经过期)</span><br><span class="line">            NSDate *modifiedDate = resourceValues[cacheContentDateKey];</span><br><span class="line">            if ([[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 计算当前已经使用的cache大小,并将对应file的属性存到cacheFiles中</span><br><span class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">            cacheFiles[fileURL] = resourceValues;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 根据需要移除文件的url来移除对应file</span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">            [self.fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         // 如果我们当前cache的大小已经超过了允许配置的缓存大小，那就删除已经缓存的文件</span><br><span class="line">         // 删除策略就是，首先删除修改时间更早的缓存文件</span><br><span class="line">        if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123;</span><br><span class="line">            // 直接将当前cache大小降到允许最大的cache大小的一般</span><br><span class="line">            //预期的缓存大小</span><br><span class="line">            const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;</span><br><span class="line"></span><br><span class="line">             // 根据文件修改时间来给所有缓存文件排序，按照修改时间越早越在前的规则排序</span><br><span class="line">            NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</span><br><span class="line">                                                                     usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">                                                                         return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">                                                                     &#125;];</span><br><span class="line"></span><br><span class="line">             // 每次删除file后，就计算此时的cache的大小.</span><br><span class="line">            //如果此时的cache大小已经降到期望的大小了，就停止删除文件了</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">                if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123;</span><br><span class="line">                    // 获取该文件对应的属性</span><br><span class="line">                    NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    // 根据resourceValues获取该文件所需磁盘空间大小</span><br><span class="line">                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                    // 计算当前cache大小</span><br><span class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line"></span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        如果当前的缓存小于预期的缓存，结束删除file操作</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 如果有completionBlock，就在主线程中调用</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">//后台删除过期文件</span><br><span class="line">- (void)backgroundDeleteOldFiles &#123;</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">    //如果backgroundTask对应的时间结束了，任务还没有处理完成，则直接终止任务</span><br><span class="line">    __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        //通过标记您的位置来清理任何未完成的任务业务</span><br><span class="line">        //完全停止或结束任务。</span><br><span class="line">        //当任务非正常终止的时候，做清理工作</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 启动长时间运行的任务并立即返回。</span><br><span class="line">    //图片清理结束以后，处理完成</span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:^&#123;</span><br><span class="line">        //清理完成以后，终止任务</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><strong>缓存信息</strong></p>
<p>获取磁盘缓存使用的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getSize &#123;</span><br><span class="line">    __block NSUInteger size = 0;</span><br><span class="line">    // 需要同步操作：等待队列self.ioQueue中的任务执行完后（有可能队列中的任务正在添加图片或者删除图片操作），再进行获取文件大小计算</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        for (NSString *fileName in fileEnumerator) &#123;</span><br><span class="line">            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *attrs = [self.fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取磁盘缓存中的图片数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getDiskCount &#123;</span><br><span class="line">    __block NSUInteger count = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        count = fileEnumerator.allObjects.count;</span><br><span class="line">    &#125;);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步计算磁盘缓存的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock &#123;</span><br><span class="line">    NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSUInteger fileCount = 0;</span><br><span class="line">        NSUInteger totalSize = 0;</span><br><span class="line"></span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:@[NSFileSize]</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSNumber *fileSize;</span><br><span class="line">            [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL];</span><br><span class="line">            totalSize += fileSize.unsignedIntegerValue;</span><br><span class="line">            fileCount += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(fileCount, totalSize);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>属性Get和Set方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span><br><span class="line">- (NSUInteger)maxMemoryCost &#123;</span><br><span class="line">    return self.memCache.totalCostLimit;</span><br><span class="line">&#125;</span><br><span class="line">//设置缓存中最大的消耗的内存，这里计算的是内存中的像素个数</span><br><span class="line">- (void)setMaxMemoryCost:(NSUInteger)maxMemoryCost &#123;</span><br><span class="line">    self.memCache.totalCostLimit = maxMemoryCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//缓存应持有的对象的的最大数量</span><br><span class="line">- (NSUInteger)maxMemoryCountLimit &#123;</span><br><span class="line">    return self.memCache.countLimit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置缓存应持有的对象的的最大数量</span><br><span class="line">- (void)setMaxMemoryCountLimit:(NSUInteger)maxCountLimit &#123;</span><br><span class="line">    self.memCache.countLimit = maxCountLimit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/读SDWebImage手札/">读SDWebImage手札</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SDWebImage/">SDWebImage</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Wheat
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'GTM-NHB73SK', 'auto');
    ga('send', 'pageview');

</script>

    
<script>
    var _hmt = _hmt || [];
    ( function () {
        var hm = document.createElement( "script" );
        hm.src = "https://hm.baidu.com/hm.js?ae05530a6a007cdb8063cf611691cc3e";
        var s = document.getElementsByTagName( "script" )[ 0 ];
        s.parentNode.insertBefore( hm, s );
    } )();
</script>

  </div>
</div>
</body>
</html>