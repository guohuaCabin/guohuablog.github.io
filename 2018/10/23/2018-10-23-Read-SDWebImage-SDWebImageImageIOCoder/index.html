<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>读 SDWebImage 六 （编码器四：SDWebImageImageIOCoder） | 所念皆星辰</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="灾难总是接踵而至，这正是世间的常理。只要找个理由，就会有谁来救你吗？要是死了，就只是说明我不过是如此程度的男人。">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="读 SDWebImage 六 （编码器四：SDWebImageImageIOCoder） | 所念皆星辰">
    <meta name="twitter:description" content="灾难总是接踵而至，这正是世间的常理。只要找个理由，就会有谁来救你吗？要是死了，就只是说明我不过是如此程度的男人。">

    <meta property="og:type" content="article">
    <meta property="og:title" content="读 SDWebImage 六 （编码器四：SDWebImageImageIOCoder） | 所念皆星辰">
    <meta property="og:description" content="灾难总是接踵而至，这正是世间的常理。只要找个理由，就会有谁来救你吗？要是死了，就只是说明我不过是如此程度的男人。">

    
    <meta name="author" content="Wheat">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="所念皆星辰" href="/atom.xml">
    

    <link rel="canonical" href="https://qinguohua.fun/2018/10/23/2018-10-23-Read-SDWebImage-SDWebImageImageIOCoder/"/>

    
      
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url()">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 所念皆星辰 的主页"><img src="/images/avatar.png" width="80" alt="所念皆星辰 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 所念皆星辰">所念皆星辰</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">踏实、低调、前行。</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">简单的一个技术博客，用来作为学习笔记和日常记录使用。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
              <li class="navigation__item"><a href="/books">读书</a></li>
            
              <li class="navigation__item"><a href="/essays">随笔</a></li>
            
              <li class="navigation__item"><a href="/about">关于</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/guohuaCabin" title="wheat的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- jianshu -->
  

<!-- cnblogs -->
  

<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-blue"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-10-23T13:57:30.000Z" class="post-list__meta--date date">2018-10-23</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/SDWebImage/">SDWebImage</a>
 </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">读 SDWebImage 六 （编码器四：SDWebImageImageIOCoder）</h1>
  </header>

  <section class="post">
    <p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p>
<p><code>SDWebImageImageIOCoder</code> ：内置编码器，支持PNG，JPEG，TIFF，支持逐行解码。该类遵守 <code>SDWebImageProgressiveCoder</code>协议。该协议也遵守<code>SDWebImageCoder</code>协议，所以这个类要实现这两个协议的方法。</p>
<p>  GIF<br>  还支持静态GIF（意思是只处理第一帧）。<br>  要获得完整的GIF支持，我们建议使用<code>FLAnimatedImage</code>或性能较差的<code>SDWebImageGIFCoder</code></p>
<p>  HEIC<br>  该编码器还支持HEIC格式，因为ImageIO本身支持它。但这取决于系统功能，因此无法在所有设备上运行。<a id="more"></a></p>
<h3 id="私有静态常量"><a href="#私有静态常量" class="headerlink" title="私有静态常量"></a>私有静态常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//每像素字节数为4</span><br><span class="line">static const size_t kBytesPerPixel = 4;</span><br><span class="line">//每位字节数为8</span><br><span class="line">static const size_t kBitsPerComponent = 8;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  *设置标志“SDWebImageScaleDownLargeImages”时，解码图像的最大大小（以MB为单位）</span><br><span class="line">  * iPad1和iPhone 3GS的建议值：60。</span><br><span class="line">  * iPad2和iPhone 4的建议值：120。</span><br><span class="line">  * iPhone 3G和iPod 2及早期设备的建议值：30。</span><br><span class="line"> */</span><br><span class="line">static const CGFloat kDestImageSizeMB = 60.0f;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *当设置标志“SDWebImageScaleDownLargeImages”时，定义用于解码图像的图块的最大大小（以MB为单位）</span><br><span class="line"> * iPad1和iPhone 3GS的建议值：20。</span><br><span class="line"> * iPad2和iPhone 4的建议值：40。</span><br><span class="line"> * iPhone 3G和iPod 2及早期设备的建议值：10。</span><br><span class="line">*/</span><br><span class="line">static const CGFloat kSourceImageTileSizeMB = 20.0f;</span><br><span class="line"></span><br><span class="line">//定义 1M = 1024.0f * 1024.0f</span><br><span class="line">static const CGFloat kBytesPerMB = 1024.0f * 1024.0f;</span><br><span class="line"></span><br><span class="line">//定义1MB的像素数是1MB的Bytes数量除以1像素的Bytes数</span><br><span class="line">static const CGFloat kPixelsPerMB = kBytesPerMB / kBytesPerPixel;</span><br><span class="line">//定义解码完的图像的最大像素总数数是解码完的图像最size乘以1MB的像素数</span><br><span class="line">static const CGFloat kDestTotalPixels = kDestImageSizeMB * kPixelsPerMB;</span><br><span class="line"></span><br><span class="line">//定义用于解码的图像的最大像素总数是解码的图像的size乘以1MB的像素数</span><br><span class="line">static const CGFloat kTileTotalPixels = kSourceImageTileSizeMB * kPixelsPerMB;</span><br><span class="line"></span><br><span class="line">//定义重叠像素大小为2像素</span><br><span class="line">static const CGFloat kDestSeemOverlap = 2.0f;</span><br></pre></td></tr></table></figure>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        //定义了两个变量来保存图像的宽和高</span><br><span class="line">        size_t _width, _height;</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">        //定义变量记录图片方向</span><br><span class="line">        UIImageOrientation _orientation;</span><br><span class="line">#endif</span><br><span class="line">        //定义变量记录图片源</span><br><span class="line">        CGImageSourceRef _imageSource;</span><br></pre></td></tr></table></figure>
<h3 id="life-cycle"><a href="#life-cycle" class="headerlink" title="life cycle"></a>life cycle</h3><p>单例方法和dealloc方法</p>
<p>C 语言不能够调用OC中的retain与release，一般的C 语言接口都提供了release函数（比如CGContextRelease(context c)）来管理内存。ARC不会自动调用这些C接口的函数，所以这还是需要我们自己来进行管理的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    //如果CGImageSourceRef类型的_imageSource存在，在dealloc方法中手动释放掉（CGXXX 和CFXXX方法，ARC并不会自动释放，需要手动去释放掉）</span><br><span class="line">    </span><br><span class="line">    if (_imageSource) &#123;</span><br><span class="line">        CFRelease(_imageSource);</span><br><span class="line">        _imageSource = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//单例方法</span><br><span class="line">+ (instancetype)sharedCoder &#123;</span><br><span class="line">    static SDWebImageImageIOCoder *coder;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        coder = [[SDWebImageImageIOCoder alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="SDWebImageCoder协议方法"><a href="#SDWebImageCoder协议方法" class="headerlink" title="SDWebImageCoder协议方法"></a><code>SDWebImageCoder</code>协议方法</h4><p>判断是否支持图片数据的解码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canDecodeFromData:(nullable NSData *)data &#123;</span><br><span class="line">    //通过NSData中的扩展方法：sd_imageFormatForImageData 获取图片的格式</span><br><span class="line">    switch ([NSData sd_imageFormatForImageData:data]) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // 不支持WebP格式图片解码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // 检查是否支持HEIC格式图片解码</span><br><span class="line">            return [[self class] canDecodeFromHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过图片数据（ImageData）解码获取图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    //如果data为空，返回nil</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将imagedata转为图片</span><br><span class="line">    UIImage *image = [[UIImage alloc] initWithData:data];</span><br><span class="line">    //设置图片的格式</span><br><span class="line">    image.sd_imageFormat = [NSData sd_imageFormatForImageData:data];</span><br><span class="line">    </span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用原始图片和图片数据解压缩图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">使用原始图片和图片数据解压缩图片。</span><br><span class="line"></span><br><span class="line"> @param image 需要压缩的原图片</span><br><span class="line"> @param data 指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span><br><span class="line"> @param optionsDict 一个包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span><br><span class="line"> @return 解压缩后的图片</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">                                </span><br><span class="line">//如果是mac，直接返回图片</span><br><span class="line">#if SD_MAC</span><br><span class="line">    return image;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//如果是iOS 、osTV、osWatch</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">    // 创建变量保存，默认是不缩小</span><br><span class="line">    BOOL shouldScaleDown = NO;</span><br><span class="line">    </span><br><span class="line">    // 如果传入选项字典参数</span><br><span class="line">    if (optionsDict != nil) &#123;</span><br><span class="line">        //创建临时变量保存选项值</span><br><span class="line">        NSNumber *scaleDownLargeImagesOption = nil;</span><br><span class="line">        //SDWebImageCoderScaleDownLargeImagesKey对应的value类型为NSNumber，则保存value</span><br><span class="line">        if ([optionsDict[SDWebImageCoderScaleDownLargeImagesKey] isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">            scaleDownLargeImagesOption = (NSNumber *)optionsDict[SDWebImageCoderScaleDownLargeImagesKey];</span><br><span class="line">        &#125;</span><br><span class="line">        //如果选项值不为nil，转换成BOOL类型，并保存</span><br><span class="line">        if (scaleDownLargeImagesOption != nil) &#123;</span><br><span class="line">            shouldScaleDown = [scaleDownLargeImagesOption boolValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果不需要缩小图片，直接执行解压图片操作</span><br><span class="line">    if (!shouldScaleDown) &#123;</span><br><span class="line">        return [self sd_decompressedImageWithImage:image];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        如果需要缩小图片，则执行图片的解压和缩小操作</span><br><span class="line">        UIImage *scaledDownImage = [self sd_decompressedAndScaledDownImageWithImage:image];</span><br><span class="line">        </span><br><span class="line">         // 如果解压和缩小成功，仍处理数据指针，调用压缩方法</span><br><span class="line">        if (scaledDownImage &amp;&amp; !CGSizeEqualToSize(scaledDownImage.size, image.size)) &#123;</span><br><span class="line">            //根据图片数据指针得到图片的格式</span><br><span class="line">            SDImageFormat format = [NSData sd_imageFormatForImageData:*data];</span><br><span class="line">            //通过缩小的图片和图片格式编码获取imagedata</span><br><span class="line">            NSData *imageData = [self encodedDataWithImage:scaledDownImage format:format];</span><br><span class="line">            if (imageData) &#123;</span><br><span class="line">                // 通过参数回传处理后的图像数据</span><br><span class="line">                *data = imageData;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回处理后的图片</span><br><span class="line">        return scaledDownImage;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SDWebImageProgressiveCoder-协议方法"><a href="#SDWebImageProgressiveCoder-协议方法" class="headerlink" title="SDWebImageProgressiveCoder 协议方法"></a><code>SDWebImageProgressiveCoder</code> 协议方法</h4><p>判断是否支持增量解码某个data数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canIncrementallyDecodeFromData:(NSData *)data &#123;</span><br><span class="line">    //获取图片的格式</span><br><span class="line">    switch ([NSData sd_imageFormatForImageData:data]) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // 不支持WebP逐行解码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // 检查HEIC解码兼容性</span><br><span class="line">            return [[self class] canDecodeFromHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            // 其他类型就返回YES</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将图片数据增量解码为图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)incrementallyDecodedImageWithData:(NSData *)data finished:(BOOL)finished &#123;</span><br><span class="line">    判断增量图片源是否存在，如果不存在，创建一个新的</span><br><span class="line">    if (!_imageSource) &#123;</span><br><span class="line">        _imageSource = CGImageSourceCreateIncremental(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    UIImage *image;</span><br><span class="line">    </span><br><span class="line">    //更新数据源，这里必须传递所有数据，而不仅仅是新字节</span><br><span class="line">    CGImageSourceUpdateData(_imageSource, (__bridge CFDataRef)data, finished);</span><br><span class="line">    </span><br><span class="line">    // 获取到图像的宽、高和方向</span><br><span class="line">    if (_width + _height == 0) &#123;</span><br><span class="line">        CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(_imageSource, 0, NULL);</span><br><span class="line">        if (properties) &#123;</span><br><span class="line">            NSInteger orientationValue = 1;</span><br><span class="line">            CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_height);</span><br><span class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_width);</span><br><span class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</span><br><span class="line">            if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</span><br><span class="line">            CFRelease(properties);</span><br><span class="line">            </span><br><span class="line">            //当我们绘制到Core Graphics时，我们会丢失方向信息，这意味着initWithCGIImage生成的图像有时会导致错误定向。 （与didCompleteWithError中的initWithData生成的图像不同。）因此将其保存在此处并稍后传递。</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">            _orientation = [SDWebImageCoderHelper imageOrientationFromEXIFOrientation:orientationValue];</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_width + _height &gt; 0) &#123;</span><br><span class="line">        // 创建位图对象</span><br><span class="line">        CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(_imageSource, 0, NULL);</span><br><span class="line">        </span><br><span class="line">        //如果存在，则根据该位图生成图片</span><br><span class="line">        if (partialImageRef) &#123;</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef scale:1 orientation:_orientation];</span><br><span class="line">#elif SD_MAC</span><br><span class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef size:NSZeroSize];</span><br><span class="line">#endif</span><br><span class="line">            // 位图对象的引用计数-1</span><br><span class="line">            CGImageRelease(partialImageRef);</span><br><span class="line">            image.sd_imageFormat = [NSData sd_imageFormatForImageData:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     // 如果加载完成就释放掉位图对象，并置空</span><br><span class="line">    if (finished) &#123;</span><br><span class="line">        if (_imageSource) &#123;</span><br><span class="line">            CFRelease(_imageSource);</span><br><span class="line">            _imageSource = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回该图片</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="私有方法中的：解压图片-和-解压并按比例缩小图片"><a href="#私有方法中的：解压图片-和-解压并按比例缩小图片" class="headerlink" title="私有方法中的：解压图片 和 解压并按比例缩小图片"></a>私有方法中的：解压图片 和 解压并按比例缩小图片</h4><p>解压图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">- (nullable UIImage *)sd_decompressedImageWithImage:(nullable UIImage *)image &#123;</span><br><span class="line"></span><br><span class="line">    //如果图片不需要解码，直接返回image</span><br><span class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //自动释放位图上下文和所有变量以帮助系统在存在内存警告时释放内存。</span><br><span class="line">    //在iOS7上，别忘了调用[[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    </span><br><span class="line">    // 建立自动释放池，以帮助系统在收到内存警告时释放内存。</span><br><span class="line">    @autoreleasepool&#123;</span><br><span class="line">        </span><br><span class="line">        //获取图片对象的位图图片</span><br><span class="line">        CGImageRef imageRef = image.CGImage;</span><br><span class="line">        // 获取图片对象的色彩空间</span><br><span class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</span><br><span class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(imageRef);</span><br><span class="line">        //  iOS 显示 Alpha（透明）信息  (BRGA8888/BGRX8888)</span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        </span><br><span class="line">        size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">        size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // CGBitmapContextCreate不支持kCGImageAlphaNone。由于此处的原始图像没有alpha信息，因此使用kCGImageAlphaNoneSkipLast创建没有alpha信息的位图图形上下文。</span><br><span class="line">        //创建位图图形上下文</span><br><span class="line">        CGContextRef context = CGBitmapContextCreate(NULL,</span><br><span class="line">                                                     width,</span><br><span class="line">                                                     height,</span><br><span class="line">                                                     kBitsPerComponent,</span><br><span class="line">                                                     0,</span><br><span class="line">                                                     colorspaceRef,</span><br><span class="line">                                                     bitmapInfo);</span><br><span class="line">        //如果创建失败，直接返回image</span><br><span class="line">        if (context == NULL) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将图像绘制到上下文中并检索没有alpha的新位图图像</span><br><span class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">        // 生成位图图像</span><br><span class="line">        CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context);</span><br><span class="line">        // 根据位图图像生成图片对象</span><br><span class="line">        UIImage *imageWithoutAlpha = [[UIImage alloc] initWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">        //释放掉上下文</span><br><span class="line">        CGContextRelease(context);</span><br><span class="line">        //释放掉位图图片</span><br><span class="line">        CGImageRelease(imageRefWithoutAlpha);</span><br><span class="line">        </span><br><span class="line">        //返回位图图片</span><br><span class="line">        return imageWithoutAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//解压并按比例缩小图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)sd_decompressedAndScaledDownImageWithImage:(nullable UIImage *)image &#123;</span><br><span class="line">    //如果图片不需要解码，直接返回image</span><br><span class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果图片不需要缩小，直接执行解压图片操作</span><br><span class="line">    if (![[self class] shouldScaleDownImage:image]) &#123;</span><br><span class="line">        return [self sd_decompressedImageWithImage:image];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建图像上下文</span><br><span class="line">    CGContextRef destContext;</span><br><span class="line">    </span><br><span class="line">    //自动释放位图上下文和所有变量以帮助系统在存在内存警告时释放内存。</span><br><span class="line">    //在iOS7上，别忘了调用[[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    </span><br><span class="line">    // 建立自动释放池，以帮助系统在收到内存警告时释放内存</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //获取图片对象的位图图片</span><br><span class="line">        CGImageRef sourceImageRef = image.CGImage;</span><br><span class="line">        </span><br><span class="line">        // 获取图像的总像素数</span><br><span class="line">        CGSize sourceResolution = CGSizeZero;</span><br><span class="line">        sourceResolution.width = CGImageGetWidth(sourceImageRef);</span><br><span class="line">        sourceResolution.height = CGImageGetHeight(sourceImageRef);</span><br><span class="line">        float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</span><br><span class="line">        </span><br><span class="line">        // 计算缩小比例</span><br><span class="line">        float imageScale = kDestTotalPixels / sourceTotalPixels;</span><br><span class="line">        // 计算缩小后的尺寸</span><br><span class="line">        CGSize destResolution = CGSizeZero;</span><br><span class="line">        destResolution.width = (int)(sourceResolution.width*imageScale);</span><br><span class="line">        destResolution.height = (int)(sourceResolution.height*imageScale);</span><br><span class="line">        </span><br><span class="line">        // 获取色彩空间</span><br><span class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</span><br><span class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(sourceImageRef);</span><br><span class="line">        // iOS 显示 Alpha（透明）信息 (BGRA8888/BGRX8888)</span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        </span><br><span class="line">        // CGBitmapContextCreate不支持kCGImageAlphaNone。由于此处的原始图像没有alpha信息，因此使用kCGImageAlphaNoneSkipLast创建没有alpha信息的位图图形上下文。</span><br><span class="line">        //创建位图图形上下文</span><br><span class="line">        destContext = CGBitmapContextCreate(NULL,</span><br><span class="line">                                            destResolution.width,</span><br><span class="line">                                            destResolution.height,</span><br><span class="line">                                            kBitsPerComponent,</span><br><span class="line">                                            0,</span><br><span class="line">                                            colorspaceRef,</span><br><span class="line">                                            bitmapInfo);</span><br><span class="line">        </span><br><span class="line">        //如果创建失败，直接返回image</span><br><span class="line">        if (destContext == NULL) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置图像上下文的绘图质量</span><br><span class="line">        CGContextSetInterpolationQuality(destContext, kCGInterpolationHigh);</span><br><span class="line">        </span><br><span class="line">        //现在定义用于从输入图像到输出图像的增量blit的矩形的大小。由于iOS从磁盘检索图像数据的方式，我们使用的源块宽度等于源图像的宽度。 iOS必须以全宽“波段”从磁盘解码图像，即使当前图形上下文被剪切为该波段内的子图形也是如此。 因此，我们通过将我们的图块大小设置为输入图像的整个宽度来充分利用由解码操作产生的所有像素数据。</span><br><span class="line">        </span><br><span class="line">        // 创建临时变量保存来源块大小</span><br><span class="line">        CGRect sourceTile = CGRectZero;</span><br><span class="line">        // 来源块的宽度就是原图的宽度</span><br><span class="line">        sourceTile.size.width = sourceResolution.width;</span><br><span class="line">        </span><br><span class="line">        // 源图块高度是动态的。 由于我们以MB为单位指定了源块的大小，因此请查看输入图像宽度可以为多少像素行。</span><br><span class="line">        // 计算来源块的高度</span><br><span class="line">        sourceTile.size.height = (int)(kTileTotalPixels / sourceTile.size.width );</span><br><span class="line">        // 设置来源块的X坐标</span><br><span class="line">        sourceTile.origin.x = 0.0f;</span><br><span class="line">        </span><br><span class="line">        //输出图块与输入图块的比例相同，但缩放为图像比例。</span><br><span class="line">        // 创建历史变量保存目标块大小</span><br><span class="line">        CGRect destTile;</span><br><span class="line">        </span><br><span class="line">        // 目标块的宽是缩放后的宽</span><br><span class="line">        destTile.size.width = destResolution.width;</span><br><span class="line">        </span><br><span class="line">        // 目标块的宽是来源块的高乘以缩放比</span><br><span class="line">        destTile.size.height = sourceTile.size.height * imageScale;</span><br><span class="line">        </span><br><span class="line">        // 设置目标块的X坐标</span><br><span class="line">        destTile.origin.x = 0.0f;</span><br><span class="line">        </span><br><span class="line">        //来源块与目标似乎重叠成比例。 这是我们组装输出图像时每个图块重叠的像素数量。</span><br><span class="line">        // 计算来源块与目标块的重复区域</span><br><span class="line">        float sourceSeemOverlap = (int)((kDestSeemOverlap/destResolution.height)*sourceResolution.height);</span><br><span class="line">        </span><br><span class="line">        // 生成变量保存来源块图像位图</span><br><span class="line">        CGImageRef sourceTileImageRef;</span><br><span class="line">        </span><br><span class="line">        // 计算组装输出图像所需的读/写操作次数。</span><br><span class="line">        // 计算需要绘制的次数</span><br><span class="line">        int iterations = (int)( sourceResolution.height / sourceTile.size.height );</span><br><span class="line">        </span><br><span class="line">        // 如果图块高度未均匀划分图像高度，请添加另一个迭代以考虑剩余像素。</span><br><span class="line">        // 计算剩余像素的高度</span><br><span class="line">        int remainder = (int)sourceResolution.height % (int)sourceTile.size.height;</span><br><span class="line">        </span><br><span class="line">        // 如果有剩余像素就将绘制次数加1</span><br><span class="line">        if(remainder) &#123;</span><br><span class="line">            iterations++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加似乎与切片重叠，但保存原始切片高度以进行y坐标计算。</span><br><span class="line">         // 创建变量保存来源块的高度，用来计算纵坐标的移动</span><br><span class="line">        float sourceTileHeightMinusOverlap = sourceTile.size.height;</span><br><span class="line">        </span><br><span class="line">        // 来源块高度加上要重复覆盖的高度</span><br><span class="line">        sourceTile.size.height += sourceSeemOverlap;</span><br><span class="line">        </span><br><span class="line">        // 目标块高度加上重叠的像素数</span><br><span class="line">        destTile.size.height += kDestSeemOverlap;</span><br><span class="line">        </span><br><span class="line">        // 开启循环绘制图像</span><br><span class="line">        for( int y = 0; y &lt; iterations; ++y ) &#123;</span><br><span class="line">            // 建立自动释放池，以帮助系统在收到内存警告时释放内存。</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                // 计算来源块的纵坐标：来源块的高度乘以当前循环次数，然后加上重复覆盖的高度</span><br><span class="line">                sourceTile.origin.y = y * sourceTileHeightMinusOverlap + sourceSeemOverlap;</span><br><span class="line">                </span><br><span class="line">                 // 计算目标块的纵坐标：目标图像的高度减去要绘制的来源块的高度乘以压缩比，再减去重叠高度</span><br><span class="line">                // 这个地方，来源块的纵坐标是递增的，目标块的纵坐标是递减的，这是因为为UIKit的坐标系和CGContext是镜像关系</span><br><span class="line">                destTile.origin.y = destResolution.height - (( y + 1 ) * sourceTileHeightMinusOverlap * imageScale + kDestSeemOverlap);</span><br><span class="line">                </span><br><span class="line">                // 按照计算好的尺寸绘制来源块的位图</span><br><span class="line">                sourceTileImageRef = CGImageCreateWithImageInRect( sourceImageRef, sourceTile );</span><br><span class="line">                </span><br><span class="line">                 // 如果是最后一块要绘制，并且这一块是剩余的像素</span><br><span class="line">                if( y == iterations - 1 &amp;&amp; remainder ) &#123;</span><br><span class="line">                </span><br><span class="line">                    // 因为剩余像素的高度是不固定的，所以重新计算目标块的纵坐标</span><br><span class="line">                    float dify = destTile.size.height;</span><br><span class="line">                    destTile.size.height = CGImageGetHeight( sourceTileImageRef ) * imageScale;</span><br><span class="line">                    dify -= destTile.size.height;</span><br><span class="line">                    destTile.origin.y += dify;</span><br><span class="line">                &#125;</span><br><span class="line">                // 将来源块位图按照计算好的尺寸绘制到目标图像上下文中</span><br><span class="line">                CGContextDrawImage( destContext, destTile, sourceTileImageRef );</span><br><span class="line">                </span><br><span class="line">                 // 释放来源块位图</span><br><span class="line">                CGImageRelease( sourceTileImageRef );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 根据目标图像上下文生成目标图像位图</span><br><span class="line">        CGImageRef destImageRef = CGBitmapContextCreateImage(destContext);</span><br><span class="line">        </span><br><span class="line">        // 释放目标图像上下文</span><br><span class="line">        CGContextRelease(destContext);</span><br><span class="line">        </span><br><span class="line">        // 如果生成位图失败就直接返回图片对象</span><br><span class="line">        if (destImageRef == NULL) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         // 生成目标图片对象</span><br><span class="line">        UIImage *destImage = [[UIImage alloc] initWithCGImage:destImageRef scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">        </span><br><span class="line">         // 释放目标图像位图</span><br><span class="line">        CGImageRelease(destImageRef);</span><br><span class="line">        </span><br><span class="line">        // 如果生成图片对象失败就直接返回图片对象</span><br><span class="line">        if (destImage == nil) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 返回目标图片对象</span><br><span class="line">        return destImage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>判断某个图片格式是否支持编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//如果是WebP格式，则不支持编码；HEIC格式：根据canEncodeToHEICFormat方法判断是否支持编码；其他格式都支持编码</span><br><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    switch (format) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // 不支持WebP格式编码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // 检查HEIC编码兼容性</span><br><span class="line">            return [[self class] canEncodeToHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将图片根据给定的格式解码成图片数据（imageData）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    //如果图片不存在，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果格式类型未识别，判断图片是否含有Alpha通道，如果有则定义为PNG格式，否则定义为JPEG格式</span><br><span class="line">    if (format == SDImageFormatUndefined) &#123;</span><br><span class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(image.CGImage);</span><br><span class="line">        if (hasAlpha) &#123;</span><br><span class="line">            format = SDImageFormatPNG;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            format = SDImageFormatJPEG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableData *imageData = [NSMutableData data];</span><br><span class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:format];</span><br><span class="line">    </span><br><span class="line">    // 根据imageData 和 CFStringRef 创建 CGImageDestinationRef对象，如果创建失败，返回nil</span><br><span class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL);</span><br><span class="line">    if (!imageDestination) &#123;</span><br><span class="line">        // Handle failure.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //创建字典对象保存编码参数</span><br><span class="line">    NSMutableDictionary *properties = [NSMutableDictionary dictionary];</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">    //// 获取图片的方向</span><br><span class="line">    NSInteger exifOrientation = [SDWebImageCoderHelper exifOrientationFromImageOrientation:image.imageOrientation];</span><br><span class="line">    //设置方向参数</span><br><span class="line">    [properties setValue:@(exifOrientation) forKey:(__bridge NSString *)kCGImagePropertyOrientation];</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    // 添加图片位图对象到创建的CGImageDestinationRef对象中</span><br><span class="line">    CGImageDestinationAddImage(imageDestination, image.CGImage, (__bridge CFDictionaryRef)properties);</span><br><span class="line">    </span><br><span class="line">    // 如果编码失败就返回空</span><br><span class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</span><br><span class="line">        // Handle failure.</span><br><span class="line">        imageData = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //释放掉imageDestination对象</span><br><span class="line">    CFRelease(imageDestination);</span><br><span class="line">    </span><br><span class="line">    //返回</span><br><span class="line">    return [imageData copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="私有方法（辅助方法）"><a href="#私有方法（辅助方法）" class="headerlink" title="私有方法（辅助方法）"></a>私有方法（辅助方法）</h3><ol>
<li>是否需要解压图片<br>（如果图片为动图或不存在，不解压图片，否则解压图片）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)shouldDecodeImage:(nullable UIImage *)image &#123;</span><br><span class="line">    //如果图片为空，返回NO</span><br><span class="line">    if (image == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果图片为动图，返回NO</span><br><span class="line">    if (image.images != nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    否则返回YES</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>是否支持<code>HEIC</code>格式类型的图片解码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)canDecodeFromHEICFormat &#123;</span><br><span class="line">    //临时静态变量 canDecode 为 NO</span><br><span class="line">    static BOOL canDecode = NO;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    </span><br><span class="line">//忽略-Wunguarded-availability警告   </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wunguarded-availability&quot;</span><br><span class="line"></span><br><span class="line">//如果是iWatch 或者 SIMULATOR ，则不支持</span><br><span class="line">#if TARGET_OS_SIMULATOR || SD_WATCH  //iWatch</span><br><span class="line">        canDecode = NO;</span><br><span class="line">        </span><br><span class="line">#elif SD_MAC  //mac</span><br><span class="line">        </span><br><span class="line">        //获取进程信息对象</span><br><span class="line">        NSProcessInfo *processInfo = [NSProcessInfo processInfo];</span><br><span class="line">        if ([processInfo respondsToSelector:@selector(operatingSystemVersion)]) &#123;</span><br><span class="line">            //通过进程信息对象获取操作系统版本。判断macOS系统版本10.13+，则支持HEIC类型图像的解码</span><br><span class="line">            canDecode = processInfo.operatingSystemVersion.minorVersion &gt;= 13;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            canDecode = NO;</span><br><span class="line">        &#125;</span><br><span class="line">#elif SD_UIKIT //iOS 和 tvOS</span><br><span class="line">        //获取进程信息对象</span><br><span class="line">        NSProcessInfo *processInfo = [NSProcessInfo processInfo];</span><br><span class="line">        if ([processInfo respondsToSelector:@selector(operatingSystemVersion)]) &#123;</span><br><span class="line">            //通过进程信息对象获取操作系统版本。判断操作系统版本是iOS 11+就支持HEIC类型图像的解码</span><br><span class="line">            canDecode = processInfo.operatingSystemVersion.majorVersion &gt;= 11;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            canDecode = NO;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125;);</span><br><span class="line">    return canDecode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>是否支持<code>HEIC</code>格式类型的图片编码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)canEncodeToHEICFormat &#123;</span><br><span class="line">    //临时静态变量 canDecode 为 NO</span><br><span class="line">    static BOOL canEncode = NO;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        NSMutableData *imageData = [NSMutableData data];</span><br><span class="line">        CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatHEIC];</span><br><span class="line">        </span><br><span class="line">        // 创建一个CGImageDestinationRef对象，如果该对象可以创建成功，则需要编码，否则不需要</span><br><span class="line">        CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL);</span><br><span class="line">        if (!imageDestination) &#123;</span><br><span class="line">            // Can&apos;t encode to HEIC</span><br><span class="line">            canEncode = NO;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Can encode to HEIC</span><br><span class="line">            CFRelease(imageDestination);</span><br><span class="line">            canEncode = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return canEncode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>是否应该缩小图片</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">+ (BOOL)shouldScaleDownImage:(nonnull UIImage *)image &#123;</span><br><span class="line">    BOOL shouldScaleDown = YES;</span><br><span class="line">    </span><br><span class="line">    //获取图片的位图图像</span><br><span class="line">    CGImageRef sourceImageRef = image.CGImage;</span><br><span class="line">    </span><br><span class="line">    //获取到位图图像的宽和高</span><br><span class="line">    CGSize sourceResolution = CGSizeZero;</span><br><span class="line">    sourceResolution.width = CGImageGetWidth(sourceImageRef);</span><br><span class="line">    sourceResolution.height = CGImageGetHeight(sourceImageRef);</span><br><span class="line">    </span><br><span class="line">    //计算图片的总像素数</span><br><span class="line">    float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</span><br><span class="line">    </span><br><span class="line">    //图片的压缩比： 最大像素数 / 图片的总像素数</span><br><span class="line">    float imageScale = kDestTotalPixels / sourceTotalPixels;</span><br><span class="line">    </span><br><span class="line">    //如果压缩比小于1，返回YES，否则返回NO</span><br><span class="line">    if (imageScale &lt; 1) &#123;</span><br><span class="line">        shouldScaleDown = YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        shouldScaleDown = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return shouldScaleDown;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

  </section>

</article>
<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/10/24/2018-10-24-Read-SDWebImage-SDWebImageGIFCoder/" title="读 SDWebImage 六（编码器五：SDWebImageGIFCoder）">读 SDWebImage 六（编码器五：SDWebImageGIFCoder）</a></h2>
                <p class="excerpt">
                
                SDWebImage 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（SDWebImageCodersManager）、编解码协议（SDWebImageCoder 和 SDWebImageProgressiveCoder ）、PNG/JPEG/TIFF编解码，解压缩，显示大图（SDWebImageImageIOCoder）、GIF编解码（SDWebImageGIFCoder）、WebP编解码（SDWebImageWebPCoder）以及辅助类（SDWebImageCoderHelper）。
SDWebImageImageIOCoder ：内置编码器,该类遵守了 SDWebImageCoder协议，但并没有遵守 SDWebImageProgressiveCoder协议，说明该类仅针对git图片的编解码，并不支持git图片的逐行解码功能。
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-10-24T14:31:13.000Z" class="post-list__meta--date date">2018-10-24</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/SDWebImage/">SDWebImage</a>
</span><a class="btn-border-small" href="/2018/10/24/2018-10-24-Read-SDWebImage-SDWebImageGIFCoder/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/10/18/2018-10-18-Read-SDWebImage-SDWebImageCodersManager/" title="读 SDWebImage 六 （编码器三：SDWebImageCodersManager）">读 SDWebImage 六 （编码器三：SDWebImageCodersManager）</a></h2>
                <p class="excerpt">
                
                SDWebImage 内部实现了一个图片解码/编码的图片编解码器，用于图片的编解码、压缩。其中涉及到编解码管理（SDWebImageCodersManager）、编解码协议（SDWebImageCoder）、PNG/JPEG/TIFF编解码，解压缩，显示大图（SDWebImageImageIOCoder）、GIF编解码（SDWebImageGIFCoder）、WebP编解码（SDWebImageWebPCoder）以及辅助类（SDWebImageCoderHelper）
编解码管理（ SDWebImageCodersManager ）编解码管理器，整体编解码器的入口，该类遵守了 SDWebImageCoder 协议，说明这个类可以提供基本的编解码功能 。编解码器数组是一个优先级队列，也意味着处理多个图片编解码任务时新添加的编解码器将具有最高优先级（即被先调用）
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-10-18T12:48:55.000Z" class="post-list__meta--date date">2018-10-18</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/SDWebImage/">SDWebImage</a>
</span><a class="btn-border-small" href="/2018/10/18/2018-10-18-Read-SDWebImage-SDWebImageCodersManager/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

            
            <br><footer class="footer">
    <span class="footer__copyright">听过无数道理，还是过不好这一生。那就随着心意任性地走吧，走累的时候再安营扎寨，或者永远也不。本人邮箱：wheatden@guohuaden.com
    </span>
   
</footer>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
        </div>
    </div>

    

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'GTM-NHB73SK', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?ae05530a6a007cdb8063cf611691cc3e";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
    
    </script>
    
</body>
</html>
