<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="undefined" />
  <meta name="author" content="GUOHUA" />
  <meta name="description" content="简单的一个技术博客，用来作为学习笔记和日常记录使用。" />
  
  
  <title>
    
      读SDWebImage 二 (SDWebImageManager) 
      
      
      |
    
     所念皆星辰
  </title>

  
    <link rel="apple-touch-icon" href="/images/avatar.png">
    <link rel="icon" href="/images/avatar.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  <script src="/js/fancybox.js"></script>

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>

</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">所念皆星辰</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>

<script src="/js/activeNav.js"></script>


      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>



  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">读SDWebImage 二 (SDWebImageManager)</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2018-10-01 09:38:06
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/SDWebImage/" title="SDWebImage">
                    <b>#</b> SDWebImage
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="1、整体框架"><a href="#1、整体框架" class="headerlink" title="1、整体框架"></a>1、整体框架</h2><p>看下整体的框架图：<br><img src="http://blog.guohuaden.com/SDWebImageClassDiagram.png" alt="SDWebImage框架"><br>从图中可以更清晰的看出，<code>SDWebImage</code>库是围绕<code>SDWebImageManager</code>、<code>SDWebImageCache</code>、<code>SDWebImageDownloader</code>三个类展开的，而这三个类又是以<code>SDWebImageManager</code>作为核心类。</p>
<p>下面就重点分析<code>SDWebImageManager</code>：<br><code>SDWebImageManager</code>是 <code>SDWebImage</code> 的管理以及操作类。也是<code>SDWebImage</code>的核心类，拥有一个<code>SDWebImageCache</code> 和 <code>SDWebImageDownloader</code> 属性，分别用于图片缓存和下载处理。</p>
<h2 id="2、SDWebImageManager类分析"><a href="#2、SDWebImageManager类分析" class="headerlink" title="2、SDWebImageManager类分析"></a>2、<code>SDWebImageManager</code>类分析</h2><h3 id="先看下-h文件"><a href="#先看下-h文件" class="headerlink" title="先看下.h文件"></a>先看下.h文件</h3><h3 id="2-1、公共枚举"><a href="#2-1、公共枚举" class="headerlink" title="2.1、公共枚举"></a>2.1、公共枚举</h3><p>该枚举定义了图像加载的可选项:<br><strong>options 选项（枚举类型）</strong></p>
<blockquote>
<p><code>SDWebImageRetryFailed = 1 &lt;&lt; 0,</code><br>默认情况下当通过URL下载图片失败后，该URL就被加入黑名单，之后SDWebImage不会再去尝试下载。此标志作用就是禁用该黑名单，也就是说使用SDWebImageRetryFailed后，图片下载失败仍会尝试下载</p>
<p><code>SDWebImageLowPriority = 1 &lt;&lt; 1,</code><br>默认情况下图片在UI交互期间下载，此标志的作用就是禁用该功能。例如：在UIScrollView减速时导致延迟下载。</p>
<p><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</code><br>此标志作用是：图片下载完成后仅缓存到内存，不缓存在磁盘上</p>
<p><code>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</code><br>此标志作用是：图片下载完成后仅缓存到内存，不缓存在磁盘上</p>
<p><code>SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</code><br>此标志启用渐进式下载，图像在下载过程中逐步显示，就像浏览器一样。<br>默认情况下，图像仅在完全下载后显示。</p>
<p><code>SDWebImageRefreshCached = 1 &lt;&lt; 4,</code><br>即使缓存中存在该图片，也尊重HTTP响应缓存控制，在需要时从远程刷新图片。<br>磁盘缓存将由 <code>NSURLCache</code> 替代 <code>SDWebImage</code> 去处理，这样也将导致性能略有下降。<br>该选项有助于处理同一个URL请求但更换图片的情况，例如Facebook图形api配置文件的图片。<br>如果刷新了缓存图片，则使用缓存图片调用一次完成block代码块，再使用最终的图片调用完成block代码块。<br>仅当你无法使用嵌入式缓存清除参数使URL保持静态时，才使用该标志。</p>
<p><code>SDWebImageContinueInBackground = 1 &lt;&lt; 5,</code><br>在<code>iOS 4+</code>中，如果app进入后台也继续下载图片，这是通过询问系统实现的。<br>在后台有额外的时间让请求完成，如果后台任务到期，则操作被取消。</p>
<p><code>SDWebImageHandleCookies = 1 &lt;&lt; 6,</code><br>通过<code>NSMutableURLRequest.HTTPShouldHandleCookies = YES</code>设置处理在 <code>NSHTTPCookieStore</code>中的cookies。</p>
<p><code>SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</code><br>启用允许不受信任的SSL证书（用于测试目的，在生产中谨慎使用）</p>
<p><code>SDWebImageHighPriority = 1 &lt;&lt; 8,</code><br>默认情况下，图像按其排队顺序加载，此标志将它们移动到队列的前面</p>
<p><code>SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</code><br>默认情况下，加载图像时会加载占位符。 此标志将延迟加载占位符图像，直到图像加载完毕。</p>
<p><code>SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</code><br>我们通常不会在动画图像上调用transformDownloadedImage委托方法，因为大多数转换代码会破坏它。如果使用必须使用此标志来转换它们。</p>
<p><code>SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</code><br>默认情况下，下载后会将图像添加到imageView。 但在某些情况下，我们想要<br>在设置图像之前手动处理一些东西（例如应用滤镜或添加交叉渐变动画）请使用此标志</p>
<p><code>SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</code><br>默认情况下，图像会根据其原始大小进行解码。 在iOS上，此标志将缩小图像尺寸与设备的受限内存兼容。（如果设置了“SDWebImageProgressiveDownload”标志，则停用缩小比例。）</p>
<p><code>SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</code><br>默认情况下，当图像缓存在内存中时，我们不查询磁盘数据。 此掩码可以强制同时查询磁盘数据。<br>建议将此标志与<code>SDWebImageQueryDiskSync</code>一起使用，以确保图像在同一个runloop中加载。</p>
<p><code>SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</code><br>默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。 此掩码可以强制同步查询磁盘缓存，以确保在同一个runloop中加载映像。<br>如果禁用内存缓存或在某些其他情况下，此标志可以避免在单元重用期间闪烁。</p>
<p><code>SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</code><br>默认情况下，当缓存丢失时，将从网络下载映像。此标志可以阻止网络仅从缓存加载。</p>
<p><code>SDWebImageForceTransition = 1 &lt;&lt; 16</code><br>默认情况下，当您使用 <code>SDWebImageTransition</code> 在图像加载完成后进行某些视图转换时，此转换仅适用于从网络下载图像。 此掩码也可以强制为内存和磁盘缓存应用视图转换。</p>
</blockquote>
<h3 id="2-2、公共类型定义"><a href="#2-2、公共类型定义" class="headerlink" title="2.2、公共类型定义"></a>2.2、公共类型定义</h3><p>四个回调代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//用于外部分类中完成回调的block</span><br><span class="line">typedef void(^SDExternalCompletionBlock)(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//用于该类内部完成回调的block</span><br><span class="line">typedef void(^SDInternalCompletionBlock)(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//将url处理成缓存图像用的key的方法，返回字符串作为存储时的key，可以删除url中的产讯字段</span><br><span class="line">//用于在使用某url生成key之前，先把url的某些动态信息除掉，以便可以用简洁一点的url来生成key。因此这个block的内容就是对url的操作，返回值是一个简洁版的url。</span><br><span class="line">typedef NSString * _Nullable(^SDWebImageCacheKeyFilterBlock)(NSURL * _Nullable url);</span><br><span class="line"></span><br><span class="line">//将图像缓存到磁盘的解码算法，返回的是data。</span><br><span class="line">typedef NSData * _Nullable(^SDWebImageCacheSerializerBlock)(UIImage * _Nonnull image, NSData * _Nullable data, NSURL * _Nullable imageURL);</span><br></pre></td></tr></table></figure>
<h3 id="2-3、协议：SDWebImageManagerDelegate"><a href="#2-3、协议：SDWebImageManagerDelegate" class="headerlink" title="2.3、协议：SDWebImageManagerDelegate"></a>2.3、协议：<code>SDWebImageManagerDelegate</code></h3><p>使用协议的优点在于：</p>
<ol>
<li>不需要担心循环引用问题</li>
<li>有利于程序的结构化与层次化</li>
<li>有利于代码的封装</li>
</ol>
<p><code>SDWebImageManager</code>提供的三个都是可选协议，这也是我们平时常用的方式，遵守协议的类根据需要实现协议方法，不需要编译器警告提示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当缓存没有发现当前图片，会查看调用者是否实现该方法，如果返回NO，则不会继续下载该图片</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager 当前的 `SDWebImageManager`</span><br><span class="line"> * @param imageURL    应该下载的图像的URL</span><br><span class="line"> *</span><br><span class="line"> * @return  返回结果，返回NO时阻止去下载，如果不执行，默认的是YES</span><br><span class="line"> Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span><br><span class="line"> */</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 当图片下载失败时，会查看调用者是否将该图片URL标记为失败，如果返回YES，则将此URL标记为失败。</span><br><span class="line"> 注意：如果委托实现此方法，将不会使用内置方式根据错误代码将URL标记为失败;</span><br><span class="line"> @param imageManager 当前的`SDWebImageManager`</span><br><span class="line"> @param imageURL 图像的网址</span><br><span class="line"> @param error URL下载的错误</span><br><span class="line"> @return 是否阻止失败的URL再去下载，返回YES，将URL标记为失败，不再下载</span><br><span class="line"> */</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldBlockFailedURL:(nonnull NSURL *)imageURL withError:(nonnull NSError *)error;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 允许在下载后立即转换图像，然后将图像缓存到磁盘和内存中。</span><br><span class="line"> * 注意：从全局队列调用此方法，以便不阻止主线程。</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager  当前的`SDWebImageManager`</span><br><span class="line"> * @param image        要转换的图像</span><br><span class="line"> * @param imageURL     要转换的图像的网址</span><br><span class="line"> *</span><br><span class="line"> * @return 转换后的图像对象。</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;</span><br></pre></td></tr></table></figure>
<h3 id="2-4、协议：属性和方法"><a href="#2-4、协议：属性和方法" class="headerlink" title="2.4、协议：属性和方法"></a>2.4、协议：属性和方法</h3><p>声明属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//代理</span><br><span class="line">@property (weak, nonatomic, nullable) id &lt;SDWebImageManagerDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">//图片缓存</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDImageCache *imageCache;</span><br><span class="line">//图片下载</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDWebImageDownloader *imageDownloader;</span><br><span class="line"></span><br><span class="line">//缓存过滤器代码块（每次SDWebImageManager将URL转换为缓存所需要的key时使用的代码块，这个可以用于删除图片URL的动态部分）</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//高速缓存序列化器，用于将解码图像（愿下载数据）转换为用于存储到磁盘高速缓存的世纪数据的代码块，如果返回nil，则表示从图像实例生成数据。</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheSerializerBlock cacheSerializer;</span><br><span class="line"></span><br><span class="line">//全局SDWebImageManager实例。</span><br><span class="line">+ (nonnull instancetype)sharedManager;</span><br><span class="line"></span><br><span class="line">//允许指定与图像管理器一起使用的缓存和图像下载器的实例。</span><br><span class="line">//返回带有指定缓存和下载器的`SDWebImageManager`的新实例。</span><br><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果缓存中不存在，就下载给定URL的图像，存在就返回缓存的版本</span><br><span class="line"> Downloads the image at the given URL if not present in cache or return the cached version otherwise.</span><br><span class="line"> *</span><br><span class="line"> * @param url           图像的URL</span><br><span class="line"> * @param options       用于指定此请求的选项掩码</span><br><span class="line"> * @param progressBlock 下载图像时调用的代码块（在后台队列上执行的进度代码块）</span><br><span class="line"> *                      </span><br><span class="line"> * @param completedBlock  操作完成时调用的代码块</span><br><span class="line">* @return 返回 SDWebImageDownloaderOperation 的一个实例</span><br><span class="line">  </span><br><span class="line">completedBlock 即：typedef void(^SDInternalCompletionBlock)(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL);</span><br><span class="line"> </span><br><span class="line"> 该代码块没有返回值，将请求到的UIImage作为第一个参数；NSData作为第二个参数；如果出错，则image参数为nil，第三个参数可能包含NSError；第四个参数是一个`SDImageCacheType`枚举，指明图像的来源（本地缓存中检索、内存缓存、网络下载。）第五个参数用来判断下载是否完成；最后一个参数为原始图像的URL</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                              options:(SDWebImageOptions)options</span><br><span class="line">                                             progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                            completed:(nullable SDInternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将图像保存到给定的URL的缓存中</span><br><span class="line"> *</span><br><span class="line"> * @param image要缓存的图像</span><br><span class="line"> * @param url   图像的URL</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">//</span><br><span class="line">- (void)saveImageToCache:(nullable UIImage *)image forURL:(nullable NSURL *)url;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> //取消当前所有的操作</span><br><span class="line">- (void)cancelAll;</span><br><span class="line"></span><br><span class="line"> //检查一个或多个正在运行的操作</span><br><span class="line">- (BOOL)isRunning;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  异步检查图像是否已被缓存</span><br><span class="line"> *</span><br><span class="line"> *  @param url              图像 url</span><br><span class="line"> *  @param completionBlock  检查完成时要执行的代码块</span><br><span class="line"> *  </span><br><span class="line"> *  @note 完成代码块总是在主队列上执行</span><br><span class="line"> */</span><br><span class="line">- (void)cachedImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">                     completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  异步检查图像是否已仅缓存在磁盘上</span><br><span class="line"> *</span><br><span class="line"> *  @param url             图像 url</span><br><span class="line"> *  @param completionBlock  检查完成时要执行的代码块</span><br><span class="line"> *</span><br><span class="line"> *  @note 完成代码块总是在主队列上执行</span><br><span class="line"> */</span><br><span class="line">- (void)diskImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">                   completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//返回给定URL的缓存key</span><br><span class="line">- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url;</span><br></pre></td></tr></table></figure>
<h3 id="再看-m文件-的声明"><a href="#再看-m文件-的声明" class="headerlink" title="再看.m文件 的声明"></a>再看.m文件 的声明</h3><h3 id="2-5-SDWebImageCombinedOperation的属性声明和协议方法实现"><a href="#2-5-SDWebImageCombinedOperation的属性声明和协议方法实现" class="headerlink" title="2.5 SDWebImageCombinedOperation的属性声明和协议方法实现"></a>2.5 <code>SDWebImageCombinedOperation</code>的属性声明和协议方法实现</h3><p>定义一个<code>SDWebImageCombinedOperation</code>类，该类遵循 <code>SDWebImageOperation</code>协议 ，该协议仅定义了一个cancel的方法。<br>之所以在这里定义这个类，而不是直接使用<code>SDWebImageDownloaderOperation</code>类来表示下载任务，原因有两方面：</p>
<ol>
<li>为了可以在下面使用中修改<code>cancelled</code>属性的值，在<code>SDWebImageDownloaderOperation</code>中 <code>cancelled</code>属于对外是只读的</li>
<li>一个操作表示一个获取图像的动作，通常优先从缓存中取出图像，缓存中没鱼哦才需要下载，而<code>SDWebImageDownloderOperation</code>是专门用来下载的，没有包含查找缓存的功能。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line">//是否已取消</span><br><span class="line">@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;</span><br><span class="line">//下载任务</span><br><span class="line">@property (strong, nonatomic, nullable) SDWebImageDownloadToken *downloadToken;</span><br><span class="line">//取消操作</span><br><span class="line">@property (strong, nonatomic, nullable) NSOperation *cacheOperation;</span><br><span class="line">//管理类</span><br><span class="line">@property (weak, nonatomic, nullable) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>实现<code>SDWebImageOperation</code>协议的cancel的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@implementation SDWebImageCombinedOperation</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        //设置为取消状态</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        //取消的操作存在，就执行该取消操作，并置为nil</span><br><span class="line">        if (self.cacheOperation) &#123;</span><br><span class="line">            [self.cacheOperation cancel];</span><br><span class="line">            self.cacheOperation = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        //在管理类的下载任务中取消该下载任务</span><br><span class="line">        if (self.downloadToken) &#123;</span><br><span class="line">            //在下载SDWebImageDownloader类中执行取消任务操作</span><br><span class="line">            [self.manager.imageDownloader cancel:self.downloadToken];</span><br><span class="line">        &#125;</span><br><span class="line">        //安全移除该操作</span><br><span class="line">        [self.manager safelyRemoveOperationFromRunning:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    if (!operation) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //加锁是为了安全，防止正在移除该操作时有变化</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations removeObject:operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-SDWebImageManager的属性声明"><a href="#2-6-SDWebImageManager的属性声明" class="headerlink" title="2.6 SDWebImageManager的属性声明"></a>2.6 <code>SDWebImageManager</code>的属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageManager ()</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, readwrite, nonnull) SDImageCache *imageCache;</span><br><span class="line">@property (strong, nonatomic, readwrite, nonnull) SDWebImageDownloader *imageDownloader;</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t failedURLsLock; // a lock to keep the access to `failedURLs` thread-safe</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t runningOperationsLock; // a lock to keep the access to `runningOperations` thread-safe</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>imageCache</code> 和 <code>imageDownloader</code> 在.h文件中已经声明，但是只读类型。这里重复声明成读写类型，实现外部为只读，内部为读写类型。</p>
<p>两个可变集合体<code>failedURLs</code> 和 <code>runningOperations</code> 前者存储<code>NSURL</code> 类型，记录失败的urls，后者存储<code>SDWebImageCombinedOperation</code>类型，记录正在运行的操作。</p>
<p>两个信号量<code>failedURLsLock</code> 和 <code>runningOperationsLock</code>锁，为了保持访问<code>failedURLs</code> 和 <code>runningOperations</code>线程安全的。</p>
<h3 id="2-7、SDWebImageManager的方法实现"><a href="#2-7、SDWebImageManager的方法实现" class="headerlink" title="2.7、SDWebImageManager的方法实现"></a>2.7、<code>SDWebImageManager</code>的方法实现</h3><h4 id="2-7-1、初始化"><a href="#2-7-1、初始化" class="headerlink" title="2.7.1、初始化"></a>2.7.1、初始化</h4><p>三个初始化方法，单例模式确保全局只有一个实例，避免每次调用时创建新的实例。</p>
<p>使用GCD中的<code>dispatch_once</code>创建的实例对象必须确保只有一个，所以使用static修饰 <code>static dispatch_once_t once; static id instance;</code><br><code>dispatch_once</code>可以简化代码且保证线程安全，开发者无需担心加锁或同步。所有问题都在GCD底层处理。此外，<code>dispatch_once</code>更高效。它没有使用重量级的同步机制。使用同步机制，每次运行代码都需要获取锁。<code>dispatch_once</code>采用“原子访问”来查询标记，判断代码是否执行过。</p>
<p><code>[self new]</code>是一种比较老式的写法，而<code>alloc/init</code>的引入则是因为<code>new</code>不够灵活，因为使用<code>new</code>的话，会使得初始化方法被固定死只能调用<code>init</code>。而这里就是使用的<code>new</code>方法，所以调用的顺序只能是<code>sharedManager ---&gt; init ---&gt; initWithCache: downloader:</code>。</p>
<p>在<code>init</code>初始化中，可以看出<code>cache</code> 和 <code>downloader</code>也是单例模式，其实也是使用的<code>new</code>方法，原理和这里的相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//单例模式</span><br><span class="line">+ (nonnull instancetype)sharedManager &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化 cache 和 downloader</span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</span><br><span class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    return [self initWithCache:cache downloader:downloader];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里实现一些属性的初始化。</span><br><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _imageCache = cache;</span><br><span class="line">        _imageDownloader = downloader;</span><br><span class="line">        _failedURLs = [NSMutableSet new];</span><br><span class="line">        _failedURLsLock = dispatch_semaphore_create(1);</span><br><span class="line">        _runningOperations = [NSMutableSet new];</span><br><span class="line">        _runningOperationsLock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-2、功能实现方法"><a href="#2-7-2、功能实现方法" class="headerlink" title="2.7.2、功能实现方法"></a>2.7.2、功能实现方法</h4><ol>
<li>通过URL获取缓存时使用的key<br> 利用Image的URL生成一个缓存时需要的key.<br> 如果检测到cacheKeyFilter不为空时,利用cacheKeyFilter来处理URL生成一个key；否则直接返回URL的string内容,当做key.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url &#123;</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        return @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.cacheKeyFilter) &#123;</span><br><span class="line">        return self.cacheKeyFilter(url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return url.absoluteString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>图像放缩操作：根据图片中的图片组 或 scale 重新计算返回图片。该方法专门使用了一个类（<code>SDWebImageCompat</code>）来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)scaledImageForKey:(nullable NSString *)key image:(nullable UIImage *)image &#123;</span><br><span class="line">    return SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存图像</p>
</li>
</ol>
<p>通过URL缓存图像到内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)cachedImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">                     completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    //获取缓存所需的key</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    //判断内存中是否已缓存该图像</span><br><span class="line">    BOOL isInMemoryCache = ([self.imageCache imageFromMemoryCacheForKey:key] != nil);</span><br><span class="line">    </span><br><span class="line">    //如果已经缓存，在主线程中执行完成回调代码块</span><br><span class="line">    if (isInMemoryCache) &#123;</span><br><span class="line">        // making sure we call the completion block on the main queue</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                completionBlock(YES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果还未缓存，则调用 diskImageExistsWithKey，该方法会将图像缓存到磁盘中（在存储之前也会判断磁盘中是否已缓存该图像），该方法在异步线程执行。</span><br><span class="line">    [self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) &#123;</span><br><span class="line">        // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(isInDiskCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将图像缓存到磁盘中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)diskImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">                   completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">    [self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) &#123;</span><br><span class="line">        // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(isInDiskCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将图像缓存到内存中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)saveImageToCache:(nullable UIImage *)image forURL:(nullable NSURL *)url &#123;</span><br><span class="line">    if (image &amp;&amp; url) &#123;</span><br><span class="line">        NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">        [self.imageCache storeImage:image forKey:key toDisk:YES completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>取消掉所有正在执行的操作Operation</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancelAll &#123;</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    NSSet&lt;SDWebImageCombinedOperation *&gt; *copiedOperations = [self.runningOperations copy];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    [copiedOperations makeObjectsPerformSelector:@selector(cancel)]; // This will call `safelyRemoveOperationFromRunning:` and remove from the array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>判断是否有正在运行的操作Operation</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isRunning &#123;</span><br><span class="line">    BOOL isRunning = NO;</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    isRunning = (self.runningOperations.count &gt; 0);</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    return isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>安全移除正在运行的操作Operation</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    if (!operation) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations removeObject:operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>回调方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)callCompletionBlockForOperation:(nullable SDWebImageCombinedOperation*)operation</span><br><span class="line">                             completion:(nullable SDInternalCompletionBlock)completionBlock</span><br><span class="line">                                  error:(nullable NSError *)error</span><br><span class="line">                                    url:(nullable NSURL *)url &#123;</span><br><span class="line">    [self callCompletionBlockForOperation:operation completion:completionBlock image:nil data:nil error:error cacheType:SDImageCacheTypeNone finished:YES url:url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callCompletionBlockForOperation:(nullable SDWebImageCombinedOperation*)operation</span><br><span class="line">                             completion:(nullable SDInternalCompletionBlock)completionBlock</span><br><span class="line">                                  image:(nullable UIImage *)image</span><br><span class="line">                                   data:(nullable NSData *)data</span><br><span class="line">                                  error:(nullable NSError *)error</span><br><span class="line">                              cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                               finished:(BOOL)finished</span><br><span class="line">                                    url:(nullable NSURL *)url &#123;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        if (operation &amp;&amp; !operation.isCancelled &amp;&amp; completionBlock) &#123;</span><br><span class="line">            completionBlock(image, data, error, cacheType, finished, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>通过url建立一个operation用来下载图片. 返回operation</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    // Invoking this method without a completedBlock is pointless</span><br><span class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line">     //在没有completedBlock的情况下调用此方法毫无意义 ， NSAssert（completedBlock！= nil，@“如果你的意思是预取图像，请使用 - [SDWebImagePrefetcher prefetchURLs]代替”）;</span><br><span class="line"></span><br><span class="line">    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won&apos;t</span><br><span class="line">    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span><br><span class="line">  （非常常见的错误是使用NSString对象而不是NSURL发送URL。 出于某些奇怪的原因，Xcode不会抛出此类型不匹配的任何警告。在这里，我们通过允许URL作为NSString传递来确保此错误。）</span><br><span class="line">  </span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        //如果传入的url是字符串类型，则转换成NSURL类型</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    //防止应用程序崩溃类型错误，如发送NSNull而不是NSURL，则url置为nil</span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    初始化一个SDWebImageCombinedOperation对象</span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    //设置它的SDWebImageManager 等于self</span><br><span class="line">    operation.manager = self;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    //如果url存在，判断该url是否失败过，并赋值给isFailedUrl；加锁是为了安全，防止在判断的过程中被其他线程修改</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    //判断条件：如果url不存在，或者options不是SDWebImageRetryFailed（失败重试）并且isFailedUrl 为 YES。就回调一个error的block （异常处理），并返回operation</span><br><span class="line">    //error为：[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil]</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url];</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建互斥锁，执行runningOperations添加operation操作</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations addObject:operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    //获取缓存所需要的key</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">     // 下面都是判断我们的cacheOptions里包含哪些SDWebImageOptions,然后给我们的cacheOptions相应的添加对应的SDImageCacheOptions. cacheOptions |= SDImageCacheQueryDataWhenInMemory这种表达式的意思等同于cacheOptions = cacheOptions | SDImageCacheQueryDataWhenInMemory</span><br><span class="line">     </span><br><span class="line">    SDImageCacheOptions cacheOptions = 0;</span><br><span class="line">    if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">    if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">    if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line">    </span><br><span class="line">    //弱引用</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line">    /*</span><br><span class="line">    *如果图片是从内存加载，则返回的cacheOperation是nil，</span><br><span class="line">    *如果是从磁盘加载，则返回的cacheOperation是`NSOperation`对象。</span><br><span class="line">    *如果是从网络加载，则返回的cacheOperation对象是`SDWebImageDownloaderOperation`对象。</span><br><span class="line">    */</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">        //强引用，防止被提前释放</span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        //operation不存在或者已经被取消，返回并移除该operation对象</span><br><span class="line">        if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Check whether we should download image from network</span><br><span class="line">        //检查是否应该从网络下载图像</span><br><span class="line">        BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</span><br><span class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</span><br><span class="line">            &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);</span><br><span class="line">          </span><br><span class="line">        //应该从网络下载图像  </span><br><span class="line">        if (shouldDownload) &#123;</span><br><span class="line">            //如果缓存图像存在，但options设置为SDWebImageRetryFailed。则先返回缓存图像</span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                //构建回调block</span><br><span class="line">                [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">             /*</span><br><span class="line">             把图片加载的`SDWebImageOptions`类型枚举转换为图片下载的`SDWebImageDownloaderOptions`类型的枚举</span><br><span class="line">             */</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            /*</span><br><span class="line">             如果设置了强制刷新缓存的选项。则`SDWebImageDownloaderProgressiveDownload`选项失效并且添加`SDWebImageDownloaderIgnoreCachedResponse`选项。</span><br><span class="line">             */</span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // force progressive off if image already cached but forced refreshing</span><br><span class="line">                //如果图像已缓存但强制刷新，则强制渐进关闭</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                //忽略从NSURLCache读取的图像，如果图像缓存但强制刷新</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</span><br><span class="line">            __weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            /*</span><br><span class="line">             新建一个网络下载的操作。</span><br><span class="line">             */</span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;</span><br><span class="line">                //如果操作被取消或者不存在，则不执行任何操作</span><br><span class="line">                if (!strongSubOperation || strongSubOperation.isCancelled) &#123;</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125; else if (error) &#123;</span><br><span class="line">                    //如果加载出错。则直接返回回调。并且添加到failedURLs中</span><br><span class="line">                    [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url];</span><br><span class="line">                    BOOL shouldBlockFailedURL;</span><br><span class="line">                    // Check whether we should block failed url</span><br><span class="line">                    //检查我们是否应该阻止失败的网址</span><br><span class="line">                    if ([self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)]) &#123;</span><br><span class="line">                        shouldBlockFailedURL = [self.delegate imageManager:self shouldBlockFailedURL:url withError:error];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotConnectToHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    //如果shouldBlockFailedURL为YES，即阻止失败的网址，添加到failedURLs中</span><br><span class="line">                    if (shouldBlockFailedURL) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs addObject:url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                //加载图片成功，</span><br><span class="line">                    //如果options选项设置为SDWebImageRetryFailed，则把url从failedURLS中移除</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs removeObject:url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //是否缓存在磁盘上</span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line">                    </span><br><span class="line">                    // We&apos;ve done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.（我们已经使用共享管理器在SDWebImageDownloader中完成了缩放过程，这用于自定义管理器并避免额外的扩展。）</span><br><span class="line">                    </span><br><span class="line">                    //如果self不为SDWebImageManager单例，并且cacheKeyFilter（缓存可以代码块存在，下载的图像存在），则缩放下载的图像</span><br><span class="line">                    if (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</span><br><span class="line">                        downloadedImage = [self scaledImageForKey:key image:downloadedImage];</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果options选项为SDWebImageRefreshCached，并且缓存图像存在，下载图像不存在。图像刷新命中NSURLCache缓存，不调用完成块</span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                        //图像刷新命中NSURLCache缓存，不调用完成块</span><br><span class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                     //如果成功下载图片。并且图片是动态图片。并且设置了SDWebImageTransformAnimatedImage属性。则处理图片</span><br><span class="line">                     </span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            //获取transform以后的图片</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line">                            //存储transform以后的的图片</span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                NSData *cacheData;</span><br><span class="line">                                // pass nil if the image was transformed, so we can recalculate the data from the image（如果图像被转换，则传递nil，因此我们可以重新计算图像中的数据）</span><br><span class="line">                                </span><br><span class="line">                                //cacheSerializer：将图像缓存到磁盘的解码算法，返回的是data。如果self.cacheSerializer存在，则重新计算图像中的数据。</span><br><span class="line">                                if (self.cacheSerializer) &#123;</span><br><span class="line">                                    cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">                                &#125;</span><br><span class="line">                               //存储transform以后的图片</span><br><span class="line">                                [self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                             //回调拼接</span><br><span class="line">                            [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; else &#123;//如果成功下载图片。并且图片不是图片。则直接缓存和回调</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            //cacheSerializer：将图像缓存到磁盘的解码算法，返回的是data。如果self.cacheSerializer存在，则重新计算图像中的数据。</span><br><span class="line">                            if (self.cacheSerializer) &#123;</span><br><span class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                                    NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);</span><br><span class="line">                                     //存储transform以后的图片</span><br><span class="line">                                    [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                //存储transform以后的图片</span><br><span class="line">                                [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                         //回调拼接</span><br><span class="line">                        [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //从正在加载的图片操作集合中移除当前操作</span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    [self safelyRemoveOperationFromRunning:strongSubOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; else if (cachedImage) &#123;</span><br><span class="line">            //如果缓存的图像存在，回调拼接，安全移除Operation对象</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Image not in cache and download disallowed by delegate（委托不允许图像不在缓存和下载中）</span><br><span class="line">             //如果缓存的图像不存在，回调拼接，安全移除Operation对象</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8、SDWebImageCompat的图像缩放操作"><a href="#2-8、SDWebImageCompat的图像缩放操作" class="headerlink" title="2.8、SDWebImageCompat的图像缩放操作"></a>2.8、<code>SDWebImageCompat</code>的图像缩放操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  放缩操作：根据图片中的图片组 或 scale 重新计算返回图片</span><br><span class="line">    *</span><br><span class="line"> *  @param key   键：就是图片的地址</span><br><span class="line"> *  @param image UIImage</span><br><span class="line">    *</span><br><span class="line"> *  @return UIImage</span><br><span class="line">    */</span><br><span class="line">inline UIImage *SDScaledImageForKey(NSString * _Nullable key, UIImage * _Nullable image) &#123;</span><br><span class="line">    //图片为空，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#if SD_MAC //如果是MAC，直接返回图片</span><br><span class="line">    return image;</span><br><span class="line">#elif SD_UIKIT || SD_WATCH //iOS或者watch</span><br><span class="line">    if ((image.images).count &gt; 0) &#123;//动态图</span><br><span class="line">        NSMutableArray&lt;UIImage *&gt; *scaledImages = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">        for (UIImage *tempImage in image.images) &#123;</span><br><span class="line">            //动态图还是执行该方法，处理单个图片</span><br><span class="line">            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //创建一个动态图片，动态图片持续的时间为duration</span><br><span class="line">        UIImage *animatedImage = [UIImage animatedImageWithImages:scaledImages duration:image.duration];</span><br><span class="line">        if (animatedImage) &#123;</span><br><span class="line">            animatedImage.sd_imageLoopCount = image.sd_imageLoopCount;</span><br><span class="line">            animatedImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">        &#125;</span><br><span class="line">        return animatedImage;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">#if SD_WATCH</span><br><span class="line">        if ([[WKInterfaceDevice currentDevice] respondsToSelector:@selector(screenScale)]) &#123;</span><br><span class="line">#elif SD_UIKIT</span><br><span class="line">        if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line">#endif</span><br><span class="line">           // 比如屏幕为320x480时，scale为1，屏幕为640x960时，scale为2</span><br><span class="line">            CGFloat scale = 1;</span><br><span class="line">            // “@2x.png”的长度为7，所以此处添加了这个判断，很巧妙</span><br><span class="line">            if (key.length &gt;= 8) &#123;</span><br><span class="line">                //根据后缀给scale赋值</span><br><span class="line">                NSRange range = [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = 2.0;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                range = [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = 3.0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用initWithCGImage来根据Core Graphics的图片构建UIImage。</span><br><span class="line">            // 这个函数可以使用scale和orientation</span><br><span class="line">            UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</span><br><span class="line">            scaledImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">            image = scaledImage;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSString *const SDWebImageErrorDomain = @&quot;SDWebImageErrorDomain&quot;;</span><br></pre></td></tr></table></figure>
      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2018/09/29/2018-09-29-Read-SDWebImage-note1/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2018-10-01 09:38:06
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/SDWebImage/" title="SDWebImage">
                        <b>#</b> SDWebImage
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2018/10/02/2018-10-02-Read-SDWebImage-SDImageCache/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、整体框架"><span class="toc-text">1、整体框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、SDWebImageManager类分析"><span class="toc-text">2、SDWebImageManager类分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#先看下-h文件"><span class="toc-text">先看下.h文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1、公共枚举"><span class="toc-text">2.1、公共枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2、公共类型定义"><span class="toc-text">2.2、公共类型定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3、协议：SDWebImageManagerDelegate"><span class="toc-text">2.3、协议：SDWebImageManagerDelegate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4、协议：属性和方法"><span class="toc-text">2.4、协议：属性和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#再看-m文件-的声明"><span class="toc-text">再看.m文件 的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-SDWebImageCombinedOperation的属性声明和协议方法实现"><span class="toc-text">2.5 SDWebImageCombinedOperation的属性声明和协议方法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-SDWebImageManager的属性声明"><span class="toc-text">2.6 SDWebImageManager的属性声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7、SDWebImageManager的方法实现"><span class="toc-text">2.7、SDWebImageManager的方法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1、初始化"><span class="toc-text">2.7.1、初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2、功能实现方法"><span class="toc-text">2.7.2、功能实现方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8、SDWebImageCompat的图像缩放操作"><span class="toc-text">2.8、SDWebImageCompat的图像缩放操作</span></a></li></ol></li></ol>
    </div>
  </div>

  <script src="/js/catalog.js"></script>



    
      <div class="comments-container">
        





      </div>
    
  </div>


        <div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" href="https://github.com/guohuaCabin">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="qinguohua@qinguohua.fun">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    <div class="footer-more">
      
        Copyright © Oranges 2021
        
    </div>
  
    <div class="footer-more">
      
        灾难总是接踵而至，这正是世间的常理。只要找个理由，就会有谁来救你吗？要是死了，就只是说明我不过是如此程度的男人。
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>

<script src="/js/backtotop.js"></script>


        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  <script src="/js/colorscheme.js"></script>




        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E8%AF%BBSDWebImage%20%E4%BA%8C%20(SDWebImageManager) + '&url=' + https%3A%2F%2Fqinguohua.fun%2F2018%2F10%2F01%2F2018-10-01-Read-SDWebImage-SDWebImageManager%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://qinguohua.fun/2018/10/01/2018-10-01-Read-SDWebImage-SDWebImageManager/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  <script src="/js/shares.js"></script>


      </div>
    </div>
  </body>
</html>
