<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>copy 和 mutableCopy | 所念皆星辰 | 踏实、低调、前行。</title>

  
  <meta name="author" content="Wheat">
  

  
  <meta name="description" content="简单的一个技术博客，用来作为学习笔记和日常记录使用。">
  

  
  
  <meta name="keywords" content="copy, mutableCopy">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="copy 和 mutableCopy"/>

  <meta property="og:site_name" content="所念皆星辰"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="所念皆星辰" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">所念皆星辰</a>
    </h1>
    <p class="site-description">踏实、低调、前行。</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>copy 和 mutableCopy</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/30/copyAndMutableCopy/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-30T06:16:37.000Z">
          2018-06-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>今天来谈下深浅拷贝【copy 和 mutableCopy】</p>
<p>想写这篇文章，是因为看到了一个有意思的文章，对于其中的一些观点不太认同，所以想简单分析一下深浅拷贝</p>
<p>先看一段代码，稍后会对代码进行分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)testOne</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *test = @[@1,@2,@3];</span><br><span class="line">    NSLog(@&quot;test-&gt;%p\n&quot;,test);</span><br><span class="line">    NSArray *testCopy = [test copy];</span><br><span class="line">    NSLog(@&quot;testCopy-&gt;%p\n&quot;,testCopy);</span><br><span class="line">    NSArray *testMutableCopy = [test mutableCopy];</span><br><span class="line">    NSLog(@&quot;testMutableCopy-&gt;%p\n&quot;,testMutableCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong></p>
<p>很简单的创建一个数组，对其进行copy和mutableCopy操作，打印其内存地址。结果看图会知道：<br>test和testCopy 内存地址是一样的，而testMutableCopy的内存地址是和test不同的。</p>
<p><strong>小总结：</strong></p>
<ol>
<li><code>copy</code> 只是拷贝指向对象的指针，并没有出现新的内存地址，我们称之为<strong>浅拷贝</strong>：</li>
<li><code>mutableCopy</code> 拷贝整个对象内存到另一块内存中，是产生了新的内存地址。</li>
</ol>
<p><img src="http://blog.guohuaden.com/copyAndMutableCopy_one.png" alt="copy和mutableCopy操作1"></p>
<hr>
<p>再看下面的一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(void)testTwo</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;\n&quot;);</span><br><span class="line">    NSMutableArray *test2 = [NSMutableArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;, nil];</span><br><span class="line">    NSLog(@&quot;test2-&gt;%p\n&quot;,test2);</span><br><span class="line">    NSMutableArray *testCopy2 = [test2 copy];</span><br><span class="line">    NSLog(@&quot;testCopy2-&gt;%p\n&quot;,testCopy2);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *testMutableCopy2 = [test2 mutableCopy];</span><br><span class="line">    NSLog(@&quot;testMutableCopy2-&gt;%p\n&quot;,testMutableCopy2);</span><br><span class="line">    </span><br><span class="line">    [test2 addObject:@&quot;A&quot;];</span><br><span class="line">    </span><br><span class="line">    //这里不能对数组做操作， 可变数组的copy属于深拷贝，和mutableCopy一样都是将数组拷贝一份存入新的内存中，但通过mutableCopy得到的可变数组可以再操作，而copy出来的是不可变数组。</span><br><span class="line">//    [testCopy2 removeObject:@&quot;1&quot;];</span><br><span class="line">//    [testCopy2 addObject:@&quot;B&quot;]; </span><br><span class="line">    </span><br><span class="line">    [testMutableCopy2 addObject:@&quot;C&quot;];</span><br><span class="line">    [testMutableCopy2 removeObject:@&quot;3&quot;];</span><br><span class="line">    NSLog(@&quot;test2 = %@, testCopy2 =%@,testMutableCopy2 = %@&quot;,test2,testCopy2,testMutableCopy2);</span><br><span class="line">    </span><br><span class="line">    //打印结果： test2 = @[1,2,3,A]   testCopy2 = @[1,2,3]   testMutableCopy2 = @[1,2,3,C]</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong><br>上面这段代码会和之前的不一样，我们这里创建的是一个可变数组，然后对可变数组进行<code>copy</code>和<code>mutableCopy</code>操作。发现打印其内存地址都不一样，<br>这说明对可变数组进行<code>copy</code>和<code>mutableCopy</code>都是深拷贝。<br>但你会发现<code>copy</code>得到的数组不能添加删除操作，这是因为<code>copy</code>得到的是不可变数组。</p>
<p><strong>小总结：</strong></p>
<p>可变数组的<code>copy</code>和<code>mutableCopy</code>都是深拷贝</p>
<p><img src="http://blog.guohuaden.com/copyAndMutableCopy_two.png" alt="copy和mutableCopy操作2"></p>
<p>最后一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(void)testThree</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *test4 = [NSMutableArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;, nil];</span><br><span class="line">    NSMutableArray *newTest = [NSMutableArray arrayWithObject:test4];</span><br><span class="line">    NSMutableArray *testMutableCopy4 = [newTest mutableCopy];//拷贝出来的是NSMutableArray类型数组</span><br><span class="line">    NSLog(@&quot;newTest-&gt;%p,testMutableCopy4-&gt;%p\n&quot;,newTest,testMutableCopy4);</span><br><span class="line">    </span><br><span class="line">    //copy的先不说， 我们看下mutableCopy得到的数组，你会发现通过mutableCopy得到的数组中的元素地址是不变的</span><br><span class="line">    NSLog(@&quot;newTest.first-&gt;%p,testMutableCopy4first-&gt;%p\n&quot;,newTest.firstObject,testMutableCopy4.firstObject);</span><br><span class="line">    </span><br><span class="line">    //test</span><br><span class="line">    [testMutableCopy4.firstObject addObject:@6];</span><br><span class="line">    [newTest.firstObject addObject:@&quot;12&quot;];</span><br><span class="line">    </span><br><span class="line">    //打印出来这里两个数组，会发现结果是一样的，原因就是mutableCopy的深拷贝是容器和其中的元素，但元素的地址并没有改变，修改其中的元素中的内容，结果必然都改变</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;newTest = %@,testMutableCopy2 = %@&quot;,newTest,testMutableCopy4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong></p>
<p>通过<code>mutableCopy</code>得到的数组，你会发现通过<code>mutableCopy</code>得到的数组中的元素地址是不变的。如果你往数组的元素中添加或删除元素，会发现newTest和testMutableCopy4中的元素都发生了改变。</p>
<p><strong>小总结：</strong></p>
<p>集合对象的内容复制（mutableCopy）仅限于对象本身，对象中的元素仍然是指针复制。</p>
<p><img src="http://blog.guohuaden.com/copyAndMutableCopy_four.png" alt="copy和mutableCopy操作4"></p>
<p>关于这点其实苹果官网文档中<code>CopyFunctions</code>给了解释，看下以下介绍：</p>
<p><strong>关于复制的介绍：</strong></p>
<blockquote>
<p>Copy Functions<br>In general, a standard copy operation, which might also be called simple assignment, occurs when you use the = operator to assign the value of one variable to another. The expression myInt2 = myInt1, for example, causes the integer contents of myInt1 to be copied from the memory used by myInt1 into the memory used by myInt2. Following the copy operation, two separate areas of memory contain the same value. However, if you attempt to copy a Core Foundation object in this way, be aware that you will not duplicate the object itself, only the reference to the object.</p>
</blockquote>
<blockquote>
<p>For example, someone new to Core Foundation might think that to make a copy of a CFString object she would use the expression myCFString2 = myCFString1. Again, this expression does not actually copy the string data. Because both myCFString1 and myCFString2 must have the CFStringRef type, this expression only copies the reference to the object. Following the copy operation, you have two copies of the reference to the CFString. This type of copy is very fast because only the reference is duplicated, but it is important to remember that copying a mutable object in this way is dangerous. As with programs that use global variables, if one part of your application changes an object using a copy of the reference, there is no way for other parts of the program which have copies of that reference to know that the data has changed.</p>
</blockquote>
<blockquote>
<p>If you want to duplicate an object, you must use one of the functions provided by Core Foundation specifically for this purpose. Continuing with the CFString example, you would use CFStringCreateCopy to create an entirely new CFString object containing the same data as the original. Core Foundation types which have “CreateCopy” functions also provide the variant “CreateMutableCopy” which returns a copy of an object that can be modified.</p>
</blockquote>
<p><strong>浅拷贝：</strong></p>
<blockquote>
<p>Shallow Copy<br>Copying compound objects, objects such as collection objects that can contain other objects, must also be done with care. As you would expect, using the = operator to perform a copy on these objects results in a duplication of the object reference. In contrast to simple objects like CFString and CFData, the “CreateCopy” functions provided for compound objects such as CFArray and CFSet actually perform a shallow copy. In the case of these objects, a shallow copy means that a new collection object is created, but the contents of the original collection are not duplicated—only the object references are copied to the new container. This type of copy is useful if, for example, you have an array that’s immutable and you want to reorder it. In this case, you don’t want to duplicate all of the contained objects because there’s no need to change them—and why use up that extra memory? You just want the set of included objects to be changed. The same risks apply here as with copying object references with simple types.</p>
</blockquote>
<p><strong>深拷贝：</strong></p>
<blockquote>
<p>Deep Copy<br>When you want to create an entirely new compound object, you must perform a deep copy. A deep copy duplicates the compound object as well as the contents of all of its contained objects. The current release of Core Foundation includes a function that performs deep copying of a property list (see CFPropertyListCreateDeepCopy). If you want to create deep copies of other structures, you could perform the deep copy yourself by recursively descending into the compound object and copying all of its contents one by one. Take care in implementing this functionality as compound objects can be recursive—they may directly or indirectly contain a reference to themselves—which can cause a recursive loop.</p>
</blockquote>
<p>引用自：<a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/CopyFunctions.html#//apple_ref/doc/uid/20001149-CJBEJBHH" target="_blank" rel="noopener">苹果官网文档-CopyFunctions</a></p>
<p><strong>小总结：</strong></p>
<p>我们通过对集合类对象进行mutableCopy得到的新对象，从某种意义上来说，并不是真正的深层次的复制，严格意义上说：它只是一个单层次的深复制。原因上面已说明：集合对象的内容复制（mutableCopy）仅限于对象本身，对象中的元素仍然是指针复制。</p>
<p>那如果需要深层次的复制，就需要以递归的形式找到集合中的元素对象，再对元素对象进行mutableCopy，以此来实现深层次的复制。但Apple并不提倡这种方式，因为这可能会导致递归循环。</p>
<p>最后总结：</p>
<ol>
<li>不管是集合类对象还是非集合类对象，copy和mutableCopy时，都遵循以下准则：<ol>
<li>copy得到的都是不可变对象（imutable），所以对其copy返回的对象做可变对象的操作，都会崩溃。</li>
<li>mutableCopy返回的是可变对象（mutable）</li>
</ol>
</li>
<li>在非集合类对象中：<ol>
<li>对不可变对象进行copy操作，是指针复制，其内存地址不变。</li>
<li>对不可变对象进行mutableCopy操作，是内容复制，其内存地址改变。</li>
<li>对可变对象进行copy和mutableCopy操作，都是内容复制，其内存地址改变。</li>
</ol>
</li>
<li>在集合类对象中：<ol>
<li>对不可变对象进行copy操作，是指针复制，其内存地址不变。</li>
<li>对不可变对象进行mutableCopy操作，是内容复制，其内存地址改变。</li>
<li>对可变对象进行copy和mutableCopy操作，都是内容复制，其内存地址改变。但集合对象的内容复制仅限于对象本身，对象中的元素仍然是指针复制。</li>
</ol>
</li>
</ol>
<p>最后可以看下这个Apple的官方文档《<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW1" target="_blank" rel="noopener">苹果官网文档-Copying</a>》</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/iOS/">iOS</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/copy-mutableCopy/">copy, mutableCopy</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Wheat
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'GTM-NHB73SK', 'auto');
    ga('send', 'pageview');

</script>

    
<script>
    var _hmt = _hmt || [];
    ( function () {
        var hm = document.createElement( "script" );
        hm.src = "https://hm.baidu.com/hm.js?ae05530a6a007cdb8063cf611691cc3e";
        var s = document.getElementsByTagName( "script" )[ 0 ];
        s.parentNode.insertBefore( hm, s );
    } )();
</script>

  </div>
</div>
</body>
</html>